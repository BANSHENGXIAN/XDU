## 简单题（26）

###  3.16-两数之和

本算法就一般做法即可，没有什么太需要注意的点。



+++



### 3.17-括号（栈）

- 在C++中，计算字符串的长度可以使用`size()`这个函数。

```cpp
string s = "ABCDEF";
cout << s.size() << endl;
```

 

**题目：**给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s`，判断字符串是否有效。

**要求：**

1. 左括号必须用相同类型的右括号闭合

2. 左括号必须以正确的顺序闭合。

本题目使用栈容器来实现。

**思路：**

1. 栈——FILO（先进后出），所以可以把要比较的字符串存到栈中
2. 利用`unordered_map<char , char>` 哈希表来实现，即左括号做`key`值来匹配

**代码如下：**

```cpp
class Solution {
public :
	bool isValid(string s) {
		if (s.size() % 2 == 1)
			return false;
		
		//map 容器，只能 key 值允许遍历
		unordered_map<char, char> pairs = {
			{ '}','{'},
			{']','['},
			{')','('},

		};
		//在遍历s中，遇到右括号，就进行匹配，左括号，就入栈
		stack<char> stk;
		for (char ch : s) { //这里遍历的条件是  ch  只遍历 key 值
			if (pairs.count(ch)) {
				if (stk.empty() || stk.top() != pairs[ch])
					return false;
				stk.pop();
			} else {
				stk.push(ch);
			}
		}

		return stk.empty();

	}
};

```



> 总结： 本题目最关键的地方在于用==栈==容器解决，同时又用到了`unorder_map`。
>
> ​			   对于哈希表来讲，只有`key`值是允许操作的，所以在pairs中右括号为`key值`



---

### 3.20 整数取反

**题目：**给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

**要求：**如果反转后整数超过 32 位的有符号整数的范围 [−2^31^, 2^31^ − 1] ，就返回 0。

**思路：**将所给的数按位取余，然后反向输出。

**注意：**这里容易溢出。所谓溢出，例如：`4bit`的数最大为16，而16反向的话为61，这个数就超过了所允许的最大范围。

> 采用取余将数按位取出。

```c++ 
class Solution{
 public:
   int reverse(int x) {
		long n = 0;
		while (x!=0) {
			n = n * 10 + x % 10;
			x /= 10;
			
		}

		return (int)n == n ? (int)n : 0; //在看到三目运算符的时候，首先考虑== 为最后优先级
	}
		
}
```





+++



### 3.22  合并两个有序链表

**题目：**将两个升序链表合并为一个新的 **升序** 链表并返回。

**要求：**新链表是通过拼接给定的两个链表的所有节点组成的。

**思路：**首先弄清楚链表的结构，问题就解决一大半了

> **知识补充：**链表(具体查看Manuscript)
>
> ​	首指针 `Head`--> `l1` --> `l2`，当插入其他链表时候，有`s->next=p->next` 	`p->next=s`
>
>  	`p->next`表示的是p的下个指向，而`p=p->next`是改写p的内容

```c++
struct ListNode {
  int val;
  ListNode *next;
  ListNode() : val(0), next(nullptr) {}
  ListNode(int x) : val(x), next(nullptr) {}
  ListNode(int x, ListNode *next) : val(x), next(next) {}
};
 
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *Head= new ListNode(-1);
        ListNode *p=Head;

        while(l1!=nullptr&&l2!=nullptr){
            if(l1->val<l2->val){
                p->next=l1;//改指针指向
                 l1=l1->next;
            }else{
                p->next=l2;
                l2=l2->next;
            }
            p=p->next;//改写指针p
        }
        p->next= l1==nullptr?l2:l1;
        return Head->next;
    }
};
```



### 3.22 回文数

**题目：**给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

**要求：**回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，`121` 是回文，而 `123` 不是。

**思路：**负数都不是回文数，剩下的按位取反比较即可。

```cpp
class Solution {
public:
public:
	bool isPalindrome(int x) {
		long n = 0;
		int temp = x;
		if (x < 0) {
			return false;
		} else {
			while (x != 0) {
				n = x % 10  + n * 10;  // 这里总会存在溢出的问题，避免不掉。
				x /= 10;
			}
			return n == temp;
		}
		
	}
};
```



```cpp
//参考答案如下：计算下怎么找出反转的位置
int revertNumber = 0;
	if (x < 0 ||(x % 10 == 0 && x != 0))
			return false;

	while (x > revertNumber) {
		revertNumber = x % 10 + revertNumber * 10;
			x /= 10;
		}

		return x == revertNumber || x == revertNumber / 10;  //这里是把奇数位去掉
	}
```

 

### 3.22  最长公共前缀

**题目：**编写一个函数来查找字符串数组中的最长公共前缀。

**要求：**如果不存在公共前缀，返回空字符串 `""`。

**思路：** 写一个比较函数，用来比较该数组的第一个数据跟第二个数据相同的部分，并把这部分看作公共前缀由此来找出最长的公共前缀。

```cpp
class Solution {
public:
	string longestCommonPrefix(vector<string> &strs) {
		int count = strs.size();		
		if (!strs.size())
			return "";
		string prefix = strs[0];
		for (int i = 0; i < count; i++) {
			prefix = compare(prefix, strs[i]);
			if (!prefix.size())
				break;
		}
		return prefix;
	}

	string compare(const string &str1, const string &str2) {
		int index = 0;
		int length = min(str1.size(), str2.size());
		while (str1[index] == str2[index] && index < length)	
			index++;	//这条语句一定要判断完成后才能执行，
        				//如若放到判断条件中，会导致即使条件不成立也会+1 的操作
		return str1.substr(0, index);
	}
	
};

```



> 注意：`while(str1[index++]==str2[index++])`这条语句会导致，无论while中的判断条件是否成立，index都会做`+1`的操作，这与我们预期不符。我们期望的是，如果判断条件成立才选择+1。



### 3.22 删除有序数组中的重复项

**题目：**给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。

**要求：**不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

**说明:**

```cpp
/*为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:
*/

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}


```



**思路：**两两比较，如果前面的值跟后面的值不一样，就正常排序。具体看下面代码。

```cpp
class Solution {
public:
	int removeDuplicates(vector<int>& nums) {
		if (nums.size() < 2)
			return nums.size();
		int index = 0;
		for (int j = 1; j < nums.size(); j++) {
			if (nums[j] != nums[index]) {
				index++;
				nums[index] = nums[j]; 
			}		
		}
		return  i + 1;
	}
};
```



### 3.22 最大子序和

**题目：**给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**思路：**结果序列中肯定是正数数目大于其他子序列，且有最大的正数值。

```cpp
class Solution {
public:
	int maxSubArray(vector<int>& nums) {
		int sum = 0;
		int res = nums[0];
		//下面这个序列，当sum < 0 的时候，应该都舍弃掉，
    	//因为当sum = 0 的时候是临界值，这样也是下个正数值最大。
        //如果是负数，势必会造成sum减小
		for (int n : nums) {
			if (sum > 0)
				sum += n;
			else
				sum = n;
			res = max(res, sum);
		}
		return res;
	}
};
```

> 如果sum是个正数，那么它对于后面的序列是有正增益的；相反，如果是个`<0`的数，则会是负增益。



+++

 

### 3.23 爬楼梯

**题目：**假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 

**思路：**看评论中有人写的，这是一个斐波那契数列，即前面的两项的和等于下一项。

```cpp
class Solution {
public:
	int climbStairs(int n) {
		int j = 1;
		int k = 2;
		if (n <= 2)
			return n;
		for (int i = 3; i <= n; i++) {
			int temp = j + k;
			j = k;
			k = temp;
		}
		return k;
	}

};
```

​           



### 3.23 对称二叉树

**题目：**给定一个二叉树，检查它是否是镜像对称的**。**

**要求：**你可以运用递归和迭代两种方法解决这个问题吗。

**思路：**检查根节点是否为0，如若为0，则为对称的；如不为0，检查左子树的左节点跟右子树的右节点，左子树的右节点跟右子树的左节点是否相同即可。



```cpp
//递归做法
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
       return mirror(root,root);
    }

    bool mirror(TreeNode* p ,TreeNode *q){
        if(!q && !p )
            return true;
        if(!p ||!q)
            return false;
        if(p->val== q->val) //下边要重复利用这个判断语句才能实现递归的功能。
            return mirror(p->left,q->right)&&mirror(p->right,q->left);
        return false; //这步不可省略，因为当上面条件不满足的时候，编译器会报错。
    }
};
```



> 这里注意，不能利用非递归方法实现，因为要判断的是一个树，即很多元素，所以只能用递归，一次次判断才可以。



### 3.23 二叉树的最大深度

**题目：**给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。其中，叶子节点是指没有子节点的节点。

**思路：**看参考答案是利用了递归算法。

```cpp
//一直判断节点是否为叶子节点，直到最远的子结点为叶子结点即为判断完毕。
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        return max(maxDepth(root->left), maxDepth(root->right))+1;
    }
};
```



> 1. **递归:**程序调用自身的编程技巧称为递归,是函数自己调用自己.一个函数在其定义中直接或间接调用自身的一种方法,它通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决,可以极大的减少代码量.递归的能力在于用有限的语句来定义对象的无限集合。
>
> 2. **迭代:**利用变量的原值推算出变量的一个新值.如果递归是自己调用自己的话,迭代就是A不停的调用B。
>
> 3. 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换.能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出。



### 3.23 买卖股票的最佳时机

**题目：**给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

**要求：**返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**思路：**总的来说就是找==最值==得问题。首先比较下当前的值与上次值的大小，选出最小的值即可。

```cpp
class Solution{
public:
    int maxProfit(vector<int> &prices){
        if(prices.size() < 2)
            return 0;
        int profit = 0;
        int buy = prices[0];
        for(int i = 1; i < prices.size(); i++){
            profit = max(profit, prices[i] - buy);  //找最大值卖出，如若未负值，则为0。
            buy = min(buy, prices[i]); 				//以最小值买入
		}
        return profit;
	}
};
```



### 3.23 只出现一次的数字

**题目：**给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**要求：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**思路：**看参考答案知，本题目应该利用==异或运算==。

> 其中，==异或运算==有以下几点：
>
> 1. 交换律：`a⊕b⊕c <=> a⊕c⊕b`
> 2. 任何数于0异或为任何数 `0 ⊕ n = n`
> 3. 相同的数异或为0: `n ⊕ n = 0`

```cpp
class Solution {
public:
	int singleNumber(vector<int>& nums) {
		int single = 0;
		for (auto e : nums)
			single ^= e;
		return single;
	}
};

```



### 3.23 环形链表

**题目：**给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 -1，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。

**要求：**如果链表中存在环，则返回 true 。 否则，返回 false 。

**思路：**参考答案中说，本题目主要考察快慢链表。只要有个一直快两次的，那么他们终会相遇。

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) { 
        if(head == nullptr || head->next == nullptr)
            return false;

        ListNode *fast= head->next;
		ListNode *slow= head ;
         while(fast !=nullptr && fast->next != nullptr){
		    fast = fast->next->next;
		    slow = slow->next;
		    if (fast == slow)
			    return true;     
        }      
		return false;
    }
};
```



### 3.23 最小栈

**题目：**设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的。

```cpp
  /* push(x) —— 将元素 x 推入栈中。
   pop() —— 删除栈顶的元素。
   top() —— 获取栈顶元素。
   getMin() —— 检索栈中的最小元素。
   */
```



**思路：**参考答案写法。这里有一点，==如果用stack来确定最值问题，那么在入栈的时候最好就能判断出大小。==

```cpp
class MinStack {
 public:
	 /** initialize your data structure here. */
	 
	 MinStack() {
		 min_stk.push(INT_MAX);
	 }

	 void push(int val) {
		 x_stk.push(val);
		 min_stk.push(min(min_stk.top(), val));
	 }

	 void pop() {
		 x_stk.pop();
		 min_stk.pop();
	 }

	 int top() {
		 return x_stk.top();
	 }

	 int getMin() {		 
		 return min_stk.top();		
	 }

 public:
	 stack<int> x_stk;
	 stack<int> min_stk;
 };

```



### 3.23 相交链表

**题目：**编写一个程序，找到两个单链表相交的起始节点。

**思路：**我走过你走过的路，你走过我走过的路；如若最终相遇，那么我们必在之前就遇到过，且一并共赴终点。我们之前相遇的点为：你原本走过的路与我原本走过的路之和。

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA == nullptr || headB == nullptr)
            return nullptr;
         ListNode *pA = headA;
         ListNode *pB = headB;
         while(pA != pB){
             pA = pA == nullptr ? headB: pA-> next;
             pB = pB == nullptr ? headA: pB-> next;
         }
          return  pA;
    }
};

```



### 3.23  多数元素

**题目：**给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** ⌊ n/2 ⌋的元素。

**思路：**Boyer-Moore 投票算法。

> ==摩尔投票法：==
>
> 核心就是对拼消耗。
>
> 玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。
>
> 那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。
>
> 最后能剩下的必定是自己人。

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
		int count = 0;
		int candinate = -1;
		for (auto e : nums) {
			if (count == 0)
				candinate = e;
			count += (candinate == e) ? 1 : -1;
		}
 
		return candinate;
	}
};

```



### 3.23 反转一个单链表

**题目：**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**要求：**你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

**思路：**本质上就是将本次节点指针的指向改成指向前面节点。

```cpp
//迭代算法
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev =nullptr;
        ListNode *curr = head ;

        while(curr){
            ListNode *next = curr->next;
            curr->next =prev; // 更改指向
            prev = curr; //指针移动
            curr = next;
        }
        return prev ;
    }
};
```



```cpp
//递归算法
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};

```



> ==递归算法：==
>
> 1. 首先满足一个大问题能分解为若干个子问题；
> 2. 子问题的解决方案同大问题；
> 3. 存在最小子问题。



+++



### 3.24 翻转二叉树

**思路：**用递归的方法实现。

**递归：**

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) {
            return root;
        }
        TreeNode *leftTree = invertTree(root->left);
        TreeNode *rightTree = invertTree(root->right);
        root->left = rightTree;
        root->right = leftTree;
        return root;
    }
};
```



>  ==递归方法总结：==
>
> 1. 首先找到最小的问题的变量，即“递”下来；
> 2. 找到最小问题的解决方法，即“归”上去；



### 3.24 回文链表

**题目：**请判断一个链表是否为回文链表。

**思路：**查看参考答案，将链表中的值复制到数组中，然后使用双指针的办法来判断。

```cpp
class Solution {
public:
	bool isPalindrome(ListNode* head) {
		vector<int> v;

		while (head != nullptr) {
			v.emplace_back(head->val);
			head = head->next;
		}

		for (int i = 0, j = v.size() - 1; i < j; i++, j--) {
			if (v[i] != v[j])
				return false;
		}
		return true;
	}
};
```





### 3.24 移动零

```cpp
class Solution {
public:
	void moveZeroes(vector<int>& nums) {
		int length = nums.size();
		int index = 0;
		for (int i = 0; i < length; i++) {
			if (nums[i] != 0)
				nums[index++] = nums[i];
		}
		for (int i = index; i < length; i++) {
			nums[i] = 0;
		}

	}
};
```



### 3.24 找到所有数组中消失的数字

**题目：**给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次，找到所有在 [1, n] 范围之间没有出现在数组中的数字。

**要求：**您能在不使用额外空间且时间复杂度为*O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

**思路：**（盗来的——评论）将所有正数作为数组下标，置对应数组值为负值。那么，仍为正数的位置即为（未出现过）消失的数字。举个例子：

- 原始数组：[4,3,2,7,8,2,3,1]
- 重置后为：[-4,-3,-2,-7,`8`,`2`,-3,-1]

结论：[8,2] 分别对应的index为[5,6]（消失的数字）

```cpp
class Solution {
public:
	vector<int> findDisappearedNumbers(vector<int>& nums) {
		//将原数组中的值置为数组下标 , 且将其取反
		for (int i = 0; i < nums.size(); ++i)
			nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);
		vector<int> res;
		for (int i = 0; i < nums.size(); ++i) {
			if (nums[i] > 0)
				res.push_back(i + 1);
		}
		return res;
	}
};
```



### 3.24 汉明距离

**题目：**两个整数之间的[汉明距离](https://baike.baidu.com/item/汉明距离)指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。

**思路：**转换成二进制，做异或运算，并且计数。==评论中给出的更加高效的方法：==将两个数做或运算，然后将得到的数 与该结果减一 做与运算，并且计数。

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        int z = x ^ y;
        int count = 0;
        while( z != 0){
            z &= z-1;
            count++;
        }
        return count;
    }
};

```



### 3.24 二叉树的直径

**题目：**给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**思路：**利用递归算法。

```cpp
class Solution {
public:
    int maxLength = 0; // 这个是类中的全局变量
    int diameterOfBinaryTree(TreeNode* root) {
        
        if (!root)
            return 0;
        dfs(root);
        return maxLength;
    }
    int  dfs(TreeNode *root){
        if(root->left == nullptr && root->right == nullptr )
            return 0;
        int leftTree = root->left == nullptr ? 0:dfs(root->left) + 1;
        int rightTree = root->right ==nullptr? 0:dfs(root->right)+ 1;
        maxLength = max(maxLength, leftTree + rightTree);
        return max(leftTree , rightTree);
    }
};
```



+++



### 3.27  罗马数字转整数

**思路：**用hash_map来映射符号和值。然后通过replace函数的使用将复杂的数都替换掉，最后读出数。

```cpp
class Solution {
public:
	int romanToInt(string s) {
        //将要求的变量用hash_map封存
		unordered_map <char, int> mp = {
			{'I',1}, {'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000},{'a',4},              {'b',9},{'c',40},{'d',90},{'e',400},{'f',900}
		};
		//要替换的字符串跟替换后的字符，转化成我们想要的格式
		string str[] = {"IV","IX","XL","XC","CD","CM"};
		string tar[] = { "a","b","c","d","e","f" };

		//替换字符
		for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
            int pos = -1;
			pos = s.find(str[i]);
			if (pos != -1)
				s = s.replace(pos, 2, tar[i]);
		}
		//将给的数转换成我们需要的格式后，计算结果	
		int res = 0;
		for (int i = 0; i < s.size(); i++) {
			res += mp[s[i]];
		}
		return res;
	}
};
```



> replace函数： `s=s.replace(s.find("tar"),num,"newTar");`
>
> string数组的大小：`sizeof(str)/sizeof(str[0]);`
>
> 普通string的大小：`s.size();`



### 3.30  移除元素

**题目：**给你一个数组 `nums` 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



```cpp
class Solution {
public:
	int removeElement(vector<int>& nums, int val) {
		if (nums.size() == 0 ||nums.empty())
			return 0;
		int j =0;
        //类似于上面某个题，都是定义一个新的变量，用来新数组的下标
		for (int i = 0; i < nums.size(); i++) {
			if (nums[i] != val){
                nums[j]=nums[i];
                 j++;
            }
				
		}
		return j;
	}
};
```











---

+++

***

------



## 中等题（17）

### 3.25 两数相加

**题目：**给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。

**要求：**你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**思路：**我的思路是将链表逐个翻转后再逐位取出相加，将得到和在按位放到新链表中。但这样的代码又臭又长。参考答案中给的方法：

直接将两个链表中的数相加，并且记录进位，进位只可能是1。这样将得到的结果在按位放置到新链表中，要简洁很多。

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = nullptr;
		ListNode *tail = nullptr;
		int carry = 0; // 记录进位
		while (l1 || l2) {
			int n = l1 ?  l1->val : 0;
			int m = l2 ?  l2->val : 0;
			int sum = m + n + carry;
			
			if (!head) {
				head = tail = new ListNode(sum % 10);
			} else {
				tail->next = new ListNode(sum % 10);
				tail = tail->next;
			}
			carry = sum / 10;

			if (l1)
				l1 = l1->next;
			if (l2)
				l2 = l2->next;

		}
		if (carry > 0)
			tail->next = new ListNode(carry);
        return head;
    }
};
```



### 3.25 无重复的最长字符串

**题目：**给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。可以查看滚动数组的总结。

**思路：**顶礼膜拜大佬的代码。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //定义两个游标,还有长度,与结果,均初始化为0
        int start(0),end(0),length(0),result(0);
        //只要end<字符串大小
        while(end<s.size())
        {
            //该注释错误		//暂存首个字符char,
            //其实应该是暂存end所指向的那个值,到时候会跟index所指向的值比较
            char tempChar=s[end];
            //定义index,它只用于改变start的指向一般为index+1
            //因为index所处的与end的值相等,则没有统计的必要了
            //for循环只用来判断是否相等
            //
            for(int index=start;index<end;index++)
            {
                //判断是否出现重复字符串
                if(tempChar==s[index])
                {
                    //start++;//这是错误的哦,没有优化呢
                    //如果出现,则将start跳过重复字符index指向的下一字符
                    start = index + 1;
                    //保存长度
                    length=end-start;
                    /////////
                    //千万注意,如果相等,则该判断应该结束了
                    break;
                }
            }
            //此时,end向后移动,每一一次,长度+1
            end++;
            length++;
            //返回更新后的length,如果更大,则为它
            result=max(result,length);
        }
        return result;
    }
};
```







### 3.25  最长回文子串

**题目：**给你一个字符串 `s`，找到 `s` 中最长的回文子串。

 **思路：**利用暴力求解法，时空间复杂度都为O（n^2^)。本质上是两个指针，一个从头开始向后遍历，一个从尾向前遍历，然后判断他们是否相等。转态转移方程如下：
$$
P(i,j)=P(i+1,j−1)∧(Si==Sj)
$$


```cpp
//这是暴力解法，不好用，也没理解透
class Solution {
public:
	string longestPalindrome(string s) {
		int n = s.size();
		vector<vector<int>> dp(n, vector<int>(n));
		string ans;
		for (int l = 0; l < n; ++l) {
			for (int i = 0; i + l < n; ++i) {
				int j = i + l;
				if (l == 0) {
					dp[i][j] = 1;
				} else if (l == 1) {
					dp[i][j] = (s[i] == s[j]);
				} else {
					dp[i][j] = (s[i] == s[j] && dp[i + 1][j - 1]);
				}
				if (dp[i][j] && l + 1 > ans.size()) {
					ans = s.substr(i, l + 1);
				}
			}
		}
		return ans;
	}
};
```





+++



### 3.26  Z字型变换

**题目：**将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

**思路：**有锤子思路，查看参考答案作者的思路吧！

本质上到达边界位置就转向，题目介绍的花里胡哨的。具体方法如下：

<img src="刷题日记.assets/Z字形方法.png" alt="排列方式" style="zoom:100%;" />



```cpp
class Solution
{
public:
    string convert(string s, int numRows)
    {
        if (numRows == 1)
        {
            return s;
        }
        int sSize = int(s.size());
        int storeSize = min(sSize, numRows);
        string result;
        vector<string> store(storeSize);
        int loc = 0;
        //初始有一次更改change值，因此初始值为false
        bool change = false;
        for (int index = 0; index < sSize; index++)
        {
            store[loc].push_back(s[index]);
            if (loc == numRows - 1 || loc == 0)
            {
                change = !change;
            }
            loc += change ? 1 : -1;
        }

        for (int index = 0; index < storeSize; index++)
        {
            result = result + store[index];
        }
        return result;
    }
};

作者：pinku-2
链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-cshi-xian-liang-chong-jie-fa-m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```cpp
//更简洁的做法，原理与上面解法类似
class Solution {
public:
	string convert(string s, int numRows) {
		if (numRows == 1)
            return s;
        //创建一个大小为numRows的string容器，注意这里不能用str数组，会报错。
        //用str容器来记录每行的内容
		vector<string> str(numRows);
        //dir 记录到达边界后的转向，表现为+1 或-1。
		int n = 0, dir = 1;
		for (int i = 0; i < s.size(); ++i) {
			if (n == numRows - 1)
                dir = -1;
			if (n == 0)
                dir = 1;
            //这里 n 就是代表了第 n 行
			str[n] += s[i];
			n += dir;
		}
		for (int i = 1; i < numRows; ++i) {
			str[0] += str[i];
		}
		return str[0];
	}
};
```



### 3.26 字符串转换正数

**题目：**请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

函数 `myAtoi(string s)` 的算法如下：

- 读入字符串并丢弃无用的前导空格
- 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
- 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
- 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
- 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
  返回整数作为最终结果。

**注意：**

- 本题中的空白字符只包括空格字符 ' ' 。

- 除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。

**思路：**题目写的花里胡哨的，其实就是读出字符串的数字。



```cpp
class Solution {
public:
	int myAtoi(string s) {
		int length = s.size();
		int idx = 0;
        //去掉空格
		while (idx < length && s[idx] == ' ') {
			idx++;
		}
		if (idx == length)
			return 0;
		bool negative = false;
		if (s[idx] == '-') {
			negative = true;
			idx++;
		} else if (s[idx] == '+') {
			idx++;
			negative = false;
            //如果未遇到正负号，且未遇到数字符号，那么返回值为0
		} else if (s[idx] != '+' && s[idx] != '-' && (s[idx] < '0' || s[idx] > '9'))
			return 0;
		int ans = 0;
		while (idx < length &&s[idx] >= '0' && s[idx] <= '9' ) {
			int digit = s[idx] - '0';
            //下面是防止越界的处理·值得记录借鉴
			if (ans > (INT_MAX- digit) / 10) {
				// 本来应该是 ans * 10 + digit > Integer.MAX_VALUE
				// 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。
				return negative ? INT_MIN : INT_MAX;
			}
			ans = ans * 10 + digit;
			idx++;
		}
		return negative? -ans:ans;
	}

};
```



### 3.26 盛最多水的容器

**题目：**给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

**思路：**有屁的思路。参考答案中写道，本题目是经典的面试题，采用双指针的办法。

```cpp
class Solution {
public:
	int maxArea(vector<int>& height) {
        //定义水桶的长、高
		int l ( 0), r ( height.size() - 1);
		int ans = 0;
        //这里不适合用 for 循环
		while (l < r) {
            //找出高度比较小的
			int area = min(height[l], height[r]) * (r - l);
			//结果取最大值
            ans = max(ans, area);
            //高度小的移动
			if (height[l] <= height[r]) {
				l++;
			} else {
				r--;
			}
		}
		return ans;
	}
};
```



++++



### 3.27 整数转罗马数字

**思路：**我想到的是枚举。评论中有大佬写的答案，将罗马符号跟对应的数字都封成数组，这样来选取罗马数字。

**贪心算法：**

```cpp
class Solution {
public:
	string intToRoman(int num) {
		int value[] = { 1000, 900,500,400,100,90,50,40,10,9,5,4,1 };
		string reps[] = { "M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I" };
		string res;
		for (int i = 0; i < 13; i++) {
			//这里必须使用while循环，因为如果使用if语句，中间数值每种可能的情况就只能运行一次就结束了。
			while (num >= value[i]) {
                //将数字按照已有的取情况分类
				num -= value[i];
                //拼接字符串
				res += reps[i];
			}
		}
		return res;
	}
};
```



### 3.27 三数之和

**题目：**给你一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

**要求：**答案中不可以包含重复的三元组。

**思路：**我想到是暴力穷举法。看参考答案中写道，使用双指针＋排序会使复杂度下降个数量级。本质上先对其进行排序，这样避免了判断是否有重复的元素相加；然后就是对于求和的运算了，如果和偏大，那么右指针左移；如果和偏小，左指针右移。



```cpp
class Solution {
public:
	vector<vector<int>> threeSum(vector<int>& nums) {
		int length = nums.size();
		vector<vector<int>> ans;
		sort(nums.begin(), nums.end());  //排序
		//i 为首指针，j为尾指针，k为中间指针
		//固定一个指针，剩下的两个分别取值求和
		for (int i = 0; i < length; i++) {
			//枚举的数要跟上一次的不同，注意是上一次，不是下一次。
			if (i > 0 && nums[i] == nums[i - 1])  
				continue;
			int j = length - 1;
			int tar = -nums[i]; //这个作用是充当第一个数固定后的条件
			//中间指针在第一个指针确定的前提下进行遍历。
			for (int k = i + 1; k < length; k++) {
				if (k > i + 1 && nums[k] == nums[k - 1])
					continue;
				//如果两者的和大了，那么尾指针左移；如果小了，那么继续循环。
				while (k < j && nums[j] + nums[k] >tar)
					j--;
				if (j == k)
					break;
				//最后统计结果
				if (nums[j] + nums[k] == tar)
					ans.push_back({ nums[i],nums[j],nums[k] });
			}			
		}
		return ans;
	}
};
```



> 不管是几个数求和，都要转换成两个数求和，依次迭代。以本体为题，三个数求和，首先要做的事固定第一个数，让后面的的两个数遍历取值，求出他俩的和与第一个数比较。当后两个数都已经遍历完成，那么继续进行第一个数的遍历，依次进行，求出结果。



### 3.27 最接近的三数之和

**题目：**给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

**思路：**本来想着用上题的办法，可是一个半小时没写出来。真是：有的人在打游戏，有的人在约会，而有的人在看着似曾相识的题目一个半小时没有做出来。。。。。

看参考答案，很简单的遍历求结果。→__→

==这个代码的逻辑性比上个题目的逻辑要清晰些~==

```cpp
class Solution {
public:
	int threeSumClosest(vector<int>& nums, int target) {
		int length =nums.size() ;
		sort(nums.begin(), nums.end());
		int ans = nums[0] + nums[1] + nums[2];
		for (int i = 0; i < length; i++) {
			int k = i + 1;
			int j = length - 1;
			while (k < j) {
				int sum = nums[i] + nums[j] + nums[k];
                //如果初始的和的绝对值小于计算后和的绝对值，那么更新ans
				if (abs(sum - target) < abs(ans - target))
					ans = sum;
				if (sum > target)
					j--;
				if (sum < target)
					k++;
				if (sum == target)
					return target;
			}
		}
		return ans;
	}
};
```



### 3.27 电话号码的字母组合

**题目：**给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

**思路：**思路个屁~这题目就压根不是我能想出来的！这题目也不是当下的我可以看懂解决的。。。

```cpp
class Solution {
public:
	unordered_map<char, string> phoneMap = {
	{'0', " "}, {'1',"*"}, {'2',"abc"},{'3',"def"},{'4',"ghi"},{'5',"jkl"},{'6',"mno"},		{'7',"pqrs"},{'8',"tuv"},{'9',"wxyz"},
	};
	vector<string> res; //存放输出字符串的容器
	string cur;  //存放所有可能的组合

	vector<string> letterCombinations(string digits) {
	
		//如果给的是空串，则返回空vector
		if (digits.empty())
			return res;
		func( digits);
		return res;
	}
	
	void func(string digits) {
		//递归结束的条件一般前置
		//但是最后写这个判断语句，先写执行语句
		if (!digits.size())
			res.push_back(cur);
		else {
			char num = digits[0];
			string letter = phoneMap[num];
			for (auto e : letter) {
                //此时遍历外层第一个数据，cur 外层只取了一个值，例如：a
                //向下遍历的时候，递归
                //内层全部，a + d , a + e, a + f; 依次进行
				cur.push_back(e);
				func(digits.substr(1)); //substr(1) 表示从下标 1 位置开始截取到末尾
				cur.pop_back(); // c++ 的string 类型字符串总是以'\0'作为串的结束符。
			}
		}
	}

};
```



> 递归算法的思路：首先是写执行语句，然后在写判断语句，并把判断语句前置。
>
> 这里的递归，跟`3. 26 Z字型变换`类似，都是用第一层当做初始值，后面遍历完，进行第二层……

+++



### 3.28 四数之和

**题目：**给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

**要求：**答案中不可以包含重复的四元组。

**思路：**参考三数之和来写。

```cpp
//用while循环写的函数，其中要注意的点都加了注释。
class Solution {
public:
	vector<vector<int>> fourSum(vector<int>& nums, int target) {
		int  length = nums.size();
		vector<vector<int>> ans;
		sort(nums.begin(), nums.end());
        //如果长度小于4 ，那么就直接返回 空容器。
		if (length < 4) 
            return ans;
        
		for (int i = 0; i < length - 3; i++) {
            //同三数之和一样，如果下个值跟本次相同，那么跳过，减少无谓的运算。
			if (i > 0 && nums[i] == nums[i - 1]) {				
				continue;
			}
            
			int j = i + 1;		
			while (j < length - 2) {				
				if (j > i + 1 && nums[j] == nums[j - 1]) {
					j++;
					continue;
				}
                //这里是需要两个移动的指针，前指针小于后指针即可。
                //last 定义到上面循环外面，会导致last的值在下面循环不能重新赋值；
                //会少解。
				int k = j + 1;
				int last = length - 1;
				while (k < last ) {
					if (k > j + 1 && nums[k] == nums[k - 1]) {
						k++;
						continue;
					}						
					int sum = nums[i] + nums[j] + nums[k] + nums[last];
					if (sum > target)
						last--;
					if (sum < target)
						k++;
                    //如果得出了想要的值，不能写 return ；
                    //因为本题是可以出现多个解，且给的数据是允许重复的。
                    //也不能写 break；
                    //那样一旦有合适的结果就退出了，导致少解。
					if (sum == target) {
						ans.push_back({ nums[i],nums[j],nums[k],nums[last] });
						k++;
					}
				}

				j++;
			}
		}		
		return ans;
	}
};
```



```cpp
//for 循环实现
class Solution {
public:
	vector<vector<int>> fourSum(vector<int>& nums, int target) {
		int length = nums.size();
		vector<vector<int>> ans;
		if (length < 4)
			return ans;
		sort(nums.begin(), nums.end());
		for (int i = 0; i < length - 3; i++) {
			if (i > 0 && nums[i] == nums[i - 1])
				continue;
			for (int j = i + 1; j < length - 2; j++) {
				if (j > i + 1 && nums[j] == nums[j - 1])
					continue;
				int last = length - 1;
				for (int k = j + 1; k < last; k++) {
					if (k > j + 1 && nums[k] == nums[k - 1])
						continue;
				
					int sum = nums[i] + nums[j] + nums[k] + nums[last];
					while ( sum > target) {
						last--;
                        //这里需要注意的一点：
                        //last --运算，会导致last == k 的情况出现；
                        //这样就有值取了两次。
						if (k == last)
							break;
						sum = nums[i] + nums[j] + nums[k] + nums[last];
					}
											
					if (sum == target) {
						ans.push_back({ nums[i],nums[j],nums[k],nums[last] });
					}
					
				}
			}
		}		
		return ans;
	}
};
```



> 这两个方法写完比较来看，`for`循环结构更加清晰些，代码实现起来逻辑简单；`while`循环可读性会高点，但是写起来的坑比较多，经常会忘运算符的自增运算，且代码实现的逻辑没那么清晰。



### 3.28 删除链表的倒数第n个节点

**题目：**给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```cpp
//计算链表长度。
class Solution {
public:
	ListNode* removeNthFromEnd(ListNode* head, int n) {
		ListNode* dummy = new ListNode(0, head);
		ListNode* curr = dummy;
		int count = 0;
		while (head){
            count++;
            head = head->next;
        }			
         //这里是倒数的 n  ，不是正数的个数
		for (int i = 1; i < count-n + 1; i++) {
			curr= curr->next;
		}
		curr->next = curr->next->next;
		ListNode *ans = dummy ->next;
		delete dummy;
		return ans;
	}
};

```



```cpp
//双指针· 这个方法要好的多，效率高得多
class Solution {
public:
	ListNode* removeNthFromEnd(ListNode* head, int n) {
		ListNode *dummy = new ListNode(0, head);
		ListNode *fast = head;
		ListNode *slow = dummy;

		//倒数第 n 个，也就是从该位置到末尾的距离为 n
		for (int i = 0; i < n; i++) {
			fast = fast->next;
		}
		while (fast !=nullptr) {
			fast = fast->next;
			slow = slow->next;
		}
		slow->next = slow->next->next;
		ListNode *ans = dummy->next;
		delete dummy;
		return ans;

	}
};
```



+++



### 3.29 括号生成

**题目：**数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

```cpp
//有关于迭代·算法的实现
class Solution {
public:
	vector<string> ans;

	vector<string> generateParenthesis(int n) {
		dfs(n, n, "");
		return ans;
	}
	void dfs(int left, int right, string curr) {
		//递归结束的条件
		//如果左括号或者右括号为 0 的话，那么就把当前的字符加入到结果中
		if (left == 0 && right == 0) {
			ans.push_back(curr);
			return;
		}
		//先写左括号，左括号完毕后在写右括号
		//左括号依次减一，然后用字符串拼接起来即可
		if (left > 0)
			dfs(left - 1, right, curr + "(");
		//进行迭代的时候，右括号是找左括号进行匹配
		if (right > left)
			dfs(left, right - 1, curr + ")");
	}
};
```





### 3.29 两两交换列表中的节点

**题目：**给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```cpp
//递归·算法
class Solution {
public:
	ListNode* swapPairs(ListNode* head) {
		if (head == nullptr || head->next == nullptr)
			return head;
		//原链表的第二个节点记为newHead
		ListNode *newhead = head->next;
		//Head 的指向为 newHead 的指向；
		head->next = swapPairs(newhead->next);
		//新链表的 newHead 的指向为Head；
		//这样完成了两两交换。
		newhead->next = head;
		return newhead;
	}
};
```



```cpp
//迭代·算法 ，该算法效率比较高效
class Solution {
public:
	ListNode* swapPairs(ListNode* head) {
		ListNode *dummy = new ListNode(0, head);
		ListNode *curr = dummy; //新建一个哑结点

		while (curr->next !=nullptr && curr->next ->next !=nullptr) {
			ListNode *node1 = curr->next;
			ListNode *node2 = curr->next->next;
			//哑节点的指向变成 原链表的第二个节点；
			//新链表的第二个节点的指向 原链表的第一个节点；
			//交换完毕。
			curr->next = node2;
			node1->next = node2->next;
			node2->next = node1;
			//节点移动到下一对 数据
			curr = node1;
		}
        return dummy->next;
	}
};

```





+++



### 3.30 下一个排列

**题目：**实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

**题意：**（盗来的）

题干的意思是：找出这个数组排序出的所有数中，刚好比当前数大的那个数；

比如当前 nums = [1,2,3]。这个数是123，找出1，2，3这3个数字排序可能的所有数，排序后，比123大的那个数 也就是132；

如果当前 nums = [3,2,1]。这就是1，2，3所有排序中最大的那个数，那么就返回1，2，3排序后所有数中最小的那个，也就是1，2，3 -> [1,2,3]。

```cpp
//此题是利用逆向查找，因为要找到比当前数列大的最小值
//首先找到一个升序的位置
//然后将升序的那个元素与大于他的最小元素交换位置
//最后将升序位置开始，依次升序排列
class Solution {
public:
	void nextPermutation(vector<int>& nums) {
		//倒序查找
		int i = nums.size() - 2;
		//找到升序的位置
		while (i >= 0 && nums[i] >= nums[i + 1])
			i--;
		if (i >= 0) {
			//继续倒序查找
			int j = nums.size() - 1;
			while (j >= 0 && nums[i] >= nums[j])
				j--;
			swap(nums[i], nums[j]);
		}
		reverse(nums.begin() + i + 1, nums.end());
	}
};
```





### 3.30 搜索旋转排序数组

**题目：**整数数组 nums 按升序排列，数组中的值 互不相同 。数组本身不是有序的，进行旋转后只保证了数组的局部是有序的；

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。

```cpp
//二分法·求范围
//二分法本质也是通过确定头、尾不动
//然后通过mid值不断移动来计算结果
class Solution {
public:
	int search(vector<int>& nums, int target) {
		int length = nums.size();
		if (!length)
			return -1;
		if (length == 1) 
			return nums[0] == target ? 0 : -1;
		//定义两个下标，分别指向头尾
		//在利用中间值的大小，细分区间位置
		int prev(0), end(length - 1);
		while (prev <= end) {
			int mid = (prev + end) / 2;
			if (nums[mid] == target)
				return mid;
			//判断前半段是否有序
            //这里是判断的原数组中 第一个元素跟 中间元素的大小
            //如果是有序数组，这步是不需要的
			if (nums[0] <= nums[mid]) {
				//虽然有两个 left、right 下标值，但其实并不真正参与区间变换
                //而是通过这两个值，找出 mid；通过mid最后判断结果
                //利用有序段，判断 target 靠近左边还是右边
				if (nums[0] <= target && target < nums[mid])
					end = mid - 1;
				else
					prev = mid + 1;
			}
			//如果前半段无序，那么后半段有序
            //else 也可以改成下面这条语句
            // if(nums[0] > nums[mid] && nums[mid] <= nums[length -1])
			else {
                //利用有序段，判断 target 靠近左边还是右边
				if (nums[mid] < target  && target <= nums[length - 1])
					prev = mid + 1;
				else
					end = mid - 1;
			}	
			
		}
        return -1;
	}
};
```



### 3.30 在排序数组中查找元素的第一个和最后一个位置

**题目：**给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

```cpp
//二分法·找左边界跟有边界
//核心就是利用 左标跟右标 来 求 mid ，根据 mid 来找值
//经过多次尝试，发现原题解的方法还是最简洁的
class Solution {
public:
	vector<int> searchRange(vector<int>& nums, int target) {
		//将ans 容器初始化为 2 个 -1 的值
		vector<int> ans(2, -1);
		int length = nums.size();
		if (!length)
			return ans;
		int left = 0;
		int right = length - 1;
		//找左边界，即找第一次出现的值
		while (left < right) {
			int mid = (left + right) >> 1;
			if (target <= nums[mid])
				right = mid;
			else
				left = mid + 1;
		}
		/*没找到 target*/
		if (nums[left] != target)
			return ans;

		ans[0] = left;
		//当target只出现一次的时候，需要两次读到这个值
		//right = length 就是为了确保从右侧逼近的时候取到这个值
		//如果 right = length -1， 那么 mid = left + right >> 1
		//实际上的 mid = left + 1 了，
		//而需要的是 mid = left 开始
		right = length;
		while (left < right) {
			int mid = left + right >> 1;
			if (nums[mid] <= target)
				left = mid + 1;
			else
				right = mid;
		}
		ans[1] = left - 1;
		return ans;
	}
};
```



- 31号暂停一天，复习以前的题目，做下老师的任务

+++

---

***



## --------从现在开始不再区分复杂度了------

## 4.1  搜索插入位置

**题目：**给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

```cpp
//普通做法
class Solution {
public:
	int searchInsert(vector<int>& nums, int target) {
		if (nums.empty())
			return -1;

		int index = 0;
        //遍历所有值
        //当前值小于后面的值的时候，继续遍历
        //当前值大于或者等于后面值得时候，返回该值即可
		while (index < nums.size()) {
			if (nums[index] < target)
				index++;
			else if (nums[index] >= target)
				return index;
			
		}
		return nums.size();
	}
};
```



```cpp
//二分法·算法
class Solution {
public:
	int searchInsert(vector<int>& nums, int target) {
		if (nums.empty())
			return -1;
		int length = nums.size();
		int left = 0;
		int right = length - 1;
		//一般的二分查找算法，都要 left <= right
        //只剩下两个数的时候，如果不取等号，那么无法实现 mid 取到所有值
		while (left <= right) {
			int mid = left + right >> 1;
            //原理不变
			if (nums[mid] >= target) {
				length = mid;
				right = mid - 1;
		}
			if (nums[mid] < target)
				left = mid + 1;
		}
		return length;
	}
};
```



> 二分法·算法
>
> - `while(left <=  right)`如果取了`“=”`，那么后面`right = mid-1`；如果没取，那么后面是`right = mid`
> - 本质上都是用mid来遍历所有值，所以要看情况用哪种方式最好

## 4.1 有效的数独

**题目：**判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

- 数字 1-9 在每一行只能出现一次。
- 数字 1-9 在每一列只能出现一次。
- 数字 1-9 在每一个以粗实线分隔的 3 x 3 宫内只能出现一次。

**思路：**具体查看该[大佬](https://leetcode-cn.com/problems/valid-sudoku/solution/36-jiu-an-zhao-cong-zuo-wang-you-cong-shang-wang-x/)的思路。

```cpp
class Solution {
public:
	bool isValidSudoku(vector<vector<char>>& board) {
		//左边是标号，右边是数字
        //记录每行、每列、每个block 数字出现的次数
		bool row[9][9] = { 0 };
		bool columns[9][9] = { 0 };
		bool block[9][9] = { 0 };

		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				if (board[i][j] == '.')
					continue;
				//当前数字是多少
                 //将字符型转换为整数型进行比较 
                 //我们想获得字符型 ——> 数字的转变，只需要将该字符减去 ‘0’ 或者 ‘1’
				int currNum = board[i][j] - '1';
				if (row[i][currNum])
					return false;
				if (columns[j][currNum])
					return false;
				if (block[j / 3 + i / 3 * 3][currNum])
					return false;
				//之前未出现过，则置为 1
				row[i][currNum] = 1;
				columns[j][currNum] = 1;
				block[j / 3 + i / 3 * 3][currNum] = 1;
			}
		}
		return true;
	}
};
```



> 由字符型转换成数字：只需要将 0 - 9 的 字符 直接减去 ‘0’ 或者 ‘1’。
>
> ‘9’ = 57， ‘0’=48；‘a' = 97 , 'A' =65。 



## 4.1 解数独

**题目：**编写一个程序，通过填充空格来解决数独问题。

**思路：**查看[大佬](https://leetcode-cn.com/problems/sudoku-solver/solution/hui-su-fa-jie-shu-du-by-i_use_python/307397)的思路，很棒。

```cpp
class Solution {
public:
	void solveSudoku(vector<vector<char>> &board) {
		backtrack(board, 0, 0);
	}
	//row,columns∈[0,8]
	bool backtrack(vector<vector<char>> &board, int row, int columns) {
        //列数 越界，则换行
		if (columns == 9)
			return backtrack(board, row + 1, 0);
         //行数 越界，则完成目标
		if (row == 9)
			return true;
         //遍历所有位置
		for (int i = row; i < 9; i++) {
			for (int j = columns; j < 9; j++) {
				//没有要填的空位，则看向下一列
				if (board[i][j] != '.')
					return backtrack(board, i, j + 1);
				for (char ch = '1'; ch <= '9'; ch++) {
					if (!isValid(board, i, j , ch)) 
						continue;
					//尝试填入未使用的数字，看向下一列
					board[i][j] = ch;
					if (backtrack(board, i, j + 1))
						return true;
					board[i][j] = '.';
				}
				return false;
			}
			
		}
		return false;
	}

	bool isValid(vector<vector<char>> &board, int row, int columns, char ch) {
		//这里的 i  代表了 字符数字
		for (int i = 0; i < 9; i++) {
			if (board[row][i] == ch)
				return false;
			if (board[i][columns] == ch)
				return false;
			//数学公式判断 block 中的哪个部分
			if (board[row / 3 * 3 + i / 3][columns/ 3 * 3 + i % 3] == ch)
				return false;
		}
		return true;
	}
};
```



## 4.1 外观数列

**题目：**给定一个正整数 n ，输出外观数列的第 n 项。外观数列 是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

**思路：**[大佬](https://blog.csdn.net/zhanshen112/article/details/84780458)的代码没有注释，只能自己悟。不过这么优美的代码，值得细品（我啥时候才能写得出）。

```cpp
class Solution {
public:
	string countAndSay(int n) {
			string s = "1";
			int j = 0;
			for (int cnt = 1; cnt < n; cnt++) {
				string t;
				for (int i = 0; i < s.length(); i = j) {
                      //求出 相邻的数不同时候的下标
					for (j = i; j < s.length() && s[j] == s[i]; j++);
					t +=  to_string(j - i) + s[i];
				}
				s = t;
			}
		
			return s;
	}
};


/*------------------根据自己理解写了个方便阅读的循环----------------------*/
			//该代码跟上面的原理相同
			for (int idx = 1; idx < n; idx++) {
				string t;
				for(int i = 0;  i < s.length(); ) {
					for (j = i; j < s.length(); j++) {
						if (s[j] != s[i]) 						
							break;
					}
					t += to_string(j - i) + s[i];
					i = j;
				}
				s = t;
			}
```



> 根据这几次用循环来看，for循环要比while循环好用点，以后首先考虑for循环，其次while循环。
>
> while循环的时候，要考虑赋初值的事情，每次循环开始的值要不要重新置0。

+++



## 4.2 组合总和

**题目：**给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。

**思路：**回溯法。

```cpp
class Solution {
public:
	vector<vector<int>> ans;
	vector<int> combine;

	vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
		
		dfs(candidates, target, 0);
		return ans;
	}

	void dfs(vector<int> &candidates, int target, int idx) {
		if (idx == candidates.size())
			return;
		if (target == 0) {
			ans.emplace_back(combine);
			return;
		}
		dfs(candidates, target, idx + 1);
		if (target - candidates[idx] >= 0) {
			combine.emplace_back(candidates[idx]);
			dfs(candidates, target - candidates[idx], idx);
			combine.pop_back();
		}
	}
};

```





## 4.2 组合总和II

**题目：**只能使用一次数字，但是给的数组中有重复元素。

```cpp

```



> 回溯法：



## 4.2 缺失的第一个正数

**题目：**给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

**要求：**你可以实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案吗？

**思路：**排序，然后找到第一个正数。该正数是最小的，则往后遍历。

- 利用哈希表的算法思想，跟之前的有个题目类似，将本数组的中元素当做新数组的下标。
- 跟 **3.24 只出现一次的数字**找到数组中消失的数字类似。

```cpp
class Solution {
public:
	int firstMissingPositive(vector<int>& nums) {
        
		int n = nums.size();
		//遍历数组，让所有非正数 全部 置为 n+1 ,不参与下面的循环
		for (auto &e : nums) {
			if (e <= 0)
				e = n + 1;			
		}
		//遍历找[0,N] 
		//这里的算法是，将原数组[0,N] + 1 当成下标值
		//如果该值出现，那么就将新数组的下标等于该值记为 负数
		//这样新数组中数据为正 的下标 + 1 即为未出现的数据
		for (int i = 0; i < n; i++) {
			//这条语句是为了 确保 有重复下标值出现的时候，能够有效标记
			int e = abs(nums[i]);
			if (e <= n)
				nums[e - 1] = -abs(nums[e - 1]);
		}
		for (int i = 0; i < n; i++) {
			if (nums[i] > 0)
				return i + 1;
		}
		//如果[1,N+1] 都出现过，则返回 N+1
		return n + 1;
	}
};
```





## 4.2 寻找两个正序数组中的中位数

**题目：**给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

```cpp
//暴力法·肯定下下下选
class Solution {
public:
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int length1 = nums1.size();
		int length2 = nums2.size();
		//将 nums1 ，num2 合并
		vector<int> ans;
		ans = nums1;
		for (int i = 0; i < length2; i++)
			ans.push_back(nums2[i]);
        //排序
		sort(ans.begin(), ans.end());
		int length = length1 + length2 ;
		int mid = length1 + length2 >> 1;
        //如果空数组
		if (mid == 0)
			return ans[mid];
		//总长度为奇数，则中间值；若为偶数，则中间值的一半
        if (length % 2 == 1)
			return ans[mid];
		else
			return (ans[mid] + ans[mid - 1])/ 2.0;
	}
};
```

这个算法具体查看[详解](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)。

```cpp
//算法·二分查找· 两次二分
class Solution {
public:
	//此函数只是求合并后 数组 的中间下标
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int length = nums1.size() + nums2.size();
		//总长为奇数，则返回中间值；总长为偶数，则返回中间两数的平均值
		if (length % 2 == 1)
			return midValue(nums1, nums2, (length + 1 ) / 2 ); // 第 n 个数
		else
			return (midValue(nums1, nums2, length / 2 ) 
                    + midValue(nums1, nums2, length / 2 + 1) )/ 2.0;
	}
	
	//此函数求该下标的具体的值，且要在两个数组中找到上面函数中所谓的下标值在哪
    //mid 为下标值
    //index 为舍弃掉不符合元素后的数组下标，newIndex 为中间数组下标
	int midValue(vector<int>& nums1, vector<int>& nums2 , int mid) {
		int m = nums1.size();
		int n = nums2.size();
		int index1(0), index2(0);
		
		while (true) {
			if (m == index1)
				return nums2[index2 + mid - 1];
			if (n == index2)
				return nums1[index1 + mid - 1];
			if (mid == 1)
				return min(nums1[index1], nums2[index2]);
			//防止数组下标越界，例如，num1 的长度为 1 ，mid = 3 ，就越界了
             //newIndex = 现在当前的下标(index) + mid / 2 
			int  newIndex1 = min(mid / 2 + index1 - 1, m - 1);
			int  newIndex2 = min(mid / 2 + index2 - 1, n - 1);
			
			if (nums1[newIndex1] <= nums2[newIndex2]) {
				mid -= newIndex1 - index1 + 1;
				index1 = newIndex1 + 1;
			} else {
				mid -= newIndex2 - index2 + 1;
				index2 = newIndex2 + 1;
			}
		}
	}
};
```



+++



## 4.3 接雨水

**题目：**给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```cpp
//dp算法·动态规划
class Solution {
public:
	int trap(vector<int>& height) {
		int n = height.size();
		if (n == 0)
			return 0;
		vector<int> left(n), right(n);
		left[0] = height[0];
		right[n - 1] = height[n - 1];
		//前一次的值赋给 left ，为坐标值
		for (int i = 1; i < n; i++) {
			left[i] = max(left[i - 1], height[i]);
		}
		for (int i = n - 2; i >= 0; i--) {
			right[i] = max(right[i + 1], height[i]);
		}
		int ans = 0;
		//height 为当前坐标下的 值
		for (int i = 0; i < n; i++) {
			int level = min(left[i], right[i]);
			ans += max(0, level - height[i]);
		}
		return ans;
	}
};
```





## 4.3 字符串相乘

**题目：**给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**思路：**逐位做乘法，结果保存起来；然后各位的数字为 result % 10，进位为 result / 10 。

```cpp
class Solution {
public:
	string multiply(string num1, string num2) {
		if (num1 == "0" || num2 == "0")
			return "0";
		int m = num1.length();
		int n = num2.length();
		//存放各位乘积的结果
		vector<int> ansArr(m + n );
		for (int i = m - 1; i >= 0; i--) {
			int x = num1[i] - '0';
			for (int j = n - 1; j >= 0; j--) {
				int y = num2[j] - '0';
				ansArr[i + j + 1] += x * y;
		
			}
		}

		for (int i = m + n - 1; i > 0; i--) {
			ansArr[i - 1] += ansArr[i] / 10; //进位
			ansArr[i ] %= 10;
		}
		/*--将数组的中的数 转化成字符串风格--*/
		//ansArr 中的容量是最大值，所以要判断下最高位是否有值。
		int index = ansArr[0] == 0 ? 1 : 0;
		string ans;
		while (index < m + n) {
			ans.push_back(ansArr[index]);
			index++;

		}
		for (auto &e : ans)
			e += '0';
		return ans;
	}
```



## 4.3 通配符匹配

**题目：**给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

- '?' 可以匹配任何单个字符。
- '*' 可以匹配任意字符串（包括空字符串）。

**思路：**看[大佬](https://leetcode-cn.com/problems/wildcard-matching/solution/yi-ge-qi-pan-kan-dong-dong-tai-gui-hua-dpsi-lu-by-/)的图解吧。太难了，我写不出来，也没能理解通透dp算法。

```cpp
class Solution {
public:
	bool isMatch(string s, string p) {
		int zong = p.length() + 1;
		int heng = s.length() + 1;
		//dp 二维数组全部初始化为 0
		vector<vector<bool>> dp(zong + 1, vector<bool>(heng + 1, 0));

		//从第一个位置出发，标为 true，即 1 
		dp[0][0] = 1;

		for (int i = 1; i <= zong; i++) {
			//标志位 path ，是否能走下一步
			int path = 0;
			for (int j = 1; j <= heng; j++) {
				//如果下个匹配符号为 ‘*’，且 左上角要为 1 的格子标为 下一步 ，即1
				if (p[i - 1] == '*' && dp[i - 1][j - 1]) {
					path = 1;
					//将此行后面的值都标为 1 ，即都是有可能的下一步
					dp[i][j - 1] = 1;
				}
				if (p[i - 1] == '?' || p[i - 1] == s[j - 1]) {
					dp[i ][j ] = dp[i-1][j-1];
				}
				if (path)
					dp[i][j] = 1;
			}
		}
		return  dp[zong][heng];
	}
};
```



## 4.3 正则表达式匹配

**题目：**给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖**整个**字符串 `s`的，而不是部分字符串。

**思路：** dp 算法

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size()
        //匿名函数
        auto matches = [&](int i, int j) {
            if (i == 0) {
                return false;
            }
            if (p[j - 1] == '.') {
                return true;
            }
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> f(m + 1, vector<int>(n + 1));
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    f[i][j] |= f[i][j - 2];
                    if (matches(i, j - 1)) {
                        f[i][j] |= f[i - 1][j];
                    }
                }
                else {
                    if (matches(i, j)) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }
};


```



+++



## 4.4 递归算法

**递归·分治·算法**：直接或者间接**不断反复调用自身**来达到解决问题的方法。这就要求原始问题可以分解成相同问题的子问题。

**解题思路：**

1. 将原问题分解为n个规模较小的子问题，各子问题间独立存在，并且与原问题形式相同

2. 递归的解决各个子问题

3. 将各个子问题的解合并得到原问题的解



**算法步骤：**

1. 明确函数要做什么，完成什么样的功能（包括但不限于给函数起名，变量起名）
2. 明确递归结束的条件（这个是重中之重，只有确定了什么时候结束，下面写的代码才知道正确与否）
3. 找到函数等价关系式，即“递”下去与“归”上来的关系



**适应题型：**



**例题：**

```cpp
/*-------------斐波那契数列---------------------*/
class Solution {
public:
	int Fibonacci(int n) {
         //退出条件
		if (n <= 2)
			return 1;
		 
		return Fibonacci(n - 1) + Fibonacci(n - 2);
	}
	
};
//也称兔子数列，单这种算法时间复杂度好像很高

//利用迭代算法试下
class Solution {
public:
	int Fibonacci(int n) {
		int prev = 1;
		int curr = 1;
		if (n <= 2)
			return 1;
		for (int i = 2; i < n; i++) {
			int temp = curr + prev;
			prev = curr;
			curr = temp;
			
		}
		return curr;
	}
	
};
```



```cpp
/*--------------小青蛙跳台阶-------------------*/
//掐头了的斐波那契数列，1,2,3,5，...


```



```cpp
/*---------------反转单链表--------------------*/
//该题目写过，查看以前的笔记
```



> 迭代法：迭代法也称“辗转法”，是一种==不断用旧变量的值递推出新值==的解决问题的方法。迭代算法一般用于数值计算。例如  累加、 累乘都是迭代运算。





## 4.4 dp 算法

**动态规划算法**：动态规划，无非就是利用**历史记录**，来避免我们的重复计算。而这些**历史记录**，我们得需要一些**变量**来保存，一般是用**一维数组**或者**二维数组**来保存。

计算机解决问题其实没有任何技巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。

列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。

备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？

**解题思路：**

1. 需要求最大、最小值
2. 该求解的值与前所有转态或多或少的有关



**算法步骤：**

1. 定义数组元素的含义（明确dp表格的横纵坐标代表了什么，存放的是什么历史记录）
2. 找出数组元素之间的关系式（找到转态转移方程）
3. 找出初始值（找到dp表格开始的地方，由此出发）

> dp算法主要分两类：一类是求最优解，典型的==背包问题==；另一类是技术类，==最优子结构==

**例题：**

```cpp
/*-----------给你六种面额1、5、10、20、50、100元的纸币，假设每种币值的数量都足够多，编写程序求组成N员（N为0-10000的非负整数）的不同组合的个数----------------*/
//定义dp[i] = 前 i 种的所有组合
// 状态转移公式： dp[i] = dp[i] + dp[ i - money[i]]
//例如，求521 的组合，当100面额的张数为 0 时，也就是求其他面额的所有可能
class Solution {
public:
	int moneyCombination(int target){
		int money[] = { 1,5,10,20,50,100 };
		//dp[j] 当前面额的所有可能
		vector<int> dp(target + 1);
		//赋初值，这里主要用与 做减法后，说明 有该面额的纸币，所以令为 1
		dp[0] = 1;
		for (int i = 0; i < 6; i++) {
			for (int j = money[i]; j <= target; j++)
				//dp[j] 上一次面额的所有可能性
				//[j - money[i]] 为当前 面额减去所给面额后剩余的 能匹配的面额纸币
                 //比如  dp[8] = （面额为1 时候的所有可能性） 1 +  1
				dp[j] = dp[j] + dp[j - money[i]];
		}
		return dp[target];
	}
	
};
```



```cpp
//完全背包问题·有序数组做法
//二维数组来做
class Solution {
public:
	int moneyCombination(int target) {
		int money[] = { 1, 5, 10, 20, 50, 100 };
		int len = sizeof(money) / sizeof(int);
		vector<vector<int>> dp(len + 1, vector<int>(target + 1));
        //组成的数值为 0 的可能性就 1 种
		for (int i = 0; i <= len; i++)
			dp[i][0] = 1;
        //没有 0 面额 的纸币
		for (int j = 1; j <= target; j++) 
			dp[0][j] = 0;
	
		for (int i = 1; i <= len; i++) {
			for (int j = 1; j <= target; j++) {
				dp[i][j] = 0;
				for (int k = 0; k <= j / money[i - 1]; k++) {
					dp[i][j] += dp[i - 1][j - k * money[i - 1]];
				}
			}
		}
		return dp[len][target];
	}

};
```





```cpp
/*--------------给你 k 种面值的硬币，面值分别为 c1, c2 … ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 --------------*/

class Solution {
public:
	int coinChange(int target) {
		int money[] = { 1, 2, 5 };
		vector<int> dp(target + 1, INT_MAX);
		dp[0] = 0;

		for (int i = 0; i < 3; i++) {
			for(int j = money[i]; j <=target; j++)
				dp[j] = min(dp[j], dp[j - money[i]] + 1);
		}
		return dp[target] == INT_MAX ? -1 : dp[target];
	}

};

```





## 4.4 贪心算法







## 4.4 回溯算法





## 4.4 分支限界法





## 4.5 不用路径

**题目：**一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**思路1：**用dp算法来做。

**思路2：**将dp算法优化，使用组合数学来做。

```cpp
class Solution {
public:
	int uniquePaths(int m, int n) {
		if (m <= 0 || n <= 0)
			return 0;
        //使用dp[i][j] 存放m，n的可能性
		vector<vector<int>> dp(m, vector<int>(n, 0));
        //若只有一行或者一列，那么可能性都为 1 
		for (int i = 0; i < m; i++)
			dp[i][0] = 1;
		for (int i = 0; i < n; i++)
			dp[0][i] = 1;
        //状态转移式： dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
			}
		}
		return dp[m - 1][n - 1];
	}
};
```



组合公式如下：
$$
\frac{(m+n-2)(m+n-3)\cdots n}{(m-1)!}
$$


```cpp
//组合数学
class Solution{
public:
    int uniquePaths(int m, int n){
        long long ans = 1;
        for(int x = n , y = 1 ; y < m ; x++, y++)
            ans *= x/y;
        return ans;
    }
};

```





## 4.5 最小路径和

**题目：**给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。

**思路：**dp 算法。

```cpp
class Solution {
public:
	int minPathSum(vector<vector<int>>& grid) {
		int m = grid.size();
		int n = grid[0].size();
		if (m <= 0 || n <= 0)
			return 0;
		vector<vector<int>> dp(m, vector<int>(n));
		//赋初值
		dp[0][0] = grid[0][0];
		/*第一行、列赋值，该行、列的值为，上一个数值 +  当前数值 */
		for (int i = 1; i < m; i++)
			dp[i][0] = dp[i - 1][0] + grid[i][0];
		for (int j = 1; j < n; j++)
			dp[0][j] = dp[0][j - 1] + grid[0][j];
		//状态转换式 ： 当前的数 + 上次值（包括行、列）的最小值
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				dp[i][j] = min(dp[i - 1][j] , dp[i][j - 1]) + grid[i][j];
			}
		}
		return dp[m - 1][n - 1];
	}
};

```



## 4.5 编辑距离

**题目：**给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**思路：**动态规划。

```cpp
class Solution {
public:
	int minDistance(string word1, string word2) {
		int m = word1.length();
		int n = word2.length();
		//dp[i][j] 表示 word1 转换成 word2 所需要的最少次数
		vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        //赋初值
		for (int j = 1; j <= n; j++)
			dp[0][j] = dp[0][j - 1] + 1;
		for (int i = 1; i <= m; i++)
			dp[i][0] = dp[i - 1][0] + 1;
		
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
                 //两个word 相同
				if (word1[i - 1] == word2[j - 1])
					dp[i][j] = dp[i - 1][j - 1];
				else					
			dp[i][j] =  min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
			//min 只接受两个参数
            }
		}
		return dp[m ][n];
	}
};

```



## 4.6 不同路径II

**题目：**一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

```cpp
//dp算法·我目前理解的算法
class Solution {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		int m = obstacleGrid.size();
		int n = obstacleGrid[0].size();
		//正常表格中的 dp[i][j]:表示从(0,0)->(i,j) 处所有的可能性
		vector<vector<int>> dp(m, vector<int>(n));
		for (int i = 0; i < m; i++) {
			//如果碰到 barrier ，就退出，下面无法走到
			//否则，该行置 1 
			if (obstacleGrid[i][0] == 1)
				break;
			dp[i][0] = 1;
		}
		for (int j = 0; j < n; j++) {
			//列中碰到 barrier ，退出，下面的列无法走到
			//否则，该列置 1  ，初始化
			if (obstacleGrid[0][j] == 1)
				break;
			dp[0][j] = 1;
		}

		//没有障碍物的情况下
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j]
                    + dp[i][j - 1];
			}
		}
		return dp[m - 1][n - 1];
	}
};
```





```cpp
//优化版本·利用滚动数组思想·最优子结构
//临时没看懂，好像与凑钱类似
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int n = obstacleGrid.size(), m = obstacleGrid.at(0).size();
        vector <int> f(m);

        f[0] = (obstacleGrid[0][0] == 0);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    f[j] = 0;
                    continue;
                }
                if (j - 1 >= 0 && obstacleGrid[i][j - 1] == 0) {
                    f[j] += f[j - 1];
                }
            }
        }

        return f.back();
    }
};

```







## 背包问题详解

### 4.6 基本背包

**题目：**有N件物品和一个容量是V的背包。第i件物品的体积是ci，价值是vi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且价值最大。

**解题步骤：**

1. 定义数组含义： `dp[i][v]`表示前 i 个物品在体积为 v 的情况下价值最大的可能
2. 找到状态转移方程：主要就是第 i 个物品 拿不拿的问题，在这两种情况中取最大值
   - 如果不拿第 i 个物品，则 f(i , j) = f(i -1 , j)
   - 如果拿第 i 个物品， 则 f(i , j) = f(i -1 , j - w~i~)
3. 赋初值：f(0, 0) = 0 ，一个物品都不考虑则价值为 0

==目前来看，背包问题最少也得两层循环==

```cpp
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		//正常的dp定义 ： dp[i][c] 代表了前 i 个物品组合的最大容量
		vector<vector<int>> dp(m + 1, vector<int>(capacity + 1, 0));
		//正常遍历操作
		for (int i = 1; i <= m; i++) {
			for (int c = 1; c <= capacity; c++) {
				//这里 w[i -1 ] 的原因是 w[m] 的最大下标为 m - 1 
				//而为了维护dp备忘录，只能是从 1 开始（这里 是因为定义，只能从1 开始）
				//所以实际中取得物品的下标为当前值 减一
				//状态转移中的 i - 1 是跟前一状态有关联
				if (c < w[i - 1])
					dp[i][c] = dp[i - 1][c];
				else
					dp[i][c] = max(dp[i - 1][c], 
                                   dp[i - 1][c - w[i - 1]] + v[i - 1]);
			}
		}
		return dp[m][capacity];
	}

};
```



```cpp
//优化·二位数组变一维数组  
//解释如下：dp[j] :代表 所有能组成 j 的可能
//因为一开始接触的是金币题目，所以以它来举例（纸币自带顺序，所以不能按通用方法处理）
//有 1 元、5 元 、10 元、 20 元等的纸币，
//第一层循环，记录用 1 元组成的所有可能，记录到j
//第二层循环，记录用 5 元 跟 1元 组成的所有可能，记录到 j 
//如此往复，形成 memo
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		vector<int> dp(capacity + 1);
         //组成的结果为 0 时， 可能性为 0
		dp[0] = 0;
		for (int i = 0; i < m; i++) {
			for (int j = capacity; j >= w[i]; j--) {
                  // i = 0 时， 记录 w[0] 所能组成的最大可能
                  // i = 1 时， 记录 w[1] 与 w[0] 所组成的最大可能
				dp[j] = max(dp[j] ,dp[j - w[i]] + v[i]);
			}
		}
		return dp[capacity];
	}

};
```



### 4.6 完全背包

**题目：**有N件物品和一个容量是V的背包。第i件物品的容量是ci，价值是vi 。求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且价值最大。

与背包问题的区别是，此处的物品可以多次选择。

**解题步骤：**

1. 定义数组含义：`dp[i][v]`表示前 i 个物品在体积为 v 的情况下价值最大的所有可能
2. 转态转移公式： `f(i , v) = max(f(i -1 , v) , f(i-1, v - k *w[i])+ v[i]*k )`表示为（前面的最大价值） 与（ 去掉所有本次物品后剩余空间还能取到的最大价值 + 取本次物品个数最多的最大价值 ）的最大值。
3. 赋初值：f(0, 0) = 0 ，f(0 , i) =0 , f(i , 0) = 0



```cpp
//当 i = 1 开始时， 一定不要忘记给进来的数组是从下标 0 开始的，一定要 减1 ，不然会越界
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveAKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		vector<vector<int>> dp(m + 1, vector<int>(capacity + 1));
		//正常程序写法
		for (int i = 1; i <= m; i++) {
			for (int c = 0; c <= capacity; c++) {
                //这里 只用 k <= c/w[i -1]即可，因为 c 最大就是 capacity
				for (int k = 0; k <= c / w[i - 1] ; k++)
					dp[i][c] = max(dp[i - 1][c], 
                                   dp[i - 1][c - k * w[i -1]] + k * v[i - 1]);

			}
		}
		return dp[m][capacity];
	}

};
```



```cpp
//优化·二维数组变成一维数组
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveAKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		//dp[j] 表示前i个物品在容量为 j 时的最大价值 ，且更新为 前 i-1 与 i 的最大值
		vector<int> dp(capacity + 1);

		for (int i = 1; i <= m; i++) {
			for (int c = capacity; c >= w[i-1]; c--) {
				for (int k = 0; k <= c / w[i - 1]; k++)
					dp[c] = max(dp[c], dp[c - k * w[i - 1]] + v[i - 1]* k);
			}
		}
		return dp[capacity];
	}
};
```



```cpp
//优化2·减少一次循环·硬币题目
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveAKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		//dp[j] 表示前i个物品在容量为 j 时的最大价值 ，且更新为 前 i-1 与 i 的最大值
		vector<int> dp(capacity + 1);
		//令 c 从 w[i] 中取值，因为所有的肯能性都是基于w[i] 中的元素值来进行的
        //此时就跟硬币的题目一模一样
		for (int i = 1; i <= m; i++) {
            //下面循环的意思是：w[i -1]所能组成最大值为 c 的所有可能性
			for (int c = w[i - 1]; c <= capacity; c++) {			
				dp[c] = max(dp[c], dp[c - w[i - 1]] + v[i - 1]);
			}
		}
		return dp[capacity];
	}
};
```



### 4.6 多重背包

**题目：**有N件物品和一个容量是V的背包。第i种物品最多有si件，每件的体积是ci，价值是vi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且价值总和最大。

==多重背包只是比完全背包多了一个约束条件，即k不是一个定值，是一个动态变化的值。==

**解题步骤：**

1. 定义`dp[i][c]`：表示前 i 个物品 在容量 为 c 的情况下组成最大价值的可能
2. 状态转移方程：`f(i ,c) = max(f(i-1,c), f(i-1, c - k*w[i-1])+k*v[i])(k <= index[i])`，这个方程仅仅是比完全背包多了一个 k  的取值范围
3. 赋初值：f(0,0) = 0

```cpp
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveMKS(vector<int> w, vector<int> v, vector<int> index ,int capacity) {
		int m = w.size();
		vector<vector<int>> dp(m + 1, vector<int>(capacity + 1));

		for (int i = 1; i <= m; i++) {
			for (int c = 0; c <= capacity; c++) {
                 //区别在这儿， k 还要满足 最大不超过给的数值，即index[i]
				for (int k = 0; k <= index[i - 1] && k <= c/w[i-1]; k++) {
					dp[i][c] = max(dp[i - 1][c],
                                   dp[i - 1][c - k * w[i - 1]] + k *v[i - 1]);
				}
			}
		}
		return dp[m][capacity];
	}
};
```



```cpp
//优化·一维数组
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveMKS(vector<int> w, vector<int> v, vector<int> index ,int capacity) {
		int m = w.size();
		vector<int> dp(capacity + 1);
		
		for (int i = 1; i <= m; i++) {
			for (int c = capacity; c >= w[i - 1]; c--) {
				for (int k = 0; k <= index[i - 1] && k <= c / w[i - 1]; k++) {
					dp[c] = max(dp[c], dp[c - k * w[i - 1]] + k * v[i - 1]);
				}
			}
		}
		return dp[capacity];
	}
};
```



[参考文章](https://blog.csdn.net/weiainibuqi/article/details/105524018?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-105524018.first_rank_v2_pc_rank_v29)

```cpp
//优化·二进制优化
//本质上将 遍历次数减少了，优化的是穷举办法。比如如果 i = 7 的时候
//无论第 7 次是取还是不取，都要遍历 6 次 
//而采取二进制优化，将其分成 1 ，2 ，4 ，8 … 只需要遍历 3 次即可 
//这样转换成了01背包问题，大大优化了时间复杂度
class Good {
public:
	int v, c, n;
};

class Solution {
public: 
	int  solveMKS(vector<Good> goods , int  capacity) {
		int s = 0;
		vector<Good> newGoods;
        //将原有的物品，按照二进制的办法分成小物品
		for (int i = 0; i < goods.size(); i++) {
			s = goods[i].n;
			for (int j = 1; j <= s; j *= 2) {				
				s -= j;
				newGoods.push_back({ j *goods[i].v , j * goods[i].c });
			}
			if (s )
				newGoods.push_back({ s*goods[i].v,s* goods[i].c });
		}
		//转化成 01 背包问题
		vector<int> dp(1024);
		for (auto good : newGoods) {
			for (int j = capacity; j >= good.c; j--) {				
				dp[j] = max(dp[j], dp[j - good.c] + good.v);
			}
		}
		return dp[capacity];
	}
	
};
```



```cpp
//优化·单调队列

```





+++



## 4.7 最长有效括号

**题目：**给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**解题步骤：**

1. 定义`dp[i]:`该 i 处位置的组成有效括号的长度。例如：（（（）））dp[4] = 2

2. 状态转移方程：两种情况

   - dp[i]  = dp [i - 2] + 2
   - dp[i] = dp[i -1] + dp[i - dp[i -1] -2] +2
 3. 赋初值

 


```cpp
   class Solution {
   public:
   	int longestValidParentheses(string s) {
   		int m = s.length();
   		vector<int> dp(m + 1, 0);
   		int ans = 0; //这是简化代码初始化的变量，要是在下面就计算出最大值，代码就显得冗长
   		for (int i = 1; i <= m; i++) {
   			if (s[i ] == ')') {
   				if (s[i - 1] == '(')
   					dp[i] = i >= 2 ? dp[i - 2] + 2 : 0 + 2;
   			//前一个是左括号，则进行判断
   			//如果该i 的值与前面配对的最大值的差值 超过了2则证明有无效的括号，需要减去
   				else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(')
   					dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ?
                                         dp[i - dp[i - 1] - 2] : 0) + 2;
   			}
   			ans = max(dp[i], ans);
   		}
   		return ans;
   	}
   };
```

   

```cpp
class Solution {
public:
	int longestValidParentheses(string s) {
		int ans = 0;
		stack<int> stk;
		stk.push(-1);
        //遇到左括号，则入栈，右括号，出栈
        //直到栈顶为空，则 i + 1 ， 即为 有效长度
		for (int i = 0; i < s.length(); i++) {
			if (s[i] == '(')
				stk.push(i);
			else {
				stk.pop();
				if (stk.empty())
					stk.push(i);
				else {
					ans = max(ans, i - stk.top());
				}
			}
		}
		return ans;
	}
};
```



## 4.7 整数拆分

**题目：**给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。返回你可以获得的最大乘积。

**解题步骤：**

1. 定义`dp[i]`：数字 i 拆分后乘积能达到的最大值。

2. 状态转移方程：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

   一个是j * (i - j) 直接相乘。

   一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。

3. 赋初值：dp[2] = 1

```cpp
class Solution {
public:
	int integerBreak(int n) {
        if (n < 4) 
            return n - 1;
		vector<int> dp(n + 1);
		dp[2] = 1;
		//外层循环是遍历给的数值
		//内层循环是计算所有可能的组合数值
		for (int i = 3; i <= n; i++) {
			for (int j = 1; j < i; j++) {
				dp[i] = max(dp[i], max(j *(i - j), j * dp[i - j]));
			}
		}
		return dp[n];
	}
};
```







## 4.7 不同的二叉树搜索

**题目：**给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**解题步骤：**

1. 定义：dp[i] 1到i为节点组成的二叉搜索树的个数为dp[i]。
2. 状态转移方程（以后用递推式代替）：dp[i] += dp[j - 1] * dp[i - j]， [解释](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486532&idx=1&sn=9c3d605f6bf81027f9f39d1c45b8c4a6&scene=21#wechat_redirect)为  dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
3. 赋初值：dp[0] = 1。

```cpp
  class Solution {
  public:
	  int numTrees(int n) {
		  vector<int> dp(n + 1);
		  dp[0] = 1;
		  for (int i = 1; i <= n; i++) {
			  //j 为头节点的所有组合
			  for (int j = 1; j <= i; j++) {
				  dp[i] += dp[j - 1] * dp[i - j];
			  }
		  }
		  return dp[n];
	  }
  };
```



## 4.7 分割等和子集

**题目：**给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**思路：**可以转换成01背包问题。即总容量为 sum / 2 ， 让数组的中元素当做物品与价值。

**解题步骤：**

1. 定义dp[i]：前 i 数值所组成的最大和
2. 递推式：dp[i] = max(dp[i -1] , dp[j - nums[i]] + nums[i])
3. 赋初值：dp[0] = 0。

```cpp
  class Solution {
  public:
	  bool canPartition(vector<int>& nums) {
		  int m = nums.size();
		  int sum = 0;
		 
		  for (int i = 0; i < m; i++)
			  sum += nums[i];
		  if (sum % 2 == 1)
			  return false;
		  int target = sum / 2;
		  vector<int> dp(target + 1);
		  for (int i = 1; i <= m; i++) {
			  for (int j = target; j >= nums[i-1]; j--) {
				  dp[j] = max(dp[j], dp[j - nums[i -1]] + nums[i-1]);
			  }
		  }
		  if (dp[target] == target)
			  return true;
		  return false;
	  }
  };

```



+++



## 4.8 最后一块石头的重量II

**题目：**有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；

如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

> **拆题：**本题可以一共是取两个数，而这两个数所能组成的最大可能为 sum/2 。这样就转换成了01 背包问题。即有容量为 sum/2的背包，有stone[i] 的物品，其中c[i] 、v[i] 都是stone[i]；求两个数的最大值。

```cpp
  class Solution {
  public:
	  int lastStoneWeightII(vector<int>& stones) {
		  int m = stones.size();
		  //这里要计算容量，即个数，stone[i] 当做价值来考虑
		  int sum = accumulate(stones.begin(), stones.end(),0) ;
          int capacity = sum / 2;
		  vector<int> dp(capacity + 1);
		  dp[0] = 0;
		  for (int i = 1; i <= m; i++) {
			  for (int j = capacity; j >= stones[i -1]; j--) {
				  dp[j] = max(dp[j], dp[j - stones[i - 1]] + stones[i - 1]);
			  }
		  }
		  return sum-dp[capacity]*2 ;
	  }
  };

```



## 4.8 目标和

**题目：**给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

> **拆题：**原问题等同于： 找到nums一个正子集和一个负子集，使得总和等于target
>
> 我们假设P是正子集，N是负子集 例如： 假设nums = [1, 2, 3, 4, 5]，target = 3，一个可能的解决方案是+1-2+3-4+5 = 3 这里正子集P = [1, 3, 5]和负子集N = [2, 4]
>
> 那么让我们看看如何将其转换为子集求和问题：
>
> ```
>                   sum(P) - sum(N) = target
> sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
>                        2 * sum(P) = target + sum(nums)  
> ```

```cpp
//关键在于  上面的公式 推导 
class Solution {
  public:
	  int findTargetSumWays(vector<int>& nums, int S) {
		  int m = nums.size();
		  int sum = accumulate(nums.begin(), nums.end(), 0);
		  //公式中已经证明了 sum + S 必须是 偶数
		  if (S > sum) 
            return 0;
		  if ((sum + S) % 2 == 1)
			  return 0;
          int capacity = (sum + S) /2;

		  vector<int> dp(capacity + 1);
		  dp[0] = 1;
		  for (int i = 1; i <= m; i++) {
			  for (int j = capacity; j >= nums[i - 1]; j--) {
				  dp[j] = dp[j] + dp[j - nums[i - 1]];
			  }
		  }
		  return dp[capacity];
	  }
  };
```



## 4.8 1和0

**题目：**给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

> **拆题：**相当于二维背包，但还是同 01 背包问题的解法。

```cpp
  class Solution {
  public:
	  // m 、n 相当于是个二维背包，两层背包
	  int findMaxForm(vector<string>& strs, int m, int n) {
		  //dp[i][j] 满足 i 个 0 ， j 个 1 的最大可能数
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1));
		  //外层循环是挨个字符串进行遍历
		  for (auto s : strs) {
			  int oneNum(0), zeroNum(0);
			  for (auto e : s) {
				  if (e == '1')
					  oneNum++;
				  else
					  zeroNum++;
			  }
			  //内层循环是找出  该字符串中所有元素能满足target 的最大可能数	
			  //不要忘记dp[][] 是备忘录，记录了上次 循环的最大可能数
			  for (int i = m; i >= zeroNum; i--) {
				  for (int j = n; j >= oneNum; j--) {
					  dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
				  }
			  }
			 
		  }
		  
		  return dp[m][n];
	  }

  };
```



## 4.8 零钱兑换II

**题目：**给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

**思路：**dp的例题。硬币的题目因为计算的是总次数，不是总价值，所以只能前向遍历，累计次数。

```cpp
  class Solution {
  public:
	  int change(int amount, vector<int>& coins) {
		  int m = coins.size();
		  vector<int> dp(amount + 1);
          dp[0] = 1;
		  for (int i = 1; i <= m; i++) {
			  for (int j = coins[i -1]; j <= amount; j++) {
				  dp[j] = dp[j] + dp[j - coins[i - 1]];
			  }
		  }

		  return dp[amount];
	  }
  };
```



+++



## 4.9 组合总数IV

**题目：**给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**思路：**纸币问题（组合数），现在是升级版，求排列数。

>  **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。这个是给定选项，选项中的值仅遍历1次，每次都从target中，看每次能组合的最大值；
>
> **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。这个是给定target，target的值仅遍历1次，每次都将选项中的值依次遍历，看符合条件的个数。

> **排列的解释：**
>
> ```
> dp[j] = dp[j] + dp[j - nums[i - 1]]
> 等式右边，第一项是之前的累加，第二项是选择当前项后所有的可能性
> 
> j = 1 且 j > nums[i - 1] 时 ，i = 1，
> dp[1] = dp[1] + dp[0];
> 
> j = 2 且 j > nums[i - 1] 时，i = 1，2
> dp[2] = dp[2] + dp[1] --> 1 所有的可能性
> dp[2] = dp[2] + dp[0] --> 2 所有的可能性
> 
> j = 3 且 j > nums[i - 1] 时，i = 1，2，3
> dp[3] = dp[3] + dp[2]--> 1 所有的可能性
> dp[3] = dp[3] + dp[1]--> 2 所有的可能性
> dp[3] = dp[3] + dp[0]--> 3 所有的可能性
> ```
>
> 

```cpp
class Solution {
 public:
	  int combinationSum4(vector<int>& nums, int target) {
		  int m = nums.size();
		  vector<int> dp(target + 1);
		  dp[0] = 1;
		  for (int j = 1; j <= target ; j++) {
			  for (int i = 1; i <= m ; i++) {
				  if (j >= nums[i - 1] && dp[j] < INT_MAX - dp[j - nums[i - 1]])
					  dp[j] = dp[j] + dp[j - nums[i - 1]];
			  }
		  }
		  return dp[target];
	  }
  };


```



## 4.9 再爬楼梯

**原题(#3.23 爬楼梯)**就是一个排列问题。

**题目：**每次可以爬 1 、 2或者m 个台阶。问有多少种不同的方法可以爬到楼顶呢？

**思路：**与上题类似。求排列。

```cpp
  class Solution {
  public:
	  int climbStairs(vector<int> &stairs,int target) {
		  int m = stairs.size();
		  vector<int> dp(target + 1);
		  dp[0] = 1;

		  for (int j = 1; j <= target; j++) {
			  for (int i = 1; i <= m; i++) {
				  if(j >= stairs[i - 1])     
                      dp[j] = dp[j] + dp[j - stairs[i - 1]];
			  }
		  }
		  return dp[target];
	  }

  };
```



## 4.9 再换零钱

**题目：**给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

**思路：**完全背包问题。

```cpp
  class Solution {
  public:
	  int coinChange(vector<int>& coins, int amount) {
		  int m = coins.size();
		  vector<int> dp(amount + 1, INT_MAX);
		  dp[0] = 0;
		  for (int i = 1; i <= m; i++) {
			  for (int j = coins[i - 1]; j <= amount; j++) {
				  //比较最小值的时候，就将dp初始化为最大值
				  if (dp[j - coins[i - 1]] != INT_MAX) 
					  dp[j] = min(dp[j], 1 + dp[j - coins[i - 1]]);
				
			  }
		  }
		  if (dp[amount] == INT_MAX)  return -1;
		  return dp[amount];
	  }
  };
```



## 4.9 再求平方数

**题目：**给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

**思路：**完全背包问题。

```cpp
  class Solution {
  public:
	  int numSquares(int n) {
		  vector<int> dp(n + 1,INT_MAX);
		  dp[0] = 0;
		  for (int i = 1; i <= sqrt(n); i++) {
			  for (int j = pow(i, 2); j <= n; j++) {
				  dp[j] = min(dp[j],1 + dp[j - i * i]);
			  }
		  }
		  return dp[n];
	  }
  };
```



+++



## 4.10 单词拆分

**题目：**给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

**说明：**拆分时可以重复使用字典中的单词。

**思路：**一开始说的看成背包问题，就钻进去了，还在想怎么写出递推关系来。。。其实，本题目主要是将s字符串分割成一个个小串，将小串与字典的单词进行比较。

如果看成完全背包问题的话，这题目是求排列。相当于给定字符串s，看单词存不存在一种组合，能拼凑成是s，这就需要将所有的排列写出来，逐个查看。

```cpp
//算法·完全背包问题·求排列
 class Solution {
  public:
	  bool wordBreak(string s, vector<string>& wordDict) {
          //unordered_set 可以看成集合，里面的元素有序排列，且无重复
		  unordered_set<string> wordSet(wordDict.begin(),wordDict.end());
		  int m = s.size();
		  vector<bool> dp(m + 1);
		  dp[0] = 1;

		  for (int j = 1; j <= m; j++) {
			  for (int i = 0; i < j; i++) {
				  string str = s.substr(i, j - i);
                    //判断该串是否是字典的中的最后一个单词，
				  //如果不是，前项能匹配的前提下，该项也可
				  if ( wordSet.find(str) != wordSet.end() && dp[i])
					  dp[j] = 1;
			  }
		  }
		  return dp[m];
	  }
  };
```



```cpp
//一下是两个优化版本·膜拜大神
  class Solution {
  public:
	  bool wordBreak(string s, vector<string>& wordDict) {
		  //unordered_set 可以看成集合，里面的元素有序排列，且无重复
		  unordered_set<string> wordSet(wordDict.begin(),wordDict.end());
		  int m = s.size();
		  vector<bool> dp(m + 1);
		  dp[0] = 1;

		  int maxLength = 0;
		  int minLength = 0;
		 //s遍历的时候不必从初始为1，可以从字典中的最小值开始，因为小于字典中的值不符合条件
		 //物品 遍历的时候，可以省去一些不必要的循环，进行剪枝，
		 //当背包容量大于字典中的最大值的时候不需要从初始位置再进行判断了，具体看下面详解
		  for (auto e : wordDict) {
			  const int t = e.length();
			  maxLength = max(t, maxLength);
			  minLength = min(t, minLength);
		  }

		  for (int j = minLength; j <= m; j++) { //遍历背包
			  for (int i = max(0,j - maxLength); i < j; i++) { //遍历物品
				  string str = s.substr(i, j - i);
				  //判断该串是否是字典的中的最后一个单词，
				  //如果不是，前项能匹配的前提下，该项也可
				  if (dp[i] && wordSet.find(str) != wordSet.end())
					  dp[j] = 1;
			  }
		  }
		  return dp[m];
	  }
  };
```

```
当最大值为 4 的时候，i 表示 起始位置， j - i 代表 截取的长度
j = 1, i = 0, 1
j = 2, i = 0, 1, 2
j = 3, i = 0, 1, 2, 3
j = 4, i = 0, 1, 2, 3, 4 
//到上面，已将完成对 字符串最大长度的截取，如果最大长度无法匹配字典中的值，那么不符合条件
j = 5, i = 1, 2, 3, 4, 5
j = 6, i = 1, 2, 3, 4, 5, 6
```



## 4.10 打家劫舍

**题目：**你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

> **经典问题：打家劫舍，问题的核心在于不能取相邻的两个放间，只能隔一个或几个房间取，**
>
> **即转换成了     第 i 房间到底是偷不偷。如果偷，那么dp[i] = dp[i - 2] + nums[i];**
>
> **如果不偷，那么dp[i] = dp[i - 1]，该房间的最大值跟前一房间最大值相同，且前一房间跟本房间的奇偶性**
>
> **不同，将所有问题情况都考虑在内了。**

```cpp
  class Solution {
  public:
	  int rob(vector<int>& nums) {
		  int m = nums.size();
		  if (m == 0) return 0;
		  if (m == 1) return nums[0];
		  vector<int> dp(m);
		  dp[0] = nums[0];
		  dp[1] = max(nums[1], dp[0]);
		  
		  for (int i = 2; i < m; i++) {
			  //dp[i - 1]: 当第 i 间 房间不偷时，那么最高价值跟前一房间相同
			  //所以 dp[i - 1] 也代表了不同奇偶性的最大值
			  dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
		  }
		  return dp[m - 1];
	  }
  };
```



## 4.10 打家劫舍II

**题目：**这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。

> 这不是隔一个房间取得问题，而是选出不相邻的，组合值为最大的可能。

这道题目和==打家劫舍==是差不多的，唯一区别就是成环了。

对于一个数组，成环的话主要有如下三种情况：

- 情况一：考虑不包含首尾元素

![图片](刷题日记.assets/640)

- 情况二：考虑包含首元素，不包含尾元素

![图片](刷题日记.assets/640)

- 情况三：考虑包含尾元素，不包含首元素

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ciaqDnJprwv7DroYFRD2ITKia9UcE5BhI7wGSP3yF2VibOyd1DKBwDSTiaGvqRNAiaXicu9zhMVsmlJAzPMWW7iclmsZQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**注意我这里用的是"考虑"**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！对于情况三，取nums[1] 和 nums[3]就是最大的。

**而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了。**

```cpp
  class Solution {
  public:
	  int rob(vector<int>& nums) {
		  int m = nums.size();
		  if (m == 0) return 0;
		  if (m == 1) return nums[0];

		  int res1 = robRange(nums, 0, m - 2);
		  int res2 = robRange(nums, 1, m - 1);
		  return max(res1, res2);
	  }

	  int robRange(vector<int> &nums, int start, int end ) {
		  if (start == end) return nums[start];

		  int m = nums.size();
		  vector<int> dp(m);
		  dp[start] = nums[start];
		  dp[start + 1] = max(nums[start],nums[start + 1]);

		  for (int i = start + 2; i < m; i++) {
			  //dp[i - 1]: 当第 i 间 房间不偷时，那么最高价值跟前一房间相同
			  //所以 dp[i - 1] 也代表了不同奇偶性的最大值
			  dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

		  }
		  return dp[end];
	  }
  };
```



## 4.10 打家劫舍III

**题目：**在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**思路：**==树形DP的入门题目。==

**解题步骤：**

1. 定义dp[0]：不取该节点的最大值；dp[1]：取该节点的最大值。对于**树**来说，数字对于读取数据没有作用，读取左子树：利用 `root->left`，读取根节点：`root->val`；
2. 递推式：这里是递归关系。看成一个大问题分解成若干子问题，解决掉最小的子问题，返回解决大问题。
3. 递归结束条件：`curr == nullptr`



```cpp
  class Solution {
  public:
	  int rob(TreeNode* root) {
		  //定义以为一维 memo 用来存放结果
		  //其中，该 result 一共两个值，result[0] 代表不选该节点的最大值.,result [1] 代表选择该节点的最大值
		  //本题解法秒就秒在用两个值就解决了memo 的作用
		  vector<int> result = robTree(root);
		  return max(result[0], result[1]);
	  }
	  vector<int> robTree(TreeNode* curr) {
		  if (curr == nullptr) return { 0 ,0 };
		  vector<int> leftV = robTree(curr->left);
		  vector<int> rightV = robTree(curr->right);
           // 这里之所以带上[0],是为了更新 val1 中的值，以此来做 memo，记录上次的最大值
           // 不选该节点，则就是最大值，选择该节点，则计算结果，下一轮就最大值
		  int val0 = max(leftV[0], leftV[1]) +  max(rightV[0], rightV[1]);
		  int val1 = curr->val + leftV[0] + rightV[0];
		  return { val0,val1 };
	  }
  };
```



+++



## 4.11 买卖股票的最佳时机

**题目：**给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

原题 3.23 做过贪心算法，此题的最优解也是贪心算法。

**思路：**贪心算法比较直观简答，就不赘述了。对于动态规划算法，按照步骤来

1. 定义`dp[i][0]`代表第 i 天不持有股票的现金；`dp[i][1]` 代表持有股票的现金；

2. `dp[i][0] = max(dp[i - 1][0], -prices[i])`:一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数

3. `dp[i][1]  = max(dp[i - 1][1], dp[i - 1][0] + prices[i])`

   

```cpp
//贪心·算法
class Solution{
public:
    int maxProfit(vector<int> &prices){
        if(prices.size() < 2)
            return 0;
        int profit=0;
        int buy=prices[0];
        for(int i = 1; i < prices.size(); i++){
            buy = min(buy, prices[i]);
            profit = max(profit, prices[i] - buy); 
		}
        return profit;
	}
};
```



```cpp
//动态规划·算法
 //一共 m 个数据，每个数据只需要两个维度， 1（买？）代表持有股票， 0(卖？）代表不持有股票
//给出理解，当取 1  的时候，有买的倾向，取 0 卖的倾向
 class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		
		  vector<vector<int>> dp(m, vector<int>(2));
		  dp[0][0] =0;
		  dp[0][1] = -prices[0];
		  for (int i = 1; i < m; i++) {
			  dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1]);
              //昨天买的跟今天买的比较一下谁大（转换成负数，越大绝对值越小）
			  dp[i][1] = max(dp[i - 1][1], -prices[i]);
		  }
		  return dp[m - 1][0];
	  }
  };
```



```cpp
//dp算法·用滚动数组来优化
class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		  //一共 m 个数据，每个数据只需要两个维度， 1 代表选择， 0 代表不选择
		  vector<vector<int>> dp(2, vector<int>(2));
		  dp[0][1] = -prices[0];
		  dp[0][0] = 0;
		  for (int i = 1; i < m; i++) {
			dp[i % 2][1] = max(dp[(i - 1) % 2][1], -prices[i ]);
			dp[i % 2][0] = max(dp[(i - 1) % 2][0], prices[i] + dp[(i - 1) % 2][1]);
		  }
		  return dp[(m - 1) % 2][1];
	  }
  };
```





## 4.11 买卖股票的最佳时机II

**题目：**给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**升级，可以完成不限次交易**

 **可以多次买卖股票，但不能买同一支。**

```cpp
//0 ->不持有股票  1 ->持有股票
//不持有股票分为：之前卖了，或者 今天卖了
//持有股票分为：之前买了 ， 现在买
  class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		  //这样理解：之前买：现在买；之前卖：现在卖
          //dp[i][0]：第 i 天不持有股票的最大价值
          //dp[i][1]：第 i 天持有股票的最大价值
		  vector<vector<int>> dp(m, vector<int>(2));
		  dp[0][0] =0;
		  dp[0][1] = -prices[0];
		  for (int i = 1; i < m; i++) {
              //罗列了所有可能性，每一天都参与计算买入或卖出
			  dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
			  dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
		  }
		  return dp[m - 1][0];
	  }
  };
```



## 4.11 买卖股票的最佳时机III

**题目：**给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**升级，最多可以完成两笔交易**

**解题步骤：**更详细的点[这里](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487244&idx=2&sn=d4cefe597a0d5500adec6bff944c4bf5&scene=21#wechat_redirect)。

1. 定义`dp[i][j]`：第 i 天状态 j 能达到的最大值；其中状态 j 分为 5 个， [0] 代表什么都不做，[1] 代表第 1 次买入，[2] 代表第 1 次卖出，[3] 代表第 2 次买入，[4] 代表第 2 次卖出。

2. 递推式：`dp[i][1] = dp[i - 1][0] - price[i]`，`dp[i][2] = dp[i - 1][1] + price[i]`，`dp[i][3] =  dp[i - 1][2] - price[i]`，`dp[i][4] = dp[i - 1][3] + prices[i]`

   其中 `dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])`，

    `dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])`， 

   `dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])`，

    `dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])`。

3. 赋初值：`dp[0] = 0 , dp[1] = -price[0]，dp[2] = 0，dp[3] = -price[i]，dp[4] = 0`

**解释一下：**

```

达到dp[i][1]状态，有两个具体操作：

操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]
那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？

一定是选最大的，所以 dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);

同理dp[i][2]也有两个操作：

操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]
操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]
所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])

同理可推出剩下状态部分：

dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);

dp数组如何初始化
第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;

第0天做第一次买入的操作，dp[0][1] = -prices[0];

第0天做第一次卖出的操作，这个初始值应该是多少呢？

首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，

从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。

所以dp[0][2] = 0;

第0天第二次买入操作，初始值应该是多少呢？

不用管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：dp[0][3] = -prices[0];

同理第二次卖出初始化dp[0][4] = 0;

确定遍历顺序
从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。


```

```cpp
//供参考的代码、
  class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		  if (m == 0)	 return 0;
		  vector<vector<int>> dp(m, vector<int>(5, 0));
		  dp[0][1] = -prices[0];
		  dp[0][3] = -prices[0];
          //真实现起来，代码逻辑并不难懂
		  for (int i = 1; i < m; i++) {
			  dp[i][0] = dp[i - 1][0];
			  dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
			  dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
			  dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
			  dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
		  }
		  return dp[m - 1][4];
	  }
  };
```



## 4.11 买卖股票的最佳时机IV

**题目：**给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**又升级了，变成最多交易K次。**

==解题思路跟步骤同   最佳时机III==，只是这里更具有通性，限制在 K 次。

```cpp
//每奇数次 都是持有股票，偶数次 都是不持有股票
//所以只需要两个迭代式，memo 容器需要 2 * k 那么大，其中 为了方便定位 2 * k + 1 次，当状态为0 的时候我不选择 用
class Solution {
 public:
	  int maxProfit(int k, vector<int>& prices) {
		  int m = prices.size();
		  if (m == 0) return 0;
           //dp[i][1]：第 i 天持有股票的最大价值 ，即买入股票
           //dp[i][2]：第 i 天不持有股票的最大价值，即卖出股票
		  vector<vector<int>> dp(m, vector<int>(2 * k + 1, 0));
          //将第 0 天的买入都记为负数值，卖出 记为0，以此来初始化
		  for (int j = 1; j < 2 * k; j += 2)  dp[0][j] = -prices[0];
		  for (int i = 1; i < m; i++) {
			  for (int j = 0; j < 2 * k - 1; j += 2) {
				  dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
				  dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
			  }
		  }
		  return dp[m - 1][2 * k];
	  }

  };
```



+++



## 4.12 买卖股票的最佳时机V

**题目：**给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。



**解题步骤：**

1. 定义`dp[i][j]`为第 i 天 j 转态 j 情况下所卖出的最大值；其中 状态 j 有4 个值，[1]-- 买入 ， [2]--卖出，[3]--冷冻期，[4]--过了冷冻期；
2. 递推式：其他的与往常无异，只有一点，当天状态如果是[卖出]的话，只能是当天[卖出]，不能是之前卖出，因为之前卖出，那么今天状态必是 [冷冻期]；
3. 赋初值：与往常一致。

```cpp
  class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		  if (m == 0) return 0;
		  //1-持有 2-未持有 3-冷冻期 4-过冷冻期
		  vector<vector<int>> dp(m, vector<int>(5, 0));
		  dp[0][1] = -prices[0];

		  for (int i = 1; i < m; i++) {
			  //当天持有的转态，则可能是之前买入，或者当天买入
			  dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][4], dp[i - 1][3]) - prices[i]);
			  dp[i][2] = dp[i - 1][1] + prices[i];
			  dp[i][3] = dp[i - 1][2];
			  dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]);
			
		  }
		  //最后返回的一定一个未持有转态，细分为 当天为 冷冻期、过了冷冻期、卖出转态
		  //其中冷冻期跟过了冷冻期本质上价值是一样的，这里都列出来是为了防止给的数据 没有过冷冻期的状态
		  return max(dp[m - 1][3], max(dp[m - 1][4], dp[m - 1][2]));
	  }
  };
```





## 4.12 买卖股票的最佳时机VI

**题目：含手续费**。给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

==与 II 类似，不过是多减去一个fee== 

```cpp
//dp·算法
class Solution {
  public:
	  int maxProfit(vector<int>& prices, int fee) {
		  int m = prices.size();
		  if (m == 0)  return 0;
          //多次交易，不限次数，所以深度为 2 即可
           //dp[i][0]：第 i 天不持有股票的最大价值
           //dp[i][1]：第 i 天持有股票的最大价值
		  vector<vector<int>> dp(m, vector<int>(2,0));
          //正常赋值，并无异常
		  dp[0][1] = -prices[0];
		  for (int i = 1; i < m; i++) {
              //将所有天 依次买入卖出，计算下最大值
			  dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
			  dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
		  }
		  return dp[m - 1][0];
	  }
  };
```



## 4.12 最长递增子序列

**题目：**给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

**问题：**对于类似于这种题目的逻辑，总是不好厘清，并且总是过于复杂化。要多记几个样式，减轻逻辑负担，减少代码冗

```cpp
//该逻辑值得深敲
class Solution {
  public:
	  int lengthOfLIS(vector<int>& nums) {
		  int m = nums.size();
		  if (m <= 1)	return m;
		  //无论是从哪个位置开始，最小长度都是 1 
           //dp[i]:第 i 个 数的子序列个数
		  vector<int> dp(m, 1);
		  int result = 0;
          //先确定后序位置，在确定前序位置，会方便的多
		  for (int i = 1; i < m ; i++) {
			  for (int j = 0; j < i; j++) {
				  if(nums[i] > nums[j])		dp[i] = max(dp[i], dp[j] + 1)				 	 }
			  result = max(result, dp[i]);
		  }
		  return result;
	  }
  };
```

> 例如：10， 9， 2， 5， 3， 7， 101， 18
>
> 当取到 7 这个值的时候，所能组成的子串有很多个， 7 > 5   7 > 2  7 > 3，所以只需要看 5，2，3所能组成的最长串即可。由之前遍历可知，5 所能组成的最长子串为 2 ，同理 3（2） ，2（1）。故 7 能组成的最长子串为 前面的最长长度  +  1。
>
> ==本质上求组合数。==



+++



## 4.13 最长连续递增序列

**题目：**给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

**相比上面题目，是严格递增的。代码复杂度要少很多。**

```cpp
//dp·算法
class Solution {
  public:
	  int findLengthOfLCIS(vector<int>& nums) {
		  int m = nums.size();
          if(m <= 1) return m;
          //dpp[i] : 下标为 i 的时候，子序列的个数
		  vector<int> dp(m, 1);
		  int result = 0;
          //如果后项比前项大，就记录到 memo 中，自增，选出最大值
		  for (int i = 1; i < m; i++) {
			  if(nums[i] > nums[i - 1])  dp[i] = dp[i - 1] + 1;
			  result = max(dp[i], result);
		  }
		  return result;
	  }
  };
```



```cpp
//贪心·算法 本质上与dp算法一样，只是优化了许多，节省了内存
  class Solution {
  public:
	  int findLengthOfLCIS(vector<int> &nums) {
		  int m = nums.size();
		  if (m <= 1) return 1;
          //定义计数器
		  int count = 1; 
		  int result = 0;
		  for (int i = 1; i < m ; i++) {
              //与上面无异 ，如果后项大于前项，则计数器 自增
			  if (nums[i] > nums[i - 1])   count++;
              //否则，将其置为 1 ，重新开始计算
                  else  count = 1;
			  result = max(result, count);
		  }
		  return result;
	  }
  };
```



## 4.13 最长重复子数组

**题目：**给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。==找相同的地方。==

**相比于上题目，增加了一个维度。上面是对一个数组求最大长度，只需要一个遍历，下面是对两个数组，则需要两个遍历。**

```cpp
//dp·算法 二维数组
class Solution {
  public:
	  int findLength(vector<int>& nums1, vector<int>& nums2) {
		  int m = nums1.size();
		  int n = nums2.size();
		  if (m == 0 || n == 0) return 0;
		  int result = 0;
		  //这里用下标 1 ，2 会方便很多，所以从 1 开始 共需要 m + 1 个大小
		 //dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，
          //最长重复子数组长度为dp[i][j]。
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
          //依次遍历两个数组， 如果前组的值 = 后组的值，则计数器加 1 ，否则置0
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
				  if(nums1[i - 1] == nums2[j - 1])   
                      dp[i][j] = dp[i - 1][j - 1] + 1;
				  else dp[i][j] = 0;
				  if (dp[i][j] > result) result = dp[i][j];
			  }
		  }
		  return result;
	  }
  };
```



![屏幕截图 2021-04-13 103325](刷题日记.assets/屏幕截图 2021-04-13 103325.png)



```cpp
//dp·算法 滚动数组  
class Solution {
  public:
	  int findLength(vector<int>& nums1, vector<int>& nums2) {
		  int m = nums1.size();
		  int n = nums2.size();
		  if (m == 0 || n == 0) return 0;
		  int result = 0;
           
		  vector<int> dp(n + 1, 0);
		  //因为dp 只与前项的值有关，所以可以用一维数组来简化，记录上次的最大值，更新memo
          //从后向前遍历，避免重复覆盖
		  for (int i = 1; i <= m; i++) {
			  for (int j = n; j > 0; j--) {
                   // 如果两个数组的数相等，则记录 memo，+ 1，否则记为 0
				  if (nums1[i - 1] == nums2[j - 1])  dp[j] = dp[j - 1] + 1;
				  else dp[j] = 0;
				  if (dp[j] > result) result = dp[j];
			  }
		  }
		  return result;
	  }
  };
```







==滑动窗口解释如下图：==

```cpp
//滑动窗口·见具体专题



```



## 4.13 最长公共子序列

**题目：**给定两个字符串 str 1和 str 2，返回这两个字符串的最长公共子序列的长度。==找最大的组合。==

给个dp表格，一看就懂。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ciaqDnJprwv4Stw2Ra0d202BvyjCibf9go5KgAvaQNibF2oYK4CKml9mr0qnmjF0C7unejBREe5icSLAwXrn9XP5dA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```cpp
  class Solution {
  public:
	  int longestCommonSubsequence(string text1, string text2) {
		  int m = text1.size();
		  int n = text2.size();
           //dp[i][j]:下标为 i - 1， j - 1 的两个数组的公共子序列的长度
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
                  //如果相等，则 + 1
				  if (text1[i - 1] == text2[j - 1])  dp[i][j] = dp[i - 1][j - 1] + 1;
                  //否则取前面的最大值
				  else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
			  }
		  }
		  return dp[m][n];
	  }
  };
```



## 4.13 不相交的线

**题目：**我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。以这种方法绘制线条，并返回我们可以绘制的最大连线数。

本质上与最长的公共子序列问题相同。

```cpp
  class Solution {
  public:
	  int maxUncrossedLines(vector<int>& A, vector<int>& B) {
		  int m = A.size();
		  int n = B.size();
          //最长子序列的个数
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
          
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
                  
				  if (A[i - 1] == B[j - 1])
					  dp[i][j] = dp[i - 1][j - 1] + 1;
				  else
					  dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
			  }
		  }
		  return dp[m][n];
	  }
  };
```



## 4.13 判断子序列

**题目：**给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。==只需要删除。==

**思路：** 因为这里只设计到删除，所以可以用上面最长公共子序列的思路来做。看是否为子序列，即看s、t 的最长子序列的长度是否为 t的长度即可。但是要注意，子序列为0，是OK；源序列为 0，不可以。

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
          int m = s.size();
		 int n = t.size();
          if(m == 0)  return true;
          if(n == 0)  return 0;
		  int ret = m > n ? n : m;
          //dp[i][j]: i 和 j 处的子序列的长度
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
				  if (s[i - 1] == t[j - 1])
					  dp[i][j] = dp[i - 1][j - 1] + 1;
				  else
					  dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
			  }
		  }
		  return dp[m][n] == ret;

    }
};
```



**思路2：**编辑距离。

```cpp
  class Solution {
  public:
	  bool isSubsequence(string s, string t) {
		  int m = s.size();
		  int n = t.size();
		  if (m == 0) return 1;
		  if (n == 0) return 0;
          //第 i 、j 处的最长子序列长度
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
                    //如果 i 处 = j 处，则 长度 + 1
                    //否则 该长度 = 上次长度
				  if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
				  else  dp[i][j] = dp[i][j - 1];
			  }
		  }
		  return dp[m][n] == m;
	  }
  };
```



## 4.13 不同子序列

**题目：**给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "A B C D E" 的一个子序列，而 "A EC" 不是）。题目数据保证答案符合 32 位带符号整数范围。

**解题步骤：**

1. 定义`dp[i][j]`：长度为 i 的 s 子串中含有 长度为 j 的子串的个数
2. 递推式：考虑 `s[i - 1] == t[i - 1]`是否使用，当该字符匹配的时候，有两种情况，当该字符为第一次出现跟第n次出现。所以`dp[i][j] =  dp[i - 1][j - 1] + dp[i - 1][j]`，其中前项是该字符匹配的个数，后项为找一下前面 **有此字符** 的个数
3. 初始化：`dp[0][0] = 1 `，空串 s 中含有空串 t 的个数为1。



```cpp
  class Solution {
  public:
	  int numDistinct(string s, string t) {
		  int m = s.size();
		  int n = t.size();
		  if (m < n) return 0;
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1));
          //将所有 s 串为 0 的都置为 0 ， 因为s !=0
          //将所有 t 串为 0 的都置为 1 ， 因为 s 一定包含空串
		  for (int i = 0; i <= m; i++)  dp[i][0] = 1;
		  for (int j = 1; j <= n; j++)  dp[0][j] = 0;
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
                  //如果该位置匹配到了，则有两种情况，其一，该字符为首次出现
                  //其二该字符是第 n 次出现
				  if (s[i - 1] == t[j - 1]) 
                      	dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                  //如果该位置没有匹配到，则记录之前的 memo，向下进行
				  else  dp[i][j] = dp[i - 1][j];
			  }
		  }
		  return dp[m][n];
	  }
  };
```



## 4.13 两个字符串的删除操作

**题目：**给定两个单词 word 1 和 word 2，找到使得 word 1 和 word 2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

思路跟==不同的子序列==一样。具体分析看代码注释。

```cpp
  class Solution {
  public:
	  int minDistance(string word1, string word2) {
		  int m = word1.size();
		  int n = word2.size();
		  //dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1));
          //如果有空串，则次数为 i 或者为 j
		  for (int i = 0; i <= m; i++)  dp[i][0] = i;
		  for (int j = 0; j <= n; j++)  dp[0][j] = j;
         // 当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];
         // 当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：
		//情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1
		//情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1
	//情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2
	//那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：
    //dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
				  if (word1[i - 1] == word2[j - 1])  dp[i][j] = dp[i - 1][j - 1];
				  else dp[i][j] = min({ dp[i - 1][j] + 1,
                                       dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2 });
			  }
		  }
		  return dp[m][n];
	  }
  };

```



+++



## 滑动窗口

### 4.14 最小覆盖子串

**双指针技巧的进阶：滑动窗口技巧**

> 解法步骤：主要是双指针——右指针右移，直到能包含符合的条件；接着左指针右移，直到包含的最小情况出现，接着左移一次，不满足条件后，重复以往，直至尽头。没左移一次要记得更新==memo==。

**题目：**给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 `""` 。

**解题步骤：**

1. 定义4个变量：`left` 和 `right`，用来记录 start ，end 的状态指针；
2. 右指针右移，涵盖条件，接着左指针右移，更新状态，每个题目对应的细节不同，要仔细把握；但一定记得，先添值在判断，先判断后删值；
3. 找出最优解。

```cpp
//给的参考答案，用的 while 循环
//下面有我自己写的个 for 循环（钟爱for循环）^_^
class Solution {
  public:
	  string minWindow(string s, string t) {
		  //哈希表 key：字符， value：个数
		  unordered_map<char, int> need, window;
		  //将 t 中的元素都添加到 need 字典中
		  for (auto e : t)  need[e]++;
		  //cout << need['a'] << endl;
		  int left(0), right(0);  //左右指针
		  int ret = 0;  //
		  int start = 0, len = INT_MAX;
		  while (right < s.size()) {
			  char c = s[right];
			  //这里 right 先 + 1 了，所以数据长度不用 + 1
			  right++;
			  if (need.count(c)) {
				  window[c]++;
				  if (need[c] == window[c])  ret++;
			  }
			  while (ret == need.size()) {
				  if (right - left < len) {
					  start = left;
					  len = right - left;
				  }
				  char d = s[left];
				  left++;
				  if (need.count(d)) {
					  if (window[d] == need[d])  ret--;
					  window[d]--;
				  }
			  }
		  }
		  return len == INT_MAX ? "" : s.substr(start, len + 1);
	  }
  };
```



> `dict[e]++`：e 代表 unordered_map 中的 key 值，`dict[e]` 为value，++，即value 自增。
>
> 判断某key是否存在可以使用map的count方法来间接判定。

```cpp
//for 循环
  class Solution {
  public:
	  string minWindow(string s, string t) {
		  //哈希表 key：字符， value：个数
		  unordered_map<char, int> dict, window;
		  //将 t 中的元素都添加到 need 字典中
          /*
          * dict[e]++：e 代表 unordered_map 中的 key 值，dict[e] 为value，++，即value++
          */
		  for (auto e : t)  dict[e]++;
		  int start = 0, len = INT_MAX;
		  int valid = 0;
		  //先定义 左右指针，右指针先走扩大窗口，左指针后走，缩小窗口
		  int left = 0, right = 0;
		  //先扩大窗口，并且给窗口赋值
		  for (; right < s.size(); right++ ) {
			  //右指针逐个取值
			  char c = s[right];
			  //如果字典中有该元素，那么加入到窗口中，同时有效长度递增
               //当遇到重复的元素的时候，也添加进去，不过 value 则递增
			  if (dict.count(c)) {
				  window[c]++;
                    //只有当字典中的 value 与 窗口中的 value相同时，
                    //说明该元素是第一次加入，则有效长度
				  if (dict[c] == window[c])  valid++;
			  }
			  //当有效长度跟字典长度一致时，即在目标源找到了合适的解，需要缩小窗口
				  for (; valid == dict.size(); left++) {
					  //选取中最小的长度，这里注意，数据长度 = 对应元素下边的差值 + 1
					  if (right - left < len) {
						  start = left ;
						  len = right - left + 1;
					  }
					  //如果字典中在最小长度处找到了该值，则窗口继续缩小，
					  //更新下一个合适的解，进行比较
					  char d = s[left];
					  if (dict.count(d)) {
                           //如果字典中有该元素，那么窗口中一定添加了该元素，
                           //要执行自减运算，保证 窗口中最多允许有 1 个元素
                         //  window[d]--;
                           //当窗口中的 value 跟字典中的 value 相同时，
                           //窗口可以缩小了，有效长度自减
						 if (dict[d] == window[d]) valid--;
                           //这里的语句不能放到前面，因为如果先减了，
                           //则 if 永远不能判断正确
						 window[d]--;
					  }
				  }
		  }
		  return len == INT_MAX ? "" : s.substr(start, len);
	  }
  };

```



### 4.14 字符串排列

**题目：**给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的排列。换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。

**思路：**问题跟最小覆盖子串类似，只不过该子串的排列都是连续的，最小覆盖子串字符可以不是连续的。最终问题转化成求在s 2中是否含有长度、字符等于s 1 的子串。

**解题步骤：**因为比较钟爱 for 循环，所以用 for 写的。

1. 定义左右两个指针，left 、right = 0；
2. 找到右指针移动条件，即往窗口中添加元素；左指针移动条件，即 window 中删掉元素；
3. 找到最优结果，即返回条件。

> 滑动窗口一般解题步骤：
>
> 1. 大体框架类似，定义左右指针，有的题目需要start，len 等状态变量；
> 2. 向字典中添加要求元素，右指针右移条件：向窗口中添加元素；左指针右移：向窗口中删减元素；
> 3. 找到返回条件，即什么时候推出循环，该窗口达到最优解。

```cpp
 class Solution {
  public:
	  bool checkInclusion(string s1, string s2) {
           //定义字典、窗口等哈希表
		  unordered_map<char, int> dict, window;
		  int start = 0;
		  int valid = 0;
           //向字典中添加要求值
		  for (auto e : s1)	 dict[e]++;
           //指针右移
		  for (int left = 0, right = 0; right < s2.size(); right++) {
			  char c = s2[right];
			  if (dict.count(c)) {
                   //向窗口中添加条件值
				  window[c]++;
				  if (window[c] == dict[c]) valid++;
			  }
               //指针左移
			  for (; valid == dict.size(); left++) {
                    //退出循环条件
				  if (right - left  + 1 == s1.size()) return true;
				  char d = s2[left];
				  if (dict.count(d)) {
					  if (dict[d] == window[d])  valid--;
					  window[d]--;
				  }
			  }
		  }
		  return false;
	  }
  };
```



```cpp
//while 循环写法
  class Solution {
  public:
	  bool checkInclusion(string s1, string s2) {
		  //定义字典、窗口等哈希表
		  unordered_map<char, int> dict, window;
		  int start = 0;
		  int left = 0, right = 0;
		  int valid = 0;
		  for (auto e : s1) dict[e]++;
		  while (right < s2.size()) {
			  char c = s2[right];
			  if (dict.count(c)) {
				  window[c]++;
				  if (dict[c] == window[c]) valid++;
			  }
			  while (valid == dict.size()) {
				  char d = s2[left];
				  if (right - left == s1.size())  return true;

				  if (dict.count(d)) {
					  if (dict[d] == window[d])	valid--;
					  window[d]--;
				  }
				  left++;
			  }
			  
			  right++;
		  }
		  return false;
	  }
  };
```



### 4.14 找所有字母异位词

**题目：**给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

**思路：**跟之前的做的题目大同小异，最基本的即使最小覆盖子串，然后本题最相近的是字符串排列。他俩的不同点仅在于该题输出下标，上题输出布尔值。

```cpp
 class Solution {
  public:
	  vector<int> findAnagrams(string s, string p) {
		  unordered_map<char, int> dict, window;
           //用来接收最后的结果
		  vector<int> v;
		  int start = 0, len = s.size();
		  int valid = 0;
           //字典初始化
		  for (auto e : p)  dict[e]++;
		  for (int left = 0, right = 0; right < s.size(); right++) {
			  char c = s[right];
			  if (dict.count(c)) {
				  window[c]++;
				  if (dict[c] == window[c])   valid++;
			  }
			  for (; valid == dict.size(); left++) {
                    //完成要求，如果找到了长度符合的子串，则记录下左指针的值
				  if (right - left + 1 == p.size())		v.push_back(left);
				  char d = s[left];
				  if (dict.count(d)) {
					  if (dict[d] == window[d])  valid--;
					  window[d]--;
				  }
			  }
		  }
		  return v;
	  }
  };
```



### 4.14 最长无重复子串

**题目：**给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**思路：**不含重复字符的最长子串，只能是从每个字符第一次出现的地方开始计数；如果遇到重复字符，那么只能从第一次出现该字符的下一位置重新开始。

```cpp
//例如 abcbe，到碰到第二个b的时候，需要从第一次b出现的地方下一位置重新计数 
class Solution {
  public:
	  int lengthOfLongestSubstring(string s) {
		  unordered_map<char, int> window;
		  int ans = 0;  // memo：用来计算长度
		  for (int left = 0, right = 0; right < s.size(); right++) {
			  char c = s[right];
			  window[c]++;
              //下面这个循环，将重复字符之前的字符全部去掉
              //因为不含重复字符的最长子串只能是从字符第一次出现的地方开始计数
			  for (; window[c] > 1; left++) {
				  char d = s[left];
				  window[d]--;
			  }
			  ans = max(ans, right - left + 1);
		  }
		  return ans;
	  }
  };
```



```cpp
//还可以这么写
  class Solution {
  public:
	  int lengthOfLongestSubstring(string s) {
		  int length = 0;
		  int ans = 0;
		  int index = 0;
		  for (int right = 0; right < s.size(); right++) {
			  char tempChar = s[right];
               //这里注意，必须要给left赋初值
               //left = 重复元素的下一位置开始重新计数
               //如果用left本身计数，会导致一旦没有匹配的字符，left++，无法重置
               //如果 left 从0开始，这不符合要求
			  for (int left = index; left < right; left++) {
				  if (tempChar == s[left]) {
					  index = left + 1;
					  length = right - index;
					  break;
				  } 
			  }
			  length++;
			  ans = max(ans, length); 
		  }
		  return ans;
	  }
  };
```



+++



### 4.15 最长重复子数组

**题目：**给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

如下图分析：

![错开比较.gif](刷题日记.assets/9ed48b9b51214a8bafffcad17356d438b4c969b4999623247278d23f1e43977f-错开比较.gif)

代码如下：

```cpp
  class Solution {
  public:
	  int findLength(vector<int>& nums1, vector<int>& nums2) {
		  return nums1.size() <= nums2.size() ? helper(nums1, nums2) : helper(nums2, nums1);
	  }
	  //后者 > 前者，即 n > m
	  int helper(vector<int> &nums1, vector<int> &nums2) {
		  int m = nums1.size();
		  int n = nums2.size();
		  int ret = 0;
		  //动的 数组从最右端进入，一直到第一数组结束的地方。
		  for (int len = 1; len <= m; len++) {
			  int templen = maxLen(nums1, 0, nums2, m - len, len);
			  ret = max(ret, templen);
		  }
		  //数组在中间过程的时候,这时候B比A大
		  for (int len = n; len >= m; len --) {
			  int templen = maxLen(nums1, 0, nums2, n - len, len);
			  ret = max(ret, templen);
		  }
		  //数组出去的时候
		  for (int len = m; len >= 1; len--) {
			  int templen = maxLen(nums1, m - len, nums2, 0, len);
			  ret = max(ret, templen);
		  }
		  return ret;
	  }

	  int maxLen(vector<int> &nums1, int index1, vector<int> &nums2, int index2, int len) {
		  int ret = 0;
		  int  count = 0;
		  for (int i = 0; i < len; i++) {
			  //如果有相同的值，则计数器自增
			  if (nums1[index1 + i] == nums2[index2 + i])  count++;
			  //如果有不同的值，则记录最大值，重新开始计数，
			  else if (count > 0) {
				  
				  count = 0;
			  }
			  ret = max(ret, count);
		  }
		  return ret;
	  }
  };
```



### 4.15 尽可能使字符串相等

**题目：**给你两个长度相同的字符串，s 和 t将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。

如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。

**思路：**该窗口只需要从目标处移动即可，符合条件时候，右移；越界了，就左移。

```cpp
  class Solution {
  public:
	  int equalSubstring(string s, string t, int maxCost) {
		  int ans = 0;
		  int cost = 0;  // 用来记录能否满足条件值
		  for (int left = 0, right = 0; right < s.size(); right++) {
			  cost += abs(s[right] - t[right]);
			  //窗口左移，删减掉之前的元素
			  //判断条件是大于条件值的时候才选择左移，等于不移
			  for (; cost > maxCost; left++) {
				  cost -= abs(s[left] - t[left]);
			  }
			  //结果是要保存长度
			  ans = max(ans, right - left + 1);
		  }
		  return ans;
	  }
  };
```



### 4.15 滑动窗口的最大值

**题目：**给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

==具体分析看代码。==

```cpp
//严格意义上来讲，本题跟滑动窗口没有关联  
class Solution {
  public:
	  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		  //用list是因为它可以头删，vector不能头删，
		  //同理，deque也可以头删，下面就用deque来写
		  list<int> window;
		  int  index = 0;
		  vector<int> res(nums.size() - k + 1);
		  for (int right = 0; right < nums.size(); right++) {
			  //因为要求是返回最大值，这里就直接找最大值了，让window中只保存最大值
			  while (!window.empty() && nums[right] > window.back())
                  window.pop_back();
			  //构造window
			  window.push_back(nums[right]);
			  //当窗口构造完成后，每移动一个元素，都要 memo
			  // k 是个数， right是下标，想要比较，就需要right+1
			  if (right + 1 >= k ) {  
				  //将window中 最大值 放进结果容器中
				  res[index++] = window.front();
				  //window左移，保持大小为3
				  if (window.front() == nums[right - k + 1])  window.pop_front();
			  }
			  
		  }
		  return res;
	  }
  };
```



```cpp
//用deque队列来写·思路同上题
 class Solution {
  public:
	  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		  deque<int> window;
		  int index = 0;
		  vector<int> ans(nums.size() - k + 1);
		  for (int right = 0; right < nums.size(); right++) {
			  while (!window.empty() && nums[right] > window.back())
                  window.pop_back();
			  window.push_back(nums[right]);
			  if (right + 1 >= k) {
				  ans[index++] = window.front();
				  if (nums[right - k + 1] == window.front())  window.pop_front();
			  }
		  }
		  return ans;
	  }
  };
```





### 4.15 定长子串中元音的最大数目

**题目：**给你字符串 s 和整数 k 。请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。

**思路：**窗口大小为K，可以仿照上题来写。

```cpp
  class Solution {
  public:
	  int maxVowels(string s, int k) {
		  int ans = 0;
		  int sum = 0;
		  for (int right = 0; right < s.size(); right++) {
              //如果碰到了元音字母，则计数器 自增
			  sum += helper(s[right]);
              //窗口变大时，要进行左移
			  if (right + 1 >= k) {
                  //结果阶段性的 memo
				  ans = max(sum, ans);
                  //把左侧的元素的结果删减掉，维持窗口
				  sum -= helper(s[right + 1 - k]);
			  }		  
		  }
		  return ans;
	  }
	  int helper(char c) {
		  return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ? 1 : 0;
	  }
  };
```

