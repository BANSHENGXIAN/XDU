# 3月份（43）

简单题（26）

###  3.16-两数之和

本算法就一般做法即可，没有什么太需要注意的点。

```cpp
  class Solution {
  public:
	  vector<int> twoSum(vector<int>& nums, int target) {
		  for (int i = 0; i < nums.size() - 1; i++) {
			  for (int j = i + 1; j < nums.size(); j++) {
				  if (target == nums[i] + nums[j])	 return { i,j };
			  }
		  }
		  return {};
	  }
  };
```





+++



### 3.17-括号（栈）

- 在C++中，计算字符串的长度可以使用`size()`这个函数。

```cpp
string s = "ABCDEF";
cout << s.size() << endl;
```

 

**题目：**给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s`，判断字符串是否有效。

**要求：**

1. 左括号必须用相同类型的右括号闭合

2. 左括号必须以正确的顺序闭合。

本题目使用栈容器来实现。

**思路：**

1. 栈——FILO（先进后出），所以可以把要比较的字符串存到栈中
2. 利用`unordered_map<char , char>` 哈希表来实现，即左括号做`key`值来匹配

**代码如下：**

```cpp
class Solution {
public :
	bool isValid(string s) {
		if (s.size() % 2 == 1)
			return false;
		
		//map 容器，只能 key 值允许遍历
		unordered_map<char, char> pairs = {
			{ '}','{'},
			{']','['},
			{')','('},

		};
		//在遍历s中，遇到右括号，就进行匹配，左括号，就入栈
		stack<char> stk;
		for (char ch : s) { //这里遍历的条件是  ch  只遍历 key 值
			if (pairs.count(ch)) {
				if (stk.empty() || stk.top() != pairs[ch]){
                    return false;
                }		
				stk.pop();
			} else {
				stk.push(ch);
			}
		}

		return stk.empty();

	}
};

```



> 总结： 本题目最关键的地方在于用==栈==容器解决，同时又用到了`unorder_map`。
>
> ​			   对于哈希表来讲，只有`key`值是允许操作的，所以在pairs中右括号为`key值`



---

### 3.20 整数取反

**题目：**给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

**要求：**如果反转后整数超过 32 位的有符号整数的范围 [−2^31^, 2^31^ − 1] ，就返回 0。

**思路：**将所给的数按位取余，然后反向输出。

**注意：**这里容易溢出。所谓溢出，例如：`4bit`的数最大为16，而16反向的话为61，这个数就超过了所允许的最大范围。

> 采用取余将数按位取出。

```c++ 
class Solution{
 public:
   int reverse(int x) {
		long n = 0;
		while (x!=0) {
			n = n * 10 + x % 10;
			x /= 10;
			
		}

		return (int)n == n ? (int)n : 0; //在看到三目运算符的时候，首先考虑== 为最后优先级
	}
		
}
```





+++



### 3.22  合并两个有序链表

**题目：**将两个升序链表合并为一个新的 **升序** 链表并返回。

**要求：**新链表是通过拼接给定的两个链表的所有节点组成的。

**思路：**首先弄清楚链表的结构，问题就解决一大半了

> **知识补充：**链表(具体查看Manuscript)
>
> ​	首指针 `Head`--> `l1` --> `l2`，当插入其他链表时候，有`s->next=p->next` 	`p->next=s`
>
>  	`p->next`表示的是p的下个指向，而`p=p->next`是改写p的内容

```c++
struct ListNode {
  int val;
  ListNode *next;
  ListNode() : val(0), next(nullptr) {}
  ListNode(int x) : val(x), next(nullptr) {}
  ListNode(int x, ListNode *next) : val(x), next(next) {}
};
 
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *Head= new ListNode(-1);
        ListNode *p=Head;

        while(l1!=nullptr&&l2!=nullptr){
            if(l1->val<l2->val){
                p->next=l1;//改指针指向
                 l1=l1->next;
            }else{
                p->next=l2;
                l2=l2->next;
            }
            p=p->next;//改写指针p
        }
        p->next= l1==nullptr?l2:l1;
        return Head->next;
    }
};
```



### 3.22 回文数

**题目：**给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

**要求：**回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，`121` 是回文，而 `123` 不是。

**思路：**负数都不是回文数，剩下的按位取反比较即可。

```cpp
class Solution {
public:
public:
	bool isPalindrome(int x) {
		long n = 0;
		int temp = x;
		if (x < 0) {
			return false;
		} else {
			while (x != 0) {
				n = x % 10  + n * 10;  // 这里总会存在溢出的问题，避免不掉。
				x /= 10;
			}
			return n == temp;
		}
		
	}
};
```



```cpp
//参考答案如下：计算下怎么找出反转的位置
int revertNumber = 0;
	if (x < 0 ||(x % 10 == 0 && x != 0))
			return false;

	while (x > revertNumber) {
		revertNumber = x % 10 + revertNumber * 10;
			x /= 10;
		}

		return x == revertNumber || x == revertNumber / 10;  //这里是把奇数位去掉
	}
```

 

### 3.22  最长公共前缀

**题目：**编写一个函数来查找字符串数组中的最长公共前缀。

**要求：**如果不存在公共前缀，返回空字符串 `""`。

**思路：** 写一个比较函数，用来比较该数组的第一个数据跟第二个数据相同的部分，并把这部分看作公共前缀由此来找出最长的公共前缀。

```cpp
class Solution {
public:
	string longestCommonPrefix(vector<string> &strs) {
		int count = strs.size();		
		if (!strs.size())
			return "";
		string prefix = strs[0];
		for (int i = 0; i < count; i++) {
			prefix = compare(prefix, strs[i]);
			if (!prefix.size())
				break;
		}
		return prefix;
	}

	string compare(const string &str1, const string &str2) {
		int index = 0;
		int length = min(str1.size(), str2.size());
		while (str1[index] == str2[index] && index < length)	
			index++;	//这条语句一定要判断完成后才能执行，
        				//如若放到判断条件中，会导致即使条件不成立也会+1 的操作
		return str1.substr(0, index);
	}
	
};

```



> 注意：`while(str1[index++]==str2[index++])`这条语句会导致，无论while中的判断条件是否成立，index都会做`+1`的操作，这与我们预期不符。我们期望的是，如果判断条件成立才选择+1。



### 3.22 删除有序数组中的重复项

**题目：**给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。

**要求：**不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

**说明:**

```cpp
/*为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:
*/

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}


```



**思路：**两两比较，如果前面的值跟后面的值不一样，就正常排序。具体看下面代码。

```cpp
class Solution {
public:
	int removeDuplicates(vector<int>& nums) {
		if (nums.size() < 2)
			return nums.size();
		int index = 0;
		for (int j = 1; j < nums.size(); j++) {
			if (nums[j] != nums[index]) {
				index++;
				nums[index] = nums[j]; 
			}		
		}
		return  i + 1;
	}
};
```



### 3.22 最大子序和

**题目：**给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**思路：**结果序列中肯定是正数数目大于其他子序列，且有最大的正数值。

```cpp
class Solution {
public:
	int maxSubArray(vector<int>& nums) {
		int sum = 0;
		int res = nums[0];
		//下面这个序列，当sum < 0 的时候，应该都舍弃掉，
    	//因为当sum = 0 的时候是临界值，这样也是下个正数值最大。
        //如果是负数，势必会造成sum减小
		for (int n : nums) {
			if (sum > 0)
				sum += n;
			else
				sum = n;
			res = max(res, sum);
		}
		return res;
	}
};
```

> 如果sum是个正数，那么它对于后面的序列是有正增益的；相反，如果是个`<0`的数，则会是负增益。



+++

 

### 3.23 爬楼梯

**题目：**假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 

**思路：**看评论中有人写的，这是一个斐波那契数列，即前面的两项的和等于下一项。

```cpp
class Solution {
public:
	int climbStairs(int n) {
		int j = 1;
		int k = 2;
		if (n <= 2)
			return n;
		for (int i = 3; i <= n; i++) {
			int temp = j + k;
			j = k;
			k = temp;
		}
		return k;
	}

};
```

​           



### 3.23 对称二叉树

**题目：**给定一个二叉树，检查它是否是镜像对称的**。**

**要求：**你可以运用递归和迭代两种方法解决这个问题吗。

**思路：**检查根节点是否为0，如若为0，则为对称的；如不为0，检查左子树的左节点跟右子树的右节点，左子树的右节点跟右子树的左节点是否相同即可。



```cpp
//递归做法
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
       return mirror(root,root);
    }

    bool mirror(TreeNode* p ,TreeNode *q){
        if(!q && !p )
            return true;
        if(!p ||!q)
            return false;
        if(p->val== q->val) //下边要重复利用这个判断语句才能实现递归的功能。
            return mirror(p->left,q->right)&&mirror(p->right,q->left);
        return false; //这步不可省略，因为当上面条件不满足的时候，编译器会报错。
    }
};
```



> 这里注意，不能利用非递归方法实现，因为要判断的是一个树，即很多元素，所以只能用递归，一次次判断才可以。



### 3.23 二叉树的最大深度

**题目：**给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。其中，叶子节点是指没有子节点的节点。

**思路：**看参考答案是利用了递归算法。

```cpp
//一直判断节点是否为叶子节点，直到最远的子结点为叶子结点即为判断完毕。
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        return max(maxDepth(root->left), maxDepth(root->right))+1;
    }
};
```



> 1. **递归:**程序调用自身的编程技巧称为递归,是函数自己调用自己.一个函数在其定义中直接或间接调用自身的一种方法,它通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决,可以极大的减少代码量.递归的能力在于用有限的语句来定义对象的无限集合。
>
> 2. **迭代:**利用变量的原值推算出变量的一个新值.如果递归是自己调用自己的话,迭代就是A不停的调用B。
>
> 3. 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换.能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出。



### 3.23 买卖股票的最佳时机

**题目：**给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

**要求：**返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**思路：**总的来说就是找==最值==得问题。首先比较下当前的值与上次值的大小，选出最小的值即可。

```cpp
class Solution{
public:
    int maxProfit(vector<int> &prices){
        if(prices.size() < 2)
            return 0;
        int profit = 0;
        int buy = prices[0];
        for(int i = 1; i < prices.size(); i++){
            profit = max(profit, prices[i] - buy);  //找最大值卖出，如若未负值，则为0。
            buy = min(buy, prices[i]); 				//以最小值买入
		}
        return profit;
	}
};
```



### 3.23 只出现一次的数字

**题目：**给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**要求：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**思路：**看参考答案知，本题目应该利用==异或运算==。

> 其中，==异或运算==有以下几点：
>
> 1. 交换律：`a⊕b⊕c <=> a⊕c⊕b`
> 2. 任何数于0异或为任何数 `0 ⊕ n = n`
> 3. 相同的数异或为0: `n ⊕ n = 0`

```cpp
class Solution {
public:
	int singleNumber(vector<int>& nums) {
		int single = 0;
		for (auto e : nums)
			single ^= e;
		return single;
	}
};

```



### 3.23 环形链表

**题目：**给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 -1，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。

**要求：**如果链表中存在环，则返回 true 。 否则，返回 false 。

**思路：**参考答案中说，本题目主要考察快慢链表。只要有个一直快两次的，那么他们终会相遇。

> 这是因为fast是走两步，slow是走一步，**「其实相对于slow来说，fast是一个节点一个节点的靠近slow的」**，所以fast一定可以和slow重合。

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) { 
        if(head == nullptr || head->next == nullptr)
            return false;

        ListNode *fast= head->next;
		ListNode *slow= head ;
         while(fast !=nullptr && fast->next != nullptr){
		    fast = fast->next->next;
		    slow = slow->next;
		    if (fast == slow)
			    return true;     
        }      
		return false;
    }
};
```



### 3.23 最小栈

**题目：**设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的。

```cpp
  /* push(x) —— 将元素 x 推入栈中。
   pop() —— 删除栈顶的元素。
   top() —— 获取栈顶元素。
   getMin() —— 检索栈中的最小元素。
   */
```



**思路：**参考答案写法。这里有一点，==如果用stack来确定最值问题，那么在入栈的时候最好就能判断出大小。==

```cpp
class MinStack {
 public:
	 /** initialize your data structure here. */
	 
	 MinStack() {
		 min_stk.push(INT_MAX);
	 }

	 void push(int val) {
		 x_stk.push(val);
		 min_stk.push(min(min_stk.top(), val));
	 }

	 void pop() {
		 x_stk.pop();
		 min_stk.pop();
	 }

	 int top() {
		 return x_stk.top();
	 }

	 int getMin() {		 
		 return min_stk.top();		
	 }

 public:
	 stack<int> x_stk;
	 stack<int> min_stk;
 };

```



### 3.23 相交链表

**题目：**编写一个程序，找到两个单链表相交的起始节点。

**思路：**我走过你走过的路，你走过我走过的路；如若最终相遇，那么我们必在之前就遇到过，且一并共赴终点。我们之前相遇的点为：你原本走过的路与我原本走过的路之和。

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA == nullptr || headB == nullptr)
            return nullptr;
         ListNode *pA = headA;
         ListNode *pB = headB;
         while(pA != pB){
             pA = pA == nullptr ? headB: pA-> next;
             pB = pB == nullptr ? headA: pB-> next;
         }
          return  pA;
    }
};

```



### 3.23  多数元素

**题目：**给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** ⌊ n/2 ⌋的元素。

**思路：**Boyer-Moore 投票算法。

> ==摩尔投票法：==
>
> 核心就是对拼消耗。
>
> 玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。
>
> 那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。
>
> 最后能剩下的必定是自己人。

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
		int count = 0;
		int candinate = -1;
		for (auto e : nums) {
			if (count == 0)
				candinate = e;
			count += (candinate == e) ? 1 : -1;
		}
 
		return candinate;
	}
};

```



### 3.23 反转一个单链表

**题目：**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**要求：**你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

**思路：**本质上就是将本次节点指针的指向改成指向前面节点。

```cpp
//迭代算法
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev =nullptr;
        ListNode *curr = head ;

        while(curr){
            ListNode *next = curr->next;
            curr->next =prev; // 更改指向
            prev = curr; //指针移动
            curr = next;
        }
        return prev ;
    }
};
```



```cpp
//递归算法
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};

```



> ==递归算法：==
>
> 1. 首先满足一个大问题能分解为若干个子问题；
> 2. 子问题的解决方案同大问题；
> 3. 存在最小子问题。



+++



### 3.24 翻转二叉树

**思路：**用递归的方法实现。

**递归：**

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) {
            return root;
        }
        TreeNode *leftTree = invertTree(root->left);
        TreeNode *rightTree = invertTree(root->right);
        root->left = rightTree;
        root->right = leftTree;
        return root;
    }
};
```



>  ==递归方法总结：==
>
> 1. 首先找到最小的问题的变量，即“递”下来；
> 2. 找到最小问题的解决方法，即“归”上去；



### 3.24 回文链表

**题目：**请判断一个链表是否为回文链表。

**思路：**查看参考答案，将链表中的值复制到数组中，然后使用双指针的办法来判断。

```cpp
class Solution {
public:
	bool isPalindrome(ListNode* head) {
		vector<int> v;

		while (head != nullptr) {
			v.emplace_back(head->val);
			head = head->next;
		}

		for (int i = 0, j = v.size() - 1; i < j; i++, j--) {
			if (v[i] != v[j])
				return false;
		}
		return true;
	}
};
```





### 3.24 移动零

```cpp
class Solution {
public:
	void moveZeroes(vector<int>& nums) {
		int length = nums.size();
		int index = 0;
		for (int i = 0; i < length; i++) {
			if (nums[i] != 0)
				nums[index++] = nums[i];
		}
		for (int i = index; i < length; i++) {
			nums[i] = 0;
		}

	}
};
```



### 3.24 找到所有数组中消失的数字

**题目：**给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次，找到所有在 [1, n] 范围之间没有出现在数组中的数字。

**要求：**您能在不使用额外空间且时间复杂度为*O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

**思路：**（盗来的——评论）将所有正数作为数组下标，置对应数组值为负值。那么，仍为正数的位置即为（未出现过）消失的数字。举个例子：

- 原始数组：[4,3,2,7,8,2,3,1]
- 重置后为：[-4,-3,-2,-7,`8`,`2`,-3,-1]

结论：[8,2] 分别对应的index为[5,6]（消失的数字）

```cpp
class Solution {
public:
	vector<int> findDisappearedNumbers(vector<int>& nums) {
		//将原数组中的值置为数组下标 , 且将其取反
		for (int i = 0; i < nums.size(); ++i)
			nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);
		vector<int> res;
		for (int i = 0; i < nums.size(); ++i) {
			if (nums[i] > 0)
				res.push_back(i + 1);
		}
		return res;
	}
};
```



### 3.24 汉明距离

**题目：**两个整数之间的[汉明距离](https://baike.baidu.com/item/汉明距离)指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。

**思路：**转换成二进制，做异或运算，并且计数。==评论中给出的更加高效的方法：==将两个数做或运算，然后将得到的数 与该结果减一 做与运算，并且计数。

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        int z = x ^ y;
        int count = 0;
        while( z != 0){
            z &= z-1;
            count++;
        }
        return count;
    }
};

```



### 3.24 二叉树的直径

**题目：**给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**思路：**利用递归算法。

```cpp
class Solution {
public:
    int maxLength = 0; // 这个是类中的全局变量
    int diameterOfBinaryTree(TreeNode* root) {
        
        if (!root)
            return 0;
        dfs(root);
        return maxLength;
    }
    int  dfs(TreeNode *root){
        if(root->left == nullptr && root->right == nullptr )
            return 0;
        int leftTree = root->left == nullptr ? 0:dfs(root->left) + 1;
        int rightTree = root->right ==nullptr? 0:dfs(root->right)+ 1;
        maxLength = max(maxLength, leftTree + rightTree);
        return max(leftTree , rightTree);
    }
};
```



+++





---

+++

***

------



中等题（17）

### 3.25 两数相加

**题目：**给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。

**要求：**你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**思路：**我的思路是将链表逐个翻转后再逐位取出相加，将得到和在按位放到新链表中。但这样的代码又臭又长。参考答案中给的方法：

直接将两个链表中的数相加，并且记录进位，进位只可能是1。这样将得到的结果在按位放置到新链表中，要简洁很多。

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = nullptr;
		ListNode *tail = nullptr;
		int carry = 0; // 记录进位
		while (l1 || l2) {
			int n = l1 ?  l1->val : 0;
			int m = l2 ?  l2->val : 0;
			int sum = m + n + carry;
			
			if (!head) {
				head = tail = new ListNode(sum % 10);
			} else {
				tail->next = new ListNode(sum % 10);
				tail = tail->next;
			}
			carry = sum / 10;

			if (l1)
				l1 = l1->next;
			if (l2)
				l2 = l2->next;

		}
		if (carry > 0)
			tail->next = new ListNode(carry);
        return head;
    }
};
```



### 3.25 无重复的最长字符串

**题目：**给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。可以查看滚动数组的总结。

**思路：**顶礼膜拜大佬的代码。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //定义两个游标,还有长度,与结果,均初始化为0
        int start(0),end(0),length(0),result(0);
        //只要end<字符串大小
        while(end<s.size())
        {
            //该注释错误		//暂存首个字符char,
            //其实应该是暂存end所指向的那个值,到时候会跟index所指向的值比较
            char tempChar=s[end];
            //定义index,它只用于改变start的指向一般为index+1
            //因为index所处的与end的值相等,则没有统计的必要了
            //for循环只用来判断是否相等
            //
            for(int index=start;index<end;index++)
            {
                //判断是否出现重复字符串
                if(tempChar==s[index])
                {
                    //start++;//这是错误的哦,没有优化呢
                    //如果出现,则将start跳过重复字符index指向的下一字符
                    start = index + 1;
                    //保存长度
                    length=end-start;
                    /////////
                    //千万注意,如果相等,则该判断应该结束了
                    break;
                }
            }
            //此时,end向后移动,每一一次,长度+1
            end++;
            length++;
            //返回更新后的length,如果更大,则为它
            result=max(result,length);
        }
        return result;
    }
};
```







### 3.25  最长回文子串

**题目：**给你一个字符串 `s`，找到 `s` 中最长的回文子串。

 **思路：**利用暴力求解法，时空间复杂度都为O（n^2^)。本质上是两个指针，一个从头开始向后遍历，一个从尾向前遍历，然后判断他们是否相等。转态转移方程如下：
$$
P(i,j)=P(i+1,j−1)∧(Si==Sj)
$$


```cpp
//这是暴力解法，不好用，也没理解透
class Solution {
public:
	string longestPalindrome(string s) {
		int n = s.size();
		vector<vector<int>> dp(n, vector<int>(n));
		string ans;
		for (int l = 0; l < n; ++l) {
			for (int i = 0; i + l < n; ++i) {
				int j = i + l;
				if (l == 0) {
					dp[i][j] = 1;
				} else if (l == 1) {
					dp[i][j] = (s[i] == s[j]);
				} else {
					dp[i][j] = (s[i] == s[j] && dp[i + 1][j - 1]);
				}
				if (dp[i][j] && l + 1 > ans.size()) {
					ans = s.substr(i, l + 1);
				}
			}
		}
		return ans;
	}
};
```





+++



### 3.26  Z字型变换

**题目：**将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

**思路：**有锤子思路，查看参考答案作者的思路吧！

本质上到达边界位置就转向，题目介绍的花里胡哨的。具体方法如下：

<img src="刷题日记.assets/Z字形方法.png" alt="排列方式" style="zoom:100%;" />



```cpp
class Solution
{
public:
    string convert(string s, int numRows)
    {
        if (numRows == 1)
        {
            return s;
        }
        int sSize = int(s.size());
        int storeSize = min(sSize, numRows);
        string result;
        vector<string> store(storeSize);
        int loc = 0;
        //初始有一次更改change值，因此初始值为false
        bool change = false;
        for (int index = 0; index < sSize; index++)
        {
            store[loc].push_back(s[index]);
            if (loc == numRows - 1 || loc == 0)
            {
                change = !change;
            }
            loc += change ? 1 : -1;
        }

        for (int index = 0; index < storeSize; index++)
        {
            result = result + store[index];
        }
        return result;
    }
};

作者：pinku-2
链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-cshi-xian-liang-chong-jie-fa-m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```cpp
//更简洁的做法，原理与上面解法类似
class Solution {
public:
	string convert(string s, int numRows) {
		if (numRows == 1)
            return s;
        //创建一个大小为numRows的string容器，注意这里不能用str数组，会报错。
        //用str容器来记录每行的内容
		vector<string> str(numRows);
        //dir 记录到达边界后的转向，表现为+1 或-1。
		int n = 0, dir = 1;
		for (int i = 0; i < s.size(); ++i) {
			if (n == numRows - 1)
                dir = -1;
			if (n == 0)
                dir = 1;
            //这里 n 就是代表了第 n 行
			str[n] += s[i];
			n += dir;
		}
		for (int i = 1; i < numRows; ++i) {
			str[0] += str[i];
		}
		return str[0];
	}
};
```



### 3.26 字符串转换正数

**题目：**请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

函数 `myAtoi(string s)` 的算法如下：

- 读入字符串并丢弃无用的前导空格
- 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
- 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
- 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
- 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
  返回整数作为最终结果。

**注意：**

- 本题中的空白字符只包括空格字符 ' ' 。

- 除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。

**思路：**题目写的花里胡哨的，其实就是读出字符串的数字。



```cpp
class Solution {
public:
	int myAtoi(string s) {
		int length = s.size();
		int idx = 0;
        //去掉空格
		while (idx < length && s[idx] == ' ') {
			idx++;
		}
		if (idx == length)
			return 0;
		bool negative = false;
		if (s[idx] == '-') {
			negative = true;
			idx++;
		} else if (s[idx] == '+') {
			idx++;
			negative = false;
            //如果未遇到正负号，且未遇到数字符号，那么返回值为0
		} else if (s[idx] != '+' && s[idx] != '-' && (s[idx] < '0' || s[idx] > '9'))
			return 0;
		int ans = 0;
		while (idx < length &&s[idx] >= '0' && s[idx] <= '9' ) {
			int digit = s[idx] - '0';
            //下面是防止越界的处理·值得记录借鉴
			if (ans > (INT_MAX- digit) / 10) {
				// 本来应该是 ans * 10 + digit > Integer.MAX_VALUE
				// 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。
				return negative ? INT_MIN : INT_MAX;
			}
			ans = ans * 10 + digit;
			idx++;
		}
		return negative? -ans:ans;
	}

};
```



### 3.26 盛最多水的容器

**题目：**给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

**思路：**有屁的思路。参考答案中写道，本题目是经典的面试题，采用双指针的办法。

```cpp
class Solution {
public:
	int maxArea(vector<int>& height) {
        //定义水桶的长、高
		int l ( 0), r ( height.size() - 1);
		int ans = 0;
        //这里不适合用 for 循环
		while (l < r) {
            //找出高度比较小的
			int area = min(height[l], height[r]) * (r - l);
			//结果取最大值
            ans = max(ans, area);
            //高度小的移动
			if (height[l] <= height[r]) {
				l++;
			} else {
				r--;
			}
		}
		return ans;
	}
};
```



++++



### 3.27 整数转罗马数字

**思路：**我想到的是枚举。评论中有大佬写的答案，将罗马符号跟对应的数字都封成数组，这样来选取罗马数字。

**贪心算法：**

```cpp
class Solution {
public:
	string intToRoman(int num) {
		int value[] = { 1000, 900,500,400,100,90,50,40,10,9,5,4,1 };
		string reps[] = { "M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I" };
		string res;
		for (int i = 0; i < 13; i++) {
			//这里必须使用while循环，因为如果使用if语句，中间数值每种可能的情况就只能运行一次就结束了。
			while (num >= value[i]) {
                //将数字按照已有的取情况分类
				num -= value[i];
                //拼接字符串
				res += reps[i];
			}
		}
		return res;
	}
};
```



### 3.27 三数之和

**题目：**给你一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

**要求：**答案中不可以包含重复的三元组。

**思路：**我想到是暴力穷举法。看参考答案中写道，使用双指针＋排序会使复杂度下降个数量级。本质上先对其进行排序，这样避免了判断是否有重复的元素相加；然后就是对于求和的运算了，如果和偏大，那么右指针左移；如果和偏小，左指针右移。



```cpp
class Solution {
public:
	vector<vector<int>> threeSum(vector<int>& nums) {
		int length = nums.size();
		vector<vector<int>> ans;
		sort(nums.begin(), nums.end());  //排序
		//i 为首指针，j为尾指针，k为中间指针
		//固定一个指针，剩下的两个分别取值求和
		for (int i = 0; i < length; i++) {
			//枚举的数要跟上一次的不同，注意是上一次，不是下一次。
			if (i > 0 && nums[i] == nums[i - 1])  
				continue;
			int j = length - 1;
			int tar = -nums[i]; //这个作用是充当第一个数固定后的条件
			//中间指针在第一个指针确定的前提下进行遍历。
			for (int k = i + 1; k < length; k++) {
				if (k > i + 1 && nums[k] == nums[k - 1])
					continue;
				//如果两者的和大了，那么尾指针左移；如果小了，那么继续循环。
				while (k < j && nums[j] + nums[k] >tar)
					j--;
				if (j == k)
					break;
				//最后统计结果
				if (nums[j] + nums[k] == tar)
					ans.push_back({ nums[i],nums[j],nums[k] });
			}			
		}
		return ans;
	}
};
```



> 不管是几个数求和，都要转换成两个数求和，依次迭代。以本体为题，三个数求和，首先要做的事固定第一个数，让后面的的两个数遍历取值，求出他俩的和与第一个数比较。当后两个数都已经遍历完成，那么继续进行第一个数的遍历，依次进行，求出结果。



### 3.27 最接近的三数之和

**题目：**给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

**思路：**本来想着用上题的办法，可是一个半小时没写出来。真是：有的人在打游戏，有的人在约会，而有的人在看着似曾相识的题目一个半小时没有做出来。。。。。

看参考答案，很简单的遍历求结果。→__→

==这个代码的逻辑性比上个题目的逻辑要清晰些~==

```cpp
class Solution {
public:
	int threeSumClosest(vector<int>& nums, int target) {
		int length =nums.size() ;
		sort(nums.begin(), nums.end());
		int ans = nums[0] + nums[1] + nums[2];
		for (int i = 0; i < length; i++) {
			int k = i + 1;
			int j = length - 1;
			while (k < j) {
				int sum = nums[i] + nums[j] + nums[k];
                //如果初始的和的绝对值小于计算后和的绝对值，那么更新ans
				if (abs(sum - target) < abs(ans - target))
					ans = sum;
				if (sum > target)
					j--;
				if (sum < target)
					k++;
				if (sum == target)
					return target;
			}
		}
		return ans;
	}
};
```



### 3.27  罗马数字转整数

**思路：**用hash_map来映射符号和值。然后通过replace函数的使用将复杂的数都替换掉，最后读出数。

```cpp
class Solution {
public:
	int romanToInt(string s) {
        //将要求的变量用hash_map封存
		unordered_map <char, int> mp = {
			{'I',1}, {'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000},{'a',4},              {'b',9},{'c',40},{'d',90},{'e',400},{'f',900}
		};
		//要替换的字符串跟替换后的字符，转化成我们想要的格式
		string str[] = {"IV","IX","XL","XC","CD","CM"};
		string tar[] = { "a","b","c","d","e","f" };

		//替换字符
		for (int i = 0; i < sizeof(str) / sizeof(str[0]); i++) {
            int pos = -1;
			pos = s.find(str[i]);
			if (pos != -1)
				s = s.replace(pos, 2, tar[i]);
		}
		//将给的数转换成我们需要的格式后，计算结果	
		int res = 0;
		for (int i = 0; i < s.size(); i++) {
			res += mp[s[i]];
		}
		return res;
	}
};
```



> replace函数： `s=s.replace(s.find("tar"),num,"newTar");`
>
> string数组的大小：`sizeof(str)/sizeof(str[0]);`
>
> 普通string的大小：`s.size();`



### 3.27 电话号码的字母组合

**题目：**给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

**思路：**思路个屁~这题目就压根不是我能想出来的！这题目也不是当下的我可以看懂解决的。。。

```cpp
class Solution {
public:
	unordered_map<char, string> phoneMap = {
	{'0', " "}, {'1',"*"}, {'2',"abc"},{'3',"def"},{'4',"ghi"},{'5',"jkl"},{'6',"mno"},		{'7',"pqrs"},{'8',"tuv"},{'9',"wxyz"},
	};
	vector<string> res; //存放输出字符串的容器
	string cur;  //存放所有可能的组合

	vector<string> letterCombinations(string digits) {
	
		//如果给的是空串，则返回空vector
		if (digits.empty())
			return res;
		func( digits);
		return res;
	}
	
	void func(string digits) {
		//递归结束的条件一般前置
		//但是最后写这个判断语句，先写执行语句
		if (!digits.size())
			res.push_back(cur);
		else {
			char num = digits[0];
			string letter = phoneMap[num];
			for (auto e : letter) {
                //此时遍历外层第一个数据，cur 外层只取了一个值，例如：a
                //向下遍历的时候，递归
                //内层全部，a + d , a + e, a + f; 依次进行
				cur.push_back(e);
				func(digits.substr(1)); //substr(1) 表示从下标 1 位置开始截取到末尾
				cur.pop_back(); // c++ 的string 类型字符串总是以'\0'作为串的结束符。
			}
		}
	}

};
```



> 递归算法的思路：首先是写执行语句，然后在写判断语句，并把判断语句前置。
>
> 这里的递归，跟`3. 26 Z字型变换`类似，都是用第一层当做初始值，后面遍历完，进行第二层……

+++



### 3.28 四数之和

**题目：**给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

**要求：**答案中不可以包含重复的四元组。

**思路：**参考三数之和来写。

```cpp
//用while循环写的函数，其中要注意的点都加了注释。
class Solution {
public:
	vector<vector<int>> fourSum(vector<int>& nums, int target) {
		int  length = nums.size();
		vector<vector<int>> ans;
		sort(nums.begin(), nums.end());
        //如果长度小于4 ，那么就直接返回 空容器。
		if (length < 4) 
            return ans;
        
		for (int i = 0; i < length - 3; i++) {
            //同三数之和一样，如果下个值跟本次相同，那么跳过，减少无谓的运算。
			if (i > 0 && nums[i] == nums[i - 1]) {				
				continue;
			}
            
			int j = i + 1;		
			while (j < length - 2) {				
				if (j > i + 1 && nums[j] == nums[j - 1]) {
					j++;
					continue;
				}
                //这里是需要两个移动的指针，前指针小于后指针即可。
                //last 定义到上面循环外面，会导致last的值在下面循环不能重新赋值；
                //会少解。
				int k = j + 1;
				int last = length - 1;
				while (k < last ) {
					if (k > j + 1 && nums[k] == nums[k - 1]) {
						k++;
						continue;
					}						
					int sum = nums[i] + nums[j] + nums[k] + nums[last];
					if (sum > target)
						last--;
					if (sum < target)
						k++;
                    //如果得出了想要的值，不能写 return ；
                    //因为本题是可以出现多个解，且给的数据是允许重复的。
                    //也不能写 break；
                    //那样一旦有合适的结果就退出了，导致少解。
					if (sum == target) {
						ans.push_back({ nums[i],nums[j],nums[k],nums[last] });
						k++;
					}
				}

				j++;
			}
		}		
		return ans;
	}
};
```



```cpp
//for 循环实现
class Solution {
public:
	vector<vector<int>> fourSum(vector<int>& nums, int target) {
		int length = nums.size();
		vector<vector<int>> ans;
		if (length < 4)
			return ans;
		sort(nums.begin(), nums.end());
		for (int i = 0; i < length - 3; i++) {
			if (i > 0 && nums[i] == nums[i - 1])
				continue;
			for (int j = i + 1; j < length - 2; j++) {
				if (j > i + 1 && nums[j] == nums[j - 1])
					continue;
				int last = length - 1;
				for (int k = j + 1; k < last; k++) {
					if (k > j + 1 && nums[k] == nums[k - 1])
						continue;
				
					int sum = nums[i] + nums[j] + nums[k] + nums[last];
					while ( sum > target) {
						last--;
                        //这里需要注意的一点：
                        //last --运算，会导致last == k 的情况出现；
                        //这样就有值取了两次。
						if (k == last)
							break;
						sum = nums[i] + nums[j] + nums[k] + nums[last];
					}
											
					if (sum == target) {
						ans.push_back({ nums[i],nums[j],nums[k],nums[last] });
					}
					
				}
			}
		}		
		return ans;
	}
};
```



> 这两个方法写完比较来看，`for`循环结构更加清晰些，代码实现起来逻辑简单；`while`循环可读性会高点，但是写起来的坑比较多，经常会忘运算符的自增运算，且代码实现的逻辑没那么清晰。



### 3.28 删除链表的倒数第n个节点

**题目：**给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```cpp
//计算链表长度。
class Solution {
public:
	ListNode* removeNthFromEnd(ListNode* head, int n) {
		ListNode* dummy = new ListNode(0, head);
		ListNode* curr = dummy;
		int count = 0;
		while (head){
            count++;
            head = head->next;
        }			
         //这里是倒数的 n  ，不是正数的个数
		for (int i = 1; i < count-n + 1; i++) {
			curr= curr->next;
		}
		curr->next = curr->next->next;
		ListNode *ans = dummy ->next;
		delete dummy;
		return ans;
	}
};

```



```cpp
//双指针· 这个方法要好的多，效率高得多
class Solution {
public:
	ListNode* removeNthFromEnd(ListNode* head, int n) {
		ListNode *dummy = new ListNode(0, head);
		ListNode *fast = head;
		ListNode *slow = dummy;

		//倒数第 n 个，也就是从该位置到末尾的距离为 n
		for (int i = 0; i < n; i++) {
			fast = fast->next;
		}
		while (fast !=nullptr) {
			fast = fast->next;
			slow = slow->next;
		}
		slow->next = slow->next->next;
		ListNode *ans = dummy->next;
		delete dummy;
		return ans;

	}
};
```



+++



### 3.29 括号生成

**题目：**数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

```cpp
//有关于迭代·算法的实现
class Solution {
public:
	vector<string> ans;

	vector<string> generateParenthesis(int n) {
		dfs(n, n, "");
		return ans;
	}
	void dfs(int left, int right, string curr) {
		//递归结束的条件
		//如果左括号或者右括号为 0 的话，那么就把当前的字符加入到结果中
		if (left == 0 && right == 0) {
			ans.push_back(curr);
			return;
		}
		//先写左括号，左括号完毕后在写右括号
		//左括号依次减一，然后用字符串拼接起来即可
		if (left > 0)
			dfs(left - 1, right, curr + "(");
		//进行迭代的时候，右括号是找左括号进行匹配
		if (right > left)
			dfs(left, right - 1, curr + ")");
	}
};
```





### 3.29 两两交换列表中的节点

**题目：**给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```cpp
//递归·算法
class Solution {
public:
	ListNode* swapPairs(ListNode* head) {
		if (head == nullptr || head->next == nullptr)
			return head;
		//原链表的第二个节点记为newHead
		ListNode *newhead = head->next;
		//Head 的指向为 newHead 的指向；
		head->next = swapPairs(newhead->next);
		//新链表的 newHead 的指向为Head；
		//这样完成了两两交换。
		newhead->next = head;
		return newhead;
	}
};
```



```cpp
//迭代·算法 ，该算法效率比较高效
class Solution {
public:
	ListNode* swapPairs(ListNode* head) {
		ListNode *dummy = new ListNode(0, head);
		ListNode *curr = dummy; //新建一个哑结点

		while (curr->next !=nullptr && curr->next ->next !=nullptr) {
			ListNode *node1 = curr->next;
			ListNode *node2 = curr->next->next;
			//哑节点的指向变成 原链表的第二个节点；
			//新链表的第二个节点的指向 原链表的第一个节点；
			//交换完毕。
			curr->next = node2;
			node1->next = node2->next;
			node2->next = node1;
			//节点移动到下一对 数据
			curr = node1;
		}
        return dummy->next;
	}
};

```





+++



### 3.30 下一个排列

**题目：**实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

**题意：**（盗来的）

题干的意思是：找出这个数组排序出的所有数中，刚好比当前数大的那个数；

比如当前 nums = [1,2,3]。这个数是123，找出1，2，3这3个数字排序可能的所有数，排序后，比123大的那个数 也就是132；

如果当前 nums = [3,2,1]。这就是1，2，3所有排序中最大的那个数，那么就返回1，2，3排序后所有数中最小的那个，也就是1，2，3 -> [1,2,3]。

```cpp
//此题是利用逆向查找，因为要找到比当前数列大的最小值
//首先找到一个升序的位置
//然后将升序的那个元素与大于他的最小元素交换位置
//最后将升序位置开始，依次升序排列
class Solution {
public:
	void nextPermutation(vector<int>& nums) {
		//倒序查找
		int i = nums.size() - 2;
		//找到升序的位置
		while (i >= 0 && nums[i] >= nums[i + 1])
			i--;
		if (i >= 0) {
			//继续倒序查找
			int j = nums.size() - 1;
			while (j >= 0 && nums[i] >= nums[j])
				j--;
			swap(nums[i], nums[j]);
		}
		reverse(nums.begin() + i + 1, nums.end());
	}
};
```



### 3.30  移除元素

**题目：**给你一个数组 `nums` 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

==本质上是双指针。==

```cpp
class Solution {
public:
	int removeElement(vector<int>& nums, int val) {
		if (nums.size() == 0 ||nums.empty())
			return 0;
		int j =0;
        //类似于上面某个题，都是定义一个新的变量，用来新数组的下标
		for (int i = 0; i < nums.size(); i++) {
			if nums[i] != val){
                nums[j]=nums[i];
                 j++;
            }
				
		}
		return j;
	}
};
```



### 3.30 搜索旋转排序数组

**题目：**整数数组 nums 按升序排列，数组中的值 互不相同 。数组本身不是有序的，进行旋转后只保证了数组的局部是有序的；

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。

```cpp
//二分法·求范围
//二分法本质也是通过确定头、尾不动
//然后通过mid值不断移动来计算结果
class Solution {
public:
	int search(vector<int>& nums, int target) {
		int length = nums.size();
		if (!length)
			return -1;
		if (length == 1) 
			return nums[0] == target ? 0 : -1;
		//定义两个下标，分别指向头尾
		//在利用中间值的大小，细分区间位置
		int prev(0), end(length - 1);
		while (prev <= end) {
			int mid = (prev + end) / 2;
			if (nums[mid] == target)
				return mid;
			//判断前半段是否有序
            //这里是判断的原数组中 第一个元素跟 中间元素的大小
            //如果是有序数组，这步是不需要的
			if (nums[0] <= nums[mid]) {
				//虽然有两个 left、right 下标值，但其实并不真正参与区间变换
                //而是通过这两个值，找出 mid；通过mid最后判断结果
                //利用有序段，判断 target 靠近左边还是右边
				if (nums[0] <= target && target < nums[mid])
					end = mid - 1;
				else
					prev = mid + 1;
			}
			//如果前半段无序，那么后半段有序
            //else 也可以改成下面这条语句
            // if(nums[0] > nums[mid] && nums[mid] <= nums[length -1])
			else {
                //利用有序段，判断 target 靠近左边还是右边
				if (nums[mid] < target  && target <= nums[length - 1])
					prev = mid + 1;
				else
					end = mid - 1;
			}	
			
		}
        return -1;
	}
};
```



### 3.30 在排序数组中查找元素的第一个和最后一个位置

**题目：**给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

```cpp
//二分法·找左边界跟有边界
//核心就是利用 左标跟右标 来 求 mid ，根据 mid 来找值
//经过多次尝试，发现原题解的方法还是最简洁的
class Solution {
public:
	vector<int> searchRange(vector<int>& nums, int target) {
		//将ans 容器初始化为 2 个 -1 的值
		vector<int> ans(2, -1);
		int length = nums.size();
		if (!length)
			return ans;
		int left = 0;
		int right = length - 1;
		//找左边界，即找第一次出现的值
		while (left < right) {
			int mid = (left + right) >> 1;
			if (target <= nums[mid])
				right = mid;
			else
				left = mid + 1;
		}
		/*没找到 target*/
		if (nums[left] != target)
			return ans;

		ans[0] = left;
		//当target只出现一次的时候，需要两次读到这个值
		//right = length 就是为了确保从右侧逼近的时候取到这个值
		//如果 right = length -1， 那么 mid = left + right >> 1
		//实际上的 mid = left + 1 了，
		//而需要的是 mid = left 开始
		right = length;
		while (left < right) {
			int mid = left + right >> 1;
			if (nums[mid] <= target)
				left = mid + 1;
			else
				right = mid;
		}
		ans[1] = left - 1;
		return ans;
	}
};
```



- 31号暂停一天，复习以前的题目，做下老师的任务

+++

---

***



# 4月份

## 4.1  搜索插入位置

**题目：**给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

```cpp
//普通做法
class Solution {
public:
	int searchInsert(vector<int>& nums, int target) {
		if (nums.empty())
			return -1;

		int index = 0;
        //遍历所有值
        //当前值小于后面的值的时候，继续遍历
        //当前值大于或者等于后面值得时候，返回该值即可
		while (index < nums.size()) {
			if (nums[index] < target)
				index++;
			else if (nums[index] >= target)
				return index;
			
		}
		return nums.size();
	}
};
```



```cpp
//二分法·算法
class Solution {
public:
	int searchInsert(vector<int>& nums, int target) {
		if (nums.empty())
			return -1;
		int length = nums.size();
		int left = 0;
		int right = length - 1;
		//一般的二分查找算法，都要 left <= right
        //只剩下两个数的时候，如果不取等号，那么无法实现 mid 取到所有值
		while (left <= right) {
			int mid = left + right >> 1;
            //原理不变
			if (nums[mid] >= target) {
				length = mid;
				right = mid - 1;
		}
			if (nums[mid] < target)
				left = mid + 1;
		}
		return length;
	}
};
```



> 二分法·算法
>
> - `while(left <=  right)`如果取了`“=”`，那么后面`right = mid-1`；如果没取，那么后面是`right = mid`
> - 本质上都是用mid来遍历所有值，所以要看情况用哪种方式最好

## 4.1 有效的数独

**题目：**判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

- 数字 1-9 在每一行只能出现一次。
- 数字 1-9 在每一列只能出现一次。
- 数字 1-9 在每一个以粗实线分隔的 3 x 3 宫内只能出现一次。

**思路：**具体查看该[大佬](https://leetcode-cn.com/problems/valid-sudoku/solution/36-jiu-an-zhao-cong-zuo-wang-you-cong-shang-wang-x/)的思路。

```cpp
class Solution {
public:
	bool isValidSudoku(vector<vector<char>>& board) {
		//左边是标号，右边是数字
        //记录每行、每列、每个block 数字出现的次数
		bool row[9][9] = { 0 };
		bool columns[9][9] = { 0 };
		bool block[9][9] = { 0 };

		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				if (board[i][j] == '.')
					continue;
				//当前数字是多少
                 //将字符型转换为整数型进行比较 
                 //我们想获得字符型 ——> 数字的转变，只需要将该字符减去 ‘0’ 或者 ‘1’
				int currNum = board[i][j] - '1';
				if (row[i][currNum])
					return false;
				if (columns[j][currNum])
					return false;
				if (block[j / 3 + i / 3 * 3][currNum])
					return false;
				//之前未出现过，则置为 1
				row[i][currNum] = 1;
				columns[j][currNum] = 1;
				block[j / 3 + i / 3 * 3][currNum] = 1;
			}
		}
		return true;
	}
};
```



> 由字符型转换成数字：只需要将 0 - 9 的 字符 直接减去 ‘0’ 或者 ‘1’。
>
> ‘9’ = 57， ‘0’=48；‘a' = 97 , 'A' =65。 



## 4.1 解数独

**题目：**编写一个程序，通过填充空格来解决数独问题。

**思路：**查看[大佬](https://leetcode-cn.com/problems/sudoku-solver/solution/hui-su-fa-jie-shu-du-by-i_use_python/307397)的思路，很棒。

```cpp
class Solution {
public:
	void solveSudoku(vector<vector<char>> &board) {
		backtrack(board, 0, 0);
	}
	//row,columns∈[0,8]
	bool backtrack(vector<vector<char>> &board, int row, int columns) {
        //列数 越界，则换行
		if (columns == 9)
			return backtrack(board, row + 1, 0);
         //行数 越界，则完成目标
		if (row == 9)
			return true;
         //遍历所有位置
		for (int i = row; i < 9; i++) {
			for (int j = columns; j < 9; j++) {
				//没有要填的空位，则看向下一列
				if (board[i][j] != '.')
					return backtrack(board, i, j + 1);
				for (char ch = '1'; ch <= '9'; ch++) {
					if (!isValid(board, i, j , ch)) 
						continue;
					//尝试填入未使用的数字，看向下一列
					board[i][j] = ch;
					if (backtrack(board, i, j + 1))
						return true;
					board[i][j] = '.';
				}
				return false;
			}
			
		}
		return false;
	}

	bool isValid(vector<vector<char>> &board, int row, int columns, char ch) {
		//这里的 i  代表了 字符数字
		for (int i = 0; i < 9; i++) {
			if (board[row][i] == ch)
				return false;
			if (board[i][columns] == ch)
				return false;
			//数学公式判断 block 中的哪个部分
			if (board[row / 3 * 3 + i / 3][columns/ 3 * 3 + i % 3] == ch)
				return false;
		}
		return true;
	}
};
```



## 4.1 外观数列

**题目：**给定一个正整数 n ，输出外观数列的第 n 项。外观数列 是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

**思路：**[大佬](https://blog.csdn.net/zhanshen112/article/details/84780458)的代码没有注释，只能自己悟。不过这么优美的代码，值得细品（我啥时候才能写得出）。

```cpp
class Solution {
public:
	string countAndSay(int n) {
			string s = "1";
			int j = 0;
			for (int cnt = 1; cnt < n; cnt++) {
				string t;
				for (int i = 0; i < s.length(); i = j) {
                      //求出 相邻的数不同时候的下标
					for (j = i; j < s.length() && s[j] == s[i]; j++);
					t +=  to_string(j - i) + s[i];
				}
				s = t;
			}
		
			return s;
	}
};


/*------------------根据自己理解写了个方便阅读的循环----------------------*/
			//该代码跟上面的原理相同
			for (int idx = 1; idx < n; idx++) {
				string t;
				for(int i = 0;  i < s.length(); ) {
					for (j = i; j < s.length(); j++) {
						if (s[j] != s[i]) 						
							break;
					}
					t += to_string(j - i) + s[i];
					i = j;
				}
				s = t;
			}
```



> 根据这几次用循环来看，for循环要比while循环好用点，以后首先考虑for循环，其次while循环。
>
> while循环的时候，要考虑赋初值的事情，每次循环开始的值要不要重新置0。

+++



## 4.2 组合总和

**题目：**给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。

**思路：**回溯法。

```cpp
class Solution {
public:
	vector<vector<int>> ans;
	vector<int> combine;

	vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
		
		dfs(candidates, target, 0);
		return ans;
	}

	void dfs(vector<int> &candidates, int target, int idx) {
		if (idx == candidates.size())
			return;
		if (target == 0) {
			ans.emplace_back(combine);
			return;
		}
		dfs(candidates, target, idx + 1);
		if (target - candidates[idx] >= 0) {
			combine.emplace_back(candidates[idx]);
			dfs(candidates, target - candidates[idx], idx);
			combine.pop_back();
		}
	}
};

```



## 4.2 缺失的第一个正数

**题目：**给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

**要求：**你可以实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案吗？

**思路：**排序，然后找到第一个正数。该正数是最小的，则往后遍历。

- 利用哈希表的算法思想，跟之前的有个题目类似，将本数组的中元素当做新数组的下标。
- 跟 **3.24 只出现一次的数字**找到数组中消失的数字类似。

```cpp
class Solution {
public:
	int firstMissingPositive(vector<int>& nums) {
        
		int n = nums.size();
		//遍历数组，让所有非正数 全部 置为 n+1 ,不参与下面的循环
		for (auto &e : nums) {
			if (e <= 0)
				e = n + 1;			
		}
		//遍历找[0,N] 
		//这里的算法是，将原数组[0,N] + 1 当成下标值
		//如果该值出现，那么就将新数组的下标等于该值记为 负数
		//这样新数组中数据为正 的下标 + 1 即为未出现的数据
		for (int i = 0; i < n; i++) {
			//这条语句是为了 确保 有重复下标值出现的时候，能够有效标记
			int e = abs(nums[i]);
			if (e <= n)
				nums[e - 1] = -abs(nums[e - 1]);
		}
		for (int i = 0; i < n; i++) {
			if (nums[i] > 0)
				return i + 1;
		}
		//如果[1,N+1] 都出现过，则返回 N+1
		return n + 1;
	}
};
```





## 4.2 寻找两个正序数组中的中位数

**题目：**给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

```cpp
//暴力法·肯定下下下选
class Solution {
public:
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int length1 = nums1.size();
		int length2 = nums2.size();
		//将 nums1 ，num2 合并
		vector<int> ans;
		ans = nums1;
		for (int i = 0; i < length2; i++)
			ans.push_back(nums2[i]);
        //排序
		sort(ans.begin(), ans.end());
		int length = length1 + length2 ;
		int mid = length1 + length2 >> 1;
        //如果空数组
		if (mid == 0)
			return ans[mid];
		//总长度为奇数，则中间值；若为偶数，则中间值的一半
        if (length % 2 == 1)
			return ans[mid];
		else
			return (ans[mid] + ans[mid - 1])/ 2.0;
	}
};
```

这个算法具体查看[详解](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)。

```cpp
//算法·二分查找· 两次二分
class Solution {
public:
	//此函数只是求合并后 数组 的中间下标
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int length = nums1.size() + nums2.size();
		//总长为奇数，则返回中间值；总长为偶数，则返回中间两数的平均值
		if (length % 2 == 1)
			return midValue(nums1, nums2, (length + 1 ) / 2 ); // 第 n 个数
		else
			return (midValue(nums1, nums2, length / 2 ) 
                    + midValue(nums1, nums2, length / 2 + 1) )/ 2.0;
	}
	
	//此函数求该下标的具体的值，且要在两个数组中找到上面函数中所谓的下标值在哪
    //mid 为下标值
    //index 为舍弃掉不符合元素后的数组下标，newIndex 为中间数组下标
	int midValue(vector<int>& nums1, vector<int>& nums2 , int mid) {
		int m = nums1.size();
		int n = nums2.size();
		int index1(0), index2(0);
		
		while (true) {
			if (m == index1)
				return nums2[index2 + mid - 1];
			if (n == index2)
				return nums1[index1 + mid - 1];
			if (mid == 1)
				return min(nums1[index1], nums2[index2]);
			//防止数组下标越界，例如，num1 的长度为 1 ，mid = 3 ，就越界了
             //newIndex = 现在当前的下标(index) + mid / 2 
			int  newIndex1 = min(mid / 2 + index1 - 1, m - 1);
			int  newIndex2 = min(mid / 2 + index2 - 1, n - 1);
			
			if (nums1[newIndex1] <= nums2[newIndex2]) {
				mid -= newIndex1 - index1 + 1;
				index1 = newIndex1 + 1;
			} else {
				mid -= newIndex2 - index2 + 1;
				index2 = newIndex2 + 1;
			}
		}
	}
};
```



+++



## 4.3 接雨水

**题目：**给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```cpp
//dp算法·动态规划
class Solution {
public:
	int trap(vector<int>& height) {
		int n = height.size();
		if (n == 0)
			return 0;
		vector<int> left(n), right(n);
		left[0] = height[0];
		right[n - 1] = height[n - 1];
		//前一次的值赋给 left ，为坐标值
		for (int i = 1; i < n; i++) {
			left[i] = max(left[i - 1], height[i]);
		}
		for (int i = n - 2; i >= 0; i--) {
			right[i] = max(right[i + 1], height[i]);
		}
		int ans = 0;
		//height 为当前坐标下的 值
		for (int i = 0; i < n; i++) {
			int level = min(left[i], right[i]);
			ans += max(0, level - height[i]);
		}
		return ans;
	}
};
```





## 4.3 字符串相乘

**题目：**给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**思路：**逐位做乘法，结果保存起来；然后各位的数字为 result % 10，进位为 result / 10 。

```cpp
class Solution {
public:
	string multiply(string num1, string num2) {
		if (num1 == "0" || num2 == "0")
			return "0";
		int m = num1.length();
		int n = num2.length();
		//存放各位乘积的结果
		vector<int> ansArr(m + n );
		for (int i = m - 1; i >= 0; i--) {
			int x = num1[i] - '0';
			for (int j = n - 1; j >= 0; j--) {
				int y = num2[j] - '0';
				ansArr[i + j + 1] += x * y;
		
			}
		}

		for (int i = m + n - 1; i > 0; i--) {
			ansArr[i - 1] += ansArr[i] / 10; //进位
			ansArr[i ] %= 10;
		}
		/*--将数组的中的数 转化成字符串风格--*/
		//ansArr 中的容量是最大值，所以要判断下最高位是否有值。
		int index = ansArr[0] == 0 ? 1 : 0;
		string ans;
		while (index < m + n) {
			ans.push_back(ansArr[index]);
			index++;

		}
		for (auto &e : ans)
			e += '0';
		return ans;
	}
```



## 4.3 通配符匹配

**题目：**给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

- '?' 可以匹配任何单个字符。
- '*' 可以匹配任意字符串（包括空字符串）。

**思路：**看[大佬](https://leetcode-cn.com/problems/wildcard-matching/solution/yi-ge-qi-pan-kan-dong-dong-tai-gui-hua-dpsi-lu-by-/)的图解吧。太难了，我写不出来，也没能理解通透dp算法。

```cpp
class Solution {
public:
	bool isMatch(string s, string p) {
		int zong = p.length() + 1;
		int heng = s.length() + 1;
		//dp 二维数组全部初始化为 0
		vector<vector<bool>> dp(zong + 1, vector<bool>(heng + 1, 0));

		//从第一个位置出发，标为 true，即 1 
		dp[0][0] = 1;

		for (int i = 1; i <= zong; i++) {
			//标志位 path ，是否能走下一步
			int path = 0;
			for (int j = 1; j <= heng; j++) {
				//如果下个匹配符号为 ‘*’，且 左上角要为 1 的格子标为 下一步 ，即1
				if (p[i - 1] == '*' && dp[i - 1][j - 1]) {
					path = 1;
					//将此行后面的值都标为 1 ，即都是有可能的下一步
					dp[i][j - 1] = 1;
				}
				if (p[i - 1] == '?' || p[i - 1] == s[j - 1]) {
					dp[i ][j ] = dp[i-1][j-1];
				}
				if (path)
					dp[i][j] = 1;
			}
		}
		return  dp[zong][heng];
	}
};
```



## 4.3 正则表达式匹配

**题目：**给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖**整个**字符串 `s`的，而不是部分字符串。

**思路：** dp 算法

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size()
        //匿名函数
        auto matches = [&](int i, int j) {
            if (i == 0) {
                return false;
            }
            if (p[j - 1] == '.') {
                return true;
            }
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> f(m + 1, vector<int>(n + 1));
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    f[i][j] |= f[i][j - 2];
                    if (matches(i, j - 1)) {
                        f[i][j] |= f[i - 1][j];
                    }
                }
                else {
                    if (matches(i, j)) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }
};


```



+++



## 4.4 递归算法

**递归·分治·算法**：直接或者间接**不断反复调用自身**来达到解决问题的方法。这就要求原始问题可以分解成相同问题的子问题。

**解题思路：**

1. 将原问题分解为n个规模较小的子问题，各子问题间独立存在，并且与原问题形式相同

2. 递归的解决各个子问题

3. 将各个子问题的解合并得到原问题的解



**算法步骤：**

1. 明确函数要做什么，完成什么样的功能（包括但不限于给函数起名，变量起名）
2. 明确递归结束的条件（这个是重中之重，只有确定了什么时候结束，下面写的代码才知道正确与否）
3. 找到函数等价关系式，即“递”下去与“归”上来的关系



**适应题型：**



**例题：**

```cpp
/*-------------斐波那契数列---------------------*/
class Solution {
public:
	int Fibonacci(int n) {
         //退出条件
		if (n <= 2)
			return 1;
		 
		return Fibonacci(n - 1) + Fibonacci(n - 2);
	}
	
};
//也称兔子数列，单这种算法时间复杂度好像很高

//利用迭代算法试下
class Solution {
public:
	int Fibonacci(int n) {
		int prev = 1;
		int curr = 1;
		if (n <= 2)
			return 1;
		for (int i = 2; i < n; i++) {
			int temp = curr + prev;
			prev = curr;
			curr = temp;
			
		}
		return curr;
	}
	
};
```



```cpp
/*--------------小青蛙跳台阶-------------------*/
//掐头了的斐波那契数列，1,2,3,5，...


```



```cpp
/*---------------反转单链表--------------------*/
//该题目写过，查看以前的笔记
```



> 迭代法：迭代法也称“辗转法”，是一种==不断用旧变量的值递推出新值==的解决问题的方法。迭代算法一般用于数值计算。例如  累加、 累乘都是迭代运算。





## 4.4 dp 算法

**动态规划算法**：动态规划，无非就是利用**历史记录**，来避免我们的重复计算。而这些**历史记录**，我们得需要一些**变量**来保存，一般是用**一维数组**或者**二维数组**来保存。

计算机解决问题其实没有任何技巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。

列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。

备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？

**解题思路：**

1. 需要求最大、最小值
2. 该求解的值与前所有转态或多或少的有关



**算法步骤：**

1. 定义数组元素的含义（明确dp表格的横纵坐标代表了什么，存放的是什么历史记录）
2. 找出数组元素之间的关系式（找到转态转移方程）
3. 找出初始值（找到dp表格开始的地方，由此出发）

> dp算法主要分两类：一类是求最优解，典型的==背包问题==；另一类是技术类，==最优子结构==

**例题：**

```cpp
/*-----------给你六种面额1、5、10、20、50、100元的纸币，假设每种币值的数量都足够多，编写程序求组成N员（N为0-10000的非负整数）的不同组合的个数----------------*/
//定义dp[i] = 前 i 种的所有组合
// 状态转移公式： dp[i] = dp[i] + dp[ i - money[i]]
//例如，求521 的组合，当100面额的张数为 0 时，也就是求其他面额的所有可能
class Solution {
public:
	int moneyCombination(int target){
		int money[] = { 1,5,10,20,50,100 };
		//dp[j] 当前面额的所有可能
		vector<int> dp(target + 1);
		//赋初值，这里主要用与 做减法后，说明 有该面额的纸币，所以令为 1
		dp[0] = 1;
		for (int i = 0; i < 6; i++) {
			for (int j = money[i]; j <= target; j++)
				//dp[j] 上一次面额的所有可能性
				//[j - money[i]] 为当前 面额减去所给面额后剩余的 能匹配的面额纸币
                 //比如  dp[8] = （面额为1 时候的所有可能性） 1 +  1
				dp[j] = dp[j] + dp[j - money[i]];
		}
		return dp[target];
	}
	
};
```



```cpp
//完全背包问题·有序数组做法
//二维数组来做
class Solution {
public:
	int moneyCombination(int target) {
		int money[] = { 1, 5, 10, 20, 50, 100 };
		int len = sizeof(money) / sizeof(int);
		vector<vector<int>> dp(len + 1, vector<int>(target + 1));
        //组成的数值为 0 的可能性就 1 种
		for (int i = 0; i <= len; i++)
			dp[i][0] = 1;
        //没有 0 面额 的纸币
		for (int j = 1; j <= target; j++) 
			dp[0][j] = 0;
	
		for (int i = 1; i <= len; i++) {
			for (int j = 1; j <= target; j++) {
				dp[i][j] = 0;
				for (int k = 0; k <= j / money[i - 1]; k++) {
					dp[i][j] += dp[i - 1][j - k * money[i - 1]];
				}
			}
		}
		return dp[len][target];
	}

};
```





```cpp
/*--------------给你 k 种面值的硬币，面值分别为 c1, c2 … ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 --------------*/

class Solution {
public:
	int coinChange(int target) {
		int money[] = { 1, 2, 5 };
		vector<int> dp(target + 1, INT_MAX);
		dp[0] = 0;

		for (int i = 0; i < 3; i++) {
			for(int j = money[i]; j <=target; j++)
				dp[j] = min(dp[j], dp[j - money[i]] + 1);
		}
		return dp[target] == INT_MAX ? -1 : dp[target];
	}

};

```



## --------动态规划dp----------

## 4.5 不用路径

**题目：**一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**思路1：**用dp算法来做。

**思路2：**将dp算法优化，使用组合数学来做。

```cpp
class Solution {
public:
	int uniquePaths(int m, int n) {
		if (m <= 0 || n <= 0)
			return 0;
        //使用dp[i][j] 存放m，n的可能性
		vector<vector<int>> dp(m, vector<int>(n, 0));
        //若只有一行或者一列，那么可能性都为 1 
		for (int i = 0; i < m; i++)
			dp[i][0] = 1;
		for (int i = 0; i < n; i++)
			dp[0][i] = 1;
        //状态转移式： dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
			}
		}
		return dp[m - 1][n - 1];
	}
};
```



组合公式如下：
$$
\frac{(m+n-2)(m+n-3)\cdots n}{(m-1)!}
$$


```cpp
//组合数学
class Solution{
public:
    int uniquePaths(int m, int n){
        long long ans = 1;
        for(int x = n , y = 1 ; y < m ; x++, y++)
            ans *= x/y;
        return ans;
    }
};

```





## 4.5 最小路径和

**题目：**给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。

**思路：**dp 算法。

```cpp
class Solution {
public:
	int minPathSum(vector<vector<int>>& grid) {
		int m = grid.size();
		int n = grid[0].size();
		if (m <= 0 || n <= 0)
			return 0;
		vector<vector<int>> dp(m, vector<int>(n));
		//赋初值
		dp[0][0] = grid[0][0];
		/*第一行、列赋值，该行、列的值为，上一个数值 +  当前数值 */
		for (int i = 1; i < m; i++)
			dp[i][0] = dp[i - 1][0] + grid[i][0];
		for (int j = 1; j < n; j++)
			dp[0][j] = dp[0][j - 1] + grid[0][j];
		//状态转换式 ： 当前的数 + 上次值（包括行、列）的最小值
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				dp[i][j] = min(dp[i - 1][j] , dp[i][j - 1]) + grid[i][j];
			}
		}
		return dp[m - 1][n - 1];
	}
};

```



## 4.5 编辑距离

**题目：**给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**思路：**动态规划。

```cpp
class Solution {
public:
	int minDistance(string word1, string word2) {
		int m = word1.length();
		int n = word2.length();
		//dp[i][j] 表示 word1 转换成 word2 所需要的最少次数
		vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        //赋初值
		for (int j = 1; j <= n; j++)
			dp[0][j] = dp[0][j - 1] + 1;
		for (int i = 1; i <= m; i++)
			dp[i][0] = dp[i - 1][0] + 1;
		
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
                 //两个word 相同
				if (word1[i - 1] == word2[j - 1])
					dp[i][j] = dp[i - 1][j - 1];
				else					
			dp[i][j] =  min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
			//min 只接受两个参数
            }
		}
		return dp[m ][n];
	}
};

```



## 4.6 不同路径II

**题目：**一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

```cpp
//dp算法·我目前理解的算法
class Solution {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		int m = obstacleGrid.size();
		int n = obstacleGrid[0].size();
		//正常表格中的 dp[i][j]:表示从(0,0)->(i,j) 处所有的可能性
		vector<vector<int>> dp(m, vector<int>(n));
		for (int i = 0; i < m; i++) {
			//如果碰到 barrier ，就退出，下面无法走到
			//否则，该行置 1 
			if (obstacleGrid[i][0] == 1)
				break;
			dp[i][0] = 1;
		}
		for (int j = 0; j < n; j++) {
			//列中碰到 barrier ，退出，下面的列无法走到
			//否则，该列置 1  ，初始化
			if (obstacleGrid[0][j] == 1)
				break;
			dp[0][j] = 1;
		}

		//没有障碍物的情况下
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j]
                    + dp[i][j - 1];
			}
		}
		return dp[m - 1][n - 1];
	}
};
```





```cpp
//优化版本·利用滚动数组思想·最优子结构
//临时没看懂，好像与凑钱类似
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int n = obstacleGrid.size(), m = obstacleGrid.at(0).size();
        vector <int> f(m);

        f[0] = (obstacleGrid[0][0] == 0);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    f[j] = 0;
                    continue;
                }
                if (j - 1 >= 0 && obstacleGrid[i][j - 1] == 0) {
                    f[j] += f[j - 1];
                }
            }
        }

        return f.back();
    }
};

```







## --------背包问题详解---------

## 4.6 基本背包

**题目：**有N件物品和一个容量是V的背包。第i件物品的体积是ci，价值是vi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且价值最大。

**解题步骤：**

1. 定义数组含义： `dp[i][v]`表示前 i 个物品在体积为 v 的情况下价值最大的可能
2. 找到状态转移方程：主要就是第 i 个物品 拿不拿的问题，在这两种情况中取最大值
   - 如果不拿第 i 个物品，则 f(i , j) = f(i -1 , j)
   - 如果拿第 i 个物品， 则 f(i , j) = f(i -1 , j - w~i~)
3. 赋初值：f(0, 0) = 0 ，一个物品都不考虑则价值为 0

==目前来看，背包问题最少也得两层循环==

```cpp
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		//正常的dp定义 ： dp[i][c] 代表了前 i 个物品组合的最大容量
		vector<vector<int>> dp(m + 1, vector<int>(capacity + 1, 0));
		//正常遍历操作
		for (int i = 1; i <= m; i++) {
			for (int c = 1; c <= capacity; c++) {
				//这里 w[i -1 ] 的原因是 w[m] 的最大下标为 m - 1 
				//而为了维护dp备忘录，只能是从 1 开始（这里 是因为定义，只能从1 开始）
				//所以实际中取得物品的下标为当前值 减一
				//状态转移中的 i - 1 是跟前一状态有关联
				if (c < w[i - 1])
					dp[i][c] = dp[i - 1][c];
				else
					dp[i][c] = max(dp[i - 1][c], 
                                   dp[i - 1][c - w[i - 1]] + v[i - 1]);
			}
		}
		return dp[m][capacity];
	}

};
```



```cpp
//优化·二位数组变一维数组  
//解释如下：dp[j] :代表 所有能组成 j 的可能
//因为一开始接触的是金币题目，所以以它来举例（纸币自带顺序，所以不能按通用方法处理）
//有 1 元、5 元 、10 元、 20 元等的纸币，
//第一层循环，记录用 1 元组成的所有可能，记录到j
//第二层循环，记录用 5 元 跟 1元 组成的所有可能，记录到 j 
//如此往复，形成 memo
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		vector<int> dp(capacity + 1);
         //组成的结果为 0 时， 可能性为 0
		dp[0] = 0;
		for (int i = 0; i < m; i++) {
			for (int j = capacity; j >= w[i]; j--) {
                  // i = 0 时， 记录 w[0] 所能组成的最大可能
                  // i = 1 时， 记录 w[1] 与 w[0] 所组成的最大可能
				dp[j] = max(dp[j] ,dp[j - w[i]] + v[i]);
			}
		}
		return dp[capacity];
	}

};
```



## 4.6 完全背包

**题目：**有N件物品和一个容量是V的背包。第i件物品的容量是ci，价值是vi 。求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且价值最大。

与背包问题的区别是，此处的物品可以多次选择。

**解题步骤：**

1. 定义数组含义：`dp[i][v]`表示前 i 个物品在体积为 v 的情况下价值最大的所有可能
2. 转态转移公式： `f(i , v) = max(f(i -1 , v) , f(i-1, v - k *w[i])+ v[i]*k )`表示为（前面的最大价值） 与（ 去掉所有本次物品后剩余空间还能取到的最大价值 + 取本次物品个数最多的最大价值 ）的最大值。
3. 赋初值：f(0, 0) = 0 ，f(0 , i) =0 , f(i , 0) = 0



```cpp
//当 i = 1 开始时， 一定不要忘记给进来的数组是从下标 0 开始的，一定要 减1 ，不然会越界
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveAKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		vector<vector<int>> dp(m + 1, vector<int>(capacity + 1));
		//正常程序写法
		for (int i = 1; i <= m; i++) {
			for (int c = 0; c <= capacity; c++) {
                //这里 只用 k <= c/w[i -1]即可，因为 c 最大就是 capacity
				for (int k = 0; k <= c / w[i - 1] ; k++)
					dp[i][c] = max(dp[i - 1][c], 
                                   dp[i - 1][c - k * w[i -1]] + k * v[i - 1]);

			}
		}
		return dp[m][capacity];
	}

};
```



```cpp
//优化·二维数组变成一维数组
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveAKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		//dp[j] 表示前i个物品在容量为 j 时的最大价值 ，且更新为 前 i-1 与 i 的最大值
		vector<int> dp(capacity + 1);

		for (int i = 1; i <= m; i++) {
			for (int c = capacity; c >= w[i-1]; c--) {
				for (int k = 0; k <= c / w[i - 1]; k++)
					dp[c] = max(dp[c], dp[c - k * w[i - 1]] + v[i - 1]* k);
			}
		}
		return dp[capacity];
	}
};
```



```cpp
//优化2·减少一次循环·硬币题目
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveAKS(vector<int> w, vector<int> v, int capacity) {
		int m = w.size();
		//dp[j] 表示前i个物品在容量为 j 时的最大价值 ，且更新为 前 i-1 与 i 的最大值
		vector<int> dp(capacity + 1);
		//令 c 从 w[i] 中取值，因为所有的肯能性都是基于w[i] 中的元素值来进行的
        //此时就跟硬币的题目一模一样
		for (int i = 1; i <= m; i++) {
            //下面循环的意思是：w[i -1]所能组成最大值为 c 的所有可能性
			for (int c = w[i - 1]; c <= capacity; c++) {			
				dp[c] = max(dp[c], dp[c - w[i - 1]] + v[i - 1]);
			}
		}
		return dp[capacity];
	}
};
```



## 4.6 多重背包

**题目：**有N件物品和一个容量是V的背包。第i种物品最多有si件，每件的体积是ci，价值是vi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且价值总和最大。

==多重背包只是比完全背包多了一个约束条件，即k不是一个定值，是一个动态变化的值。==

**解题步骤：**

1. 定义`dp[i][c]`：表示前 i 个物品 在容量 为 c 的情况下组成最大价值的可能
2. 状态转移方程：`f(i ,c) = max(f(i-1,c), f(i-1, c - k*w[i-1])+k*v[i])(k <= index[i])`，这个方程仅仅是比完全背包多了一个 k  的取值范围
3. 赋初值：f(0,0) = 0

```cpp
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveMKS(vector<int> w, vector<int> v, vector<int> index ,int capacity) {
		int m = w.size();
		vector<vector<int>> dp(m + 1, vector<int>(capacity + 1));

		for (int i = 1; i <= m; i++) {
			for (int c = 0; c <= capacity; c++) {
                 //区别在这儿， k 还要满足 最大不超过给的数值，即index[i]
				for (int k = 0; k <= index[i - 1] && k <= c/w[i-1]; k++) {
					dp[i][c] = max(dp[i - 1][c],
                                   dp[i - 1][c - k * w[i - 1]] + k *v[i - 1]);
				}
			}
		}
		return dp[m][capacity];
	}
};
```



```cpp
//优化·一维数组
class Solution {
public:
	//w 代表物品的容量   v 代表物品价值   capacity 代表背包容量
	int solveMKS(vector<int> w, vector<int> v, vector<int> index ,int capacity) {
		int m = w.size();
		vector<int> dp(capacity + 1);
		
		for (int i = 1; i <= m; i++) {
			for (int c = capacity; c >= w[i - 1]; c--) {
				for (int k = 0; k <= index[i - 1] && k <= c / w[i - 1]; k++) {
					dp[c] = max(dp[c], dp[c - k * w[i - 1]] + k * v[i - 1]);
				}
			}
		}
		return dp[capacity];
	}
};
```



[参考文章](https://blog.csdn.net/weiainibuqi/article/details/105524018?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-105524018.first_rank_v2_pc_rank_v29)

```cpp
//优化·二进制优化
//本质上将 遍历次数减少了，优化的是穷举办法。比如如果 i = 7 的时候
//无论第 7 次是取还是不取，都要遍历 6 次 
//而采取二进制优化，将其分成 1 ，2 ，4 ，8 … 只需要遍历 3 次即可 
//这样转换成了01背包问题，大大优化了时间复杂度
class Good {
public:
	int v, c, n;
};

class Solution {
public: 
	int  solveMKS(vector<Good> goods , int  capacity) {
		int s = 0;
		vector<Good> newGoods;
        //将原有的物品，按照二进制的办法分成小物品
		for (int i = 0; i < goods.size(); i++) {
			s = goods[i].n;
			for (int j = 1; j <= s; j *= 2) {				
				s -= j;
				newGoods.push_back({ j *goods[i].v , j * goods[i].c });
			}
			if (s )
				newGoods.push_back({ s*goods[i].v,s* goods[i].c });
		}
		//转化成 01 背包问题
		vector<int> dp(1024);
		for (auto good : newGoods) {
			for (int j = capacity; j >= good.c; j--) {				
				dp[j] = max(dp[j], dp[j - good.c] + good.v);
			}
		}
		return dp[capacity];
	}
	
};
```



```cpp
//优化·单调队列

```





+++



## 4.7 最长有效括号

**题目：**给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**解题步骤：**

1. 定义`dp[i]:`该 i 处位置的组成有效括号的长度。例如：（（（）））dp[4] = 2

2. 状态转移方程：两种情况

   - dp[i]  = dp [i - 2] + 2
   - dp[i] = dp[i -1] + dp[i - dp[i -1] -2] +2
 3. 赋初值

 


```cpp
   class Solution {
   public:
   	int longestValidParentheses(string s) {
   		int m = s.length();
   		vector<int> dp(m + 1, 0);
   		int ans = 0; //这是简化代码初始化的变量，要是在下面就计算出最大值，代码就显得冗长
   		for (int i = 1; i <= m; i++) {
   			if (s[i ] == ')') {
   				if (s[i - 1] == '(')
   					dp[i] = i >= 2 ? dp[i - 2] + 2 : 0 + 2;
   			//前一个是左括号，则进行判断
   			//如果该i 的值与前面配对的最大值的差值 超过了2则证明有无效的括号，需要减去
   				else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(')
   					dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ?
                                         dp[i - dp[i - 1] - 2] : 0) + 2;
   			}
   			ans = max(dp[i], ans);
   		}
   		return ans;
   	}
   };
```

   

```cpp
class Solution {
public:
	int longestValidParentheses(string s) {
		int ans = 0;
		stack<int> stk;
		stk.push(-1);
        //遇到左括号，则入栈，右括号，出栈
        //直到栈顶为空，则 i + 1 ， 即为 有效长度
		for (int i = 0; i < s.length(); i++) {
			if (s[i] == '(')
				stk.push(i);
			else {
				stk.pop();
				if (stk.empty())
					stk.push(i);
				else {
					ans = max(ans, i - stk.top());
				}
			}
		}
		return ans;
	}
};
```



## 4.7 整数拆分

**题目：**给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。返回你可以获得的最大乘积。

**解题步骤：**

1. 定义`dp[i]`：数字 i 拆分后乘积能达到的最大值。

2. 状态转移方程：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

   一个是j * (i - j) 直接相乘。

   一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。

3. 赋初值：dp[2] = 1

```cpp
class Solution {
public:
	int integerBreak(int n) {
        if (n < 4) 
            return n - 1;
		vector<int> dp(n + 1);
		dp[2] = 1;
		//外层循环是遍历给的数值
		//内层循环是计算所有可能的组合数值
		for (int i = 3; i <= n; i++) {
			for (int j = 1; j < i; j++) {
				dp[i] = max(dp[i], max(j *(i - j), j * dp[i - j]));
			}
		}
		return dp[n];
	}
};
```







## 4.7 不同的二叉树搜索

**题目：**给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**解题步骤：**

1. 定义：dp[i] 1到i为节点组成的二叉搜索树的个数为dp[i]。
2. 状态转移方程（以后用递推式代替）：dp[i] += dp[j - 1] * dp[i - j]， [解释](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486532&idx=1&sn=9c3d605f6bf81027f9f39d1c45b8c4a6&scene=21#wechat_redirect)为  dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
3. 赋初值：dp[0] = 1。

```cpp
  class Solution {
  public:
	  int numTrees(int n) {
		  vector<int> dp(n + 1);
		  dp[0] = 1;
		  for (int i = 1; i <= n; i++) {
			  //j 为头节点的所有组合
			  for (int j = 1; j <= i; j++) {
				  dp[i] += dp[j - 1] * dp[i - j];
			  }
		  }
		  return dp[n];
	  }
  };
```



## 4.7 分割等和子集

**题目：**给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**思路：**可以转换成01背包问题。即总容量为 sum / 2 ， 让数组的中元素当做物品与价值。

**解题步骤：**

1. 定义dp[i]：前 i 数值所组成的最大和
2. 递推式：dp[i] = max(dp[i -1] , dp[j - nums[i]] + nums[i])
3. 赋初值：dp[0] = 0。

```cpp
  class Solution {
  public:
	  bool canPartition(vector<int>& nums) {
		  int m = nums.size();
		  int sum = 0;
		 
		  for (int i = 0; i < m; i++)
			  sum += nums[i];
		  if (sum % 2 == 1)
			  return false;
		  int target = sum / 2;
		  vector<int> dp(target + 1);
		  for (int i = 1; i <= m; i++) {
			  for (int j = target; j >= nums[i-1]; j--) {
				  dp[j] = max(dp[j], dp[j - nums[i -1]] + nums[i-1]);
			  }
		  }
		  if (dp[target] == target)
			  return true;
		  return false;
	  }
  };

```



+++



## 4.8 最后一块石头的重量II

**题目：**有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；

如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

> **拆题：**本题可以一共是取两个数，而这两个数所能组成的最大可能为 sum/2 。这样就转换成了01 背包问题。即有容量为 sum/2的背包，有stone[i] 的物品，其中c[i] 、v[i] 都是stone[i]；求两个数的最大值。

```cpp
  class Solution {
  public:
	  int lastStoneWeightII(vector<int>& stones) {
		  int m = stones.size();
		  //这里要计算容量，即个数，stone[i] 当做价值来考虑
		  int sum = accumulate(stones.begin(), stones.end(),0) ;
          int capacity = sum / 2;
		  vector<int> dp(capacity + 1);
		  dp[0] = 0;
		  for (int i = 1; i <= m; i++) {
			  for (int j = capacity; j >= stones[i -1]; j--) {
				  dp[j] = max(dp[j], dp[j - stones[i - 1]] + stones[i - 1]);
			  }
		  }
		  return sum-dp[capacity]*2 ;
	  }
  };

```



## 4.8 目标和

**题目：**给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

> **拆题：**原问题等同于： 找到nums一个正子集和一个负子集，使得总和等于target
>
> 我们假设P是正子集，N是负子集 例如： 假设nums = [1, 2, 3, 4, 5]，target = 3，一个可能的解决方案是+1-2+3-4+5 = 3 这里正子集P = [1, 3, 5]和负子集N = [2, 4]
>
> 那么让我们看看如何将其转换为子集求和问题：
>
> ```
>                   sum(P) - sum(N) = target
> sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
>                        2 * sum(P) = target + sum(nums)  
> ```

```cpp
//关键在于  上面的公式 推导 
class Solution {
  public:
	  int findTargetSumWays(vector<int>& nums, int S) {
		  int m = nums.size();
		  int sum = accumulate(nums.begin(), nums.end(), 0);
		  //公式中已经证明了 sum + S 必须是 偶数
		  if (S > sum) 
            return 0;
		  if ((sum + S) % 2 == 1)
			  return 0;
          int capacity = (sum + S) /2;

		  vector<int> dp(capacity + 1);
		  dp[0] = 1;
		  for (int i = 1; i <= m; i++) {
			  for (int j = capacity; j >= nums[i - 1]; j--) {
				  dp[j] = dp[j] + dp[j - nums[i - 1]];
			  }
		  }
		  return dp[capacity];
	  }
  };
```



## 4.8 1和0

**题目：**给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

> **拆题：**相当于二维背包，但还是同 01 背包问题的解法。

```cpp
  class Solution {
  public:
	  // m 、n 相当于是个二维背包，两层背包
	  int findMaxForm(vector<string>& strs, int m, int n) {
		  //dp[i][j] 满足 i 个 0 ， j 个 1 的最大可能数
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1));
		  //外层循环是挨个字符串进行遍历
		  for (auto s : strs) {
			  int oneNum(0), zeroNum(0);
			  for (auto e : s) {
				  if (e == '1')
					  oneNum++;
				  else
					  zeroNum++;
			  }
			  //内层循环是找出  该字符串中所有元素能满足target 的最大可能数	
			  //不要忘记dp[][] 是备忘录，记录了上次 循环的最大可能数
			  for (int i = m; i >= zeroNum; i--) {
				  for (int j = n; j >= oneNum; j--) {
					  dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
				  }
			  }
			 
		  }
		  
		  return dp[m][n];
	  }

  };
```



## 4.8 零钱兑换II

**题目：**给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

**思路：**dp的例题。硬币的题目因为计算的是总次数，不是总价值，所以只能前向遍历，累计次数。

```cpp
  class Solution {
  public:
	  int change(int amount, vector<int>& coins) {
		  int m = coins.size();
		  vector<int> dp(amount + 1);
          dp[0] = 1;
		  for (int i = 1; i <= m; i++) {
			  for (int j = coins[i -1]; j <= amount; j++) {
				  dp[j] = dp[j] + dp[j - coins[i - 1]];
			  }
		  }

		  return dp[amount];
	  }
  };
```



+++



## 4.9 组合总数IV

**题目：**给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**思路：**纸币问题（组合数），现在是升级版，求排列数。

>  **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。这个是给定选项，选项中的值仅遍历1次，每次都从target中，看每次能组合的最大值；
>
> **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。这个是给定target，target的值仅遍历1次，每次都将选项中的值依次遍历，看符合条件的个数。

> **排列的解释：**
>
> ```
> dp[j] = dp[j] + dp[j - nums[i - 1]]
> 等式右边，第一项是之前的累加，第二项是选择当前项后所有的可能性
> 
> j = 1 且 j > nums[i - 1] 时 ，i = 1，
> dp[1] = dp[1] + dp[0];
> 
> j = 2 且 j > nums[i - 1] 时，i = 1，2
> dp[2] = dp[2] + dp[1] --> 1 所有的可能性
> dp[2] = dp[2] + dp[0] --> 2 所有的可能性
> 
> j = 3 且 j > nums[i - 1] 时，i = 1，2，3
> dp[3] = dp[3] + dp[2]--> 1 所有的可能性
> dp[3] = dp[3] + dp[1]--> 2 所有的可能性
> dp[3] = dp[3] + dp[0]--> 3 所有的可能性
> ```
>
> 

```cpp
class Solution {
 public:
	  int combinationSum4(vector<int>& nums, int target) {
		  int m = nums.size();
		  vector<int> dp(target + 1);
		  dp[0] = 1;
		  for (int j = 1; j <= target ; j++) {
			  for (int i = 1; i <= m ; i++) {
				  if (j >= nums[i - 1] && dp[j] < INT_MAX - dp[j - nums[i - 1]])
					  dp[j] = dp[j] + dp[j - nums[i - 1]];
			  }
		  }
		  return dp[target];
	  }
  };


```



## 4.9 再爬楼梯

**原题(#3.23 爬楼梯)**就是一个排列问题。

**题目：**每次可以爬 1 、 2或者m 个台阶。问有多少种不同的方法可以爬到楼顶呢？

**思路：**与上题类似。求排列。

```cpp
  class Solution {
  public:
	  int climbStairs(vector<int> &stairs,int target) {
		  int m = stairs.size();
		  vector<int> dp(target + 1);
		  dp[0] = 1;

		  for (int j = 1; j <= target; j++) {
			  for (int i = 1; i <= m; i++) {
				  if(j >= stairs[i - 1])     
                      dp[j] = dp[j] + dp[j - stairs[i - 1]];
			  }
		  }
		  return dp[target];
	  }

  };
```



## 4.9 再换零钱

**题目：**给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

**思路：**完全背包问题。

```cpp
  class Solution {
  public:
	  int coinChange(vector<int>& coins, int amount) {
		  int m = coins.size();
		  vector<int> dp(amount + 1, INT_MAX);
		  dp[0] = 0;
		  for (int i = 1; i <= m; i++) {
			  for (int j = coins[i - 1]; j <= amount; j++) {
				  //比较最小值的时候，就将dp初始化为最大值
				  if (dp[j - coins[i - 1]] != INT_MAX) 
					  dp[j] = min(dp[j], 1 + dp[j - coins[i - 1]]);
				
			  }
		  }
		  if (dp[amount] == INT_MAX)  return -1;
		  return dp[amount];
	  }
  };
```



## 4.9 再求平方数

**题目：**给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

**思路：**完全背包问题。

```cpp
  class Solution {
  public:
	  int numSquares(int n) {
		  vector<int> dp(n + 1,INT_MAX);
		  dp[0] = 0;
		  for (int i = 1; i <= sqrt(n); i++) {
			  for (int j = pow(i, 2); j <= n; j++) {
				  dp[j] = min(dp[j],1 + dp[j - i * i]);
			  }
		  }
		  return dp[n];
	  }
  };
```



+++



## 4.10 单词拆分

**题目：**给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

**说明：**拆分时可以重复使用字典中的单词。

**思路：**一开始说的看成背包问题，就钻进去了，还在想怎么写出递推关系来。。。其实，本题目主要是将s字符串分割成一个个小串，将小串与字典的单词进行比较。

如果看成完全背包问题的话，这题目是求排列。相当于给定字符串s，看单词存不存在一种组合，能拼凑成是s，这就需要将所有的排列写出来，逐个查看。

```cpp
//算法·完全背包问题·求排列
 class Solution {
  public:
	  bool wordBreak(string s, vector<string>& wordDict) {
          //unordered_set 可以看成集合，里面的元素有序排列，且无重复
		  unordered_set<string> wordSet(wordDict.begin(),wordDict.end());
		  int m = s.size();
		  vector<bool> dp(m + 1);
		  dp[0] = 1;

		  for (int j = 1; j <= m; j++) {
			  for (int i = 0; i < j; i++) {
				  string str = s.substr(i, j - i);
                    //判断该串是否是字典的中的最后一个单词，
				  //如果不是，前项能匹配的前提下，该项也可
				  if ( wordSet.find(str) != wordSet.end() && dp[i])
					  dp[j] = 1;
			  }
		  }
		  return dp[m];
	  }
  };
```



```cpp
//一下是两个优化版本·膜拜大神
  class Solution {
  public:
	  bool wordBreak(string s, vector<string>& wordDict) {
		  //unordered_set 可以看成集合，里面的元素有序排列，且无重复
		  unordered_set<string> wordSet(wordDict.begin(),wordDict.end());
		  int m = s.size();
		  vector<bool> dp(m + 1);
		  dp[0] = 1;

		  int maxLength = 0;
		  int minLength = 0;
		 //s遍历的时候不必从初始为1，可以从字典中的最小值开始，因为小于字典中的值不符合条件
		 //物品 遍历的时候，可以省去一些不必要的循环，进行剪枝，
		 //当背包容量大于字典中的最大值的时候不需要从初始位置再进行判断了，具体看下面详解
		  for (auto e : wordDict) {
			  const int t = e.length();
			  maxLength = max(t, maxLength);
			  minLength = min(t, minLength);
		  }

		  for (int j = minLength; j <= m; j++) { //遍历背包
			  for (int i = max(0,j - maxLength); i < j; i++) { //遍历物品
				  string str = s.substr(i, j - i);
				  //判断该串是否是字典的中的最后一个单词，
				  //如果不是，前项能匹配的前提下，该项也可
				  if (dp[i] && wordSet.find(str) != wordSet.end())
					  dp[j] = 1;
			  }
		  }
		  return dp[m];
	  }
  };
```

```
当最大值为 4 的时候，i 表示 起始位置， j - i 代表 截取的长度
j = 1, i = 0, 1
j = 2, i = 0, 1, 2
j = 3, i = 0, 1, 2, 3
j = 4, i = 0, 1, 2, 3, 4 
//到上面，已将完成对 字符串最大长度的截取，如果最大长度无法匹配字典中的值，那么不符合条件
j = 5, i = 1, 2, 3, 4, 5
j = 6, i = 1, 2, 3, 4, 5, 6
```



## -------------打家劫舍-------------

## 4.10 打家劫舍

**题目：**你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

> **经典问题：打家劫舍，问题的核心在于不能取相邻的两个放间，只能隔一个或几个房间取，**
>
> **即转换成了     第 i 房间到底是偷不偷。如果偷，那么dp[i] = dp[i - 2] + nums[i];**
>
> **如果不偷，那么dp[i] = dp[i - 1]，该房间的最大值跟前一房间最大值相同，且前一房间跟本房间的奇偶性**
>
> **不同，将所有问题情况都考虑在内了。**

```cpp
  class Solution {
  public:
	  int rob(vector<int>& nums) {
		  int m = nums.size();
		  if (m == 0) return 0;
		  if (m == 1) return nums[0];
		  vector<int> dp(m);
		  dp[0] = nums[0];
		  dp[1] = max(nums[1], dp[0]);
		  
		  for (int i = 2; i < m; i++) {
			  //dp[i - 1]: 当第 i 间 房间不偷时，那么最高价值跟前一房间相同
			  //所以 dp[i - 1] 也代表了不同奇偶性的最大值
			  dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
		  }
		  return dp[m - 1];
	  }
  };
```



## 4.10 打家劫舍II

**题目：**这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。

> 这不是隔一个房间取得问题，而是选出不相邻的，组合值为最大的可能。

这道题目和==打家劫舍==是差不多的，唯一区别就是成环了。

对于一个数组，成环的话主要有如下三种情况：

- 情况一：考虑不包含首尾元素

![图片](刷题日记.assets/640)

- 情况二：考虑包含首元素，不包含尾元素

![图片](刷题日记.assets/640)

- 情况三：考虑包含尾元素，不包含首元素

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ciaqDnJprwv7DroYFRD2ITKia9UcE5BhI7wGSP3yF2VibOyd1DKBwDSTiaGvqRNAiaXicu9zhMVsmlJAzPMWW7iclmsZQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**注意我这里用的是"考虑"**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！对于情况三，取nums[1] 和 nums[3]就是最大的。

**而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了。**

```cpp
  class Solution {
  public:
	  int rob(vector<int>& nums) {
		  int m = nums.size();
		  if (m == 0) return 0;
		  if (m == 1) return nums[0];

		  int res1 = robRange(nums, 0, m - 2);
		  int res2 = robRange(nums, 1, m - 1);
		  return max(res1, res2);
	  }

	  int robRange(vector<int> &nums, int start, int end ) {
		  if (start == end) return nums[start];

		  int m = nums.size();
		  vector<int> dp(m);
		  dp[start] = nums[start];
		  dp[start + 1] = max(nums[start],nums[start + 1]);

		  for (int i = start + 2; i < m; i++) {
			  //dp[i - 1]: 当第 i 间 房间不偷时，那么最高价值跟前一房间相同
			  //所以 dp[i - 1] 也代表了不同奇偶性的最大值
			  dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

		  }
		  return dp[end];
	  }
  };
```



## 4.10 打家劫舍III

**题目：**在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**思路：**==树形DP的入门题目。==

**解题步骤：**

1. 定义dp[0]：不取该节点的最大值；dp[1]：取该节点的最大值。对于**树**来说，数字对于读取数据没有作用，读取左子树：利用 `root->left`，读取根节点：`root->val`；
2. 递推式：这里是递归关系。看成一个大问题分解成若干子问题，解决掉最小的子问题，返回解决大问题。
3. 递归结束条件：`curr == nullptr`



```cpp
  class Solution {
  public:
	  int rob(TreeNode* root) {
		  //定义以为一维 memo 用来存放结果
		  //其中，该 result 一共两个值，result[0] 代表不选该节点的最大值.,result [1] 代表选择该节点的最大值
		  //本题解法秒就秒在用两个值就解决了memo 的作用
		  vector<int> result = robTree(root);
		  return max(result[0], result[1]);
	  }
	  vector<int> robTree(TreeNode* curr) {
		  if (curr == nullptr) return { 0 ,0 };
		  vector<int> leftV = robTree(curr->left);
		  vector<int> rightV = robTree(curr->right);
           // 这里之所以带上[0],是为了更新 val1 中的值，以此来做 memo，记录上次的最大值
           // 不选该节点，则就是最大值，选择该节点，则计算结果，下一轮就最大值
		  int val0 = max(leftV[0], leftV[1]) +  max(rightV[0], rightV[1]);
		  int val1 = curr->val + leftV[0] + rightV[0];
		  return { val0,val1 };
	  }
  };
```



+++



##  ------------买卖股票---------

## 4.11 买卖股票的最佳时机

**题目：**给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

原题 3.23 做过贪心算法，此题的最优解也是贪心算法。

**思路：**贪心算法比较直观简答，就不赘述了。对于动态规划算法，按照步骤来

1. 定义`dp[i][0]`代表第 i 天不持有股票的现金；`dp[i][1]` 代表持有股票的现金；

2. `dp[i][0] = max(dp[i - 1][0], -prices[i])`:一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数

3. `dp[i][1]  = max(dp[i - 1][1], dp[i - 1][0] + prices[i])`

   

```cpp
//贪心·算法
class Solution{
public:
    int maxProfit(vector<int> &prices){
        if(prices.size() < 2)
            return 0;
        int profit=0;
        int buy=prices[0];
        for(int i = 1; i < prices.size(); i++){
            buy = min(buy, prices[i]);
            profit = max(profit, prices[i] - buy); 
		}
        return profit;
	}
};
```



```cpp
//动态规划·算法
 //一共 m 个数据，每个数据只需要两个维度， 1（买？）代表持有股票， 0(卖？）代表不持有股票
//给出理解，当取 1  的时候，有买的倾向，取 0 卖的倾向
 class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		
		  vector<vector<int>> dp(m, vector<int>(2));
		  dp[0][0] =0;
		  dp[0][1] = -prices[0];
		  for (int i = 1; i < m; i++) {
			  dp[i][0] = max(dp[i - 1][0], prices[i] + dp[i - 1][1]);
              //昨天买的跟今天买的比较一下谁大（转换成负数，越大绝对值越小）
			  dp[i][1] = max(dp[i - 1][1], -prices[i]);
		  }
		  return dp[m - 1][0];
	  }
  };
```



```cpp
//dp算法·用滚动数组来优化
class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		  //一共 m 个数据，每个数据只需要两个维度， 1 代表选择， 0 代表不选择
		  vector<vector<int>> dp(2, vector<int>(2));
		  dp[0][1] = -prices[0];
		  dp[0][0] = 0;
		  for (int i = 1; i < m; i++) {
			dp[i % 2][1] = max(dp[(i - 1) % 2][1], -prices[i ]);
			dp[i % 2][0] = max(dp[(i - 1) % 2][0], prices[i] + dp[(i - 1) % 2][1]);
		  }
		  return dp[(m - 1) % 2][1];
	  }
  };
```





## 4.11 买卖股票的最佳时机II

**题目：**给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**升级，可以完成不限次交易**

 **可以多次买卖股票，但不能买同一支。**

```cpp
//0 ->不持有股票  1 ->持有股票
//不持有股票分为：之前卖了，或者 今天卖了
//持有股票分为：之前买了 ， 现在买
  class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		  //这样理解：之前买：现在买；之前卖：现在卖
          //dp[i][0]：第 i 天不持有股票的最大价值
          //dp[i][1]：第 i 天持有股票的最大价值
		  vector<vector<int>> dp(m, vector<int>(2));
		  dp[0][0] =0;
		  dp[0][1] = -prices[0];
		  for (int i = 1; i < m; i++) {
              //罗列了所有可能性，每一天都参与计算买入或卖出
			  dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
			  dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
		  }
		  return dp[m - 1][0];
	  }
  };
```



## 4.11 买卖股票的最佳时机III

**题目：**给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**升级，最多可以完成两笔交易**

**解题步骤：**更详细的点[这里](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487244&idx=2&sn=d4cefe597a0d5500adec6bff944c4bf5&scene=21#wechat_redirect)。

1. 定义`dp[i][j]`：第 i 天状态 j 能达到的最大值；其中状态 j 分为 5 个， [0] 代表什么都不做，[1] 代表第 1 次买入，[2] 代表第 1 次卖出，[3] 代表第 2 次买入，[4] 代表第 2 次卖出。

2. 递推式：`dp[i][1] = dp[i - 1][0] - price[i]`，`dp[i][2] = dp[i - 1][1] + price[i]`，`dp[i][3] =  dp[i - 1][2] - price[i]`，`dp[i][4] = dp[i - 1][3] + prices[i]`

   其中 `dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])`，

    `dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])`， 

   `dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])`，

    `dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])`。

3. 赋初值：`dp[0] = 0 , dp[1] = -price[0]，dp[2] = 0，dp[3] = -price[i]，dp[4] = 0`

**解释一下：**

```

达到dp[i][1]状态，有两个具体操作：

操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]
那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？

一定是选最大的，所以 dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);

同理dp[i][2]也有两个操作：

操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]
操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]
所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])

同理可推出剩下状态部分：

dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);

dp数组如何初始化
第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;

第0天做第一次买入的操作，dp[0][1] = -prices[0];

第0天做第一次卖出的操作，这个初始值应该是多少呢？

首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，

从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。

所以dp[0][2] = 0;

第0天第二次买入操作，初始值应该是多少呢？

不用管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：dp[0][3] = -prices[0];

同理第二次卖出初始化dp[0][4] = 0;

确定遍历顺序
从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。


```

```cpp
//供参考的代码、
  class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		  if (m == 0)	 return 0;
		  vector<vector<int>> dp(m, vector<int>(5, 0));
		  dp[0][1] = -prices[0];
		  dp[0][3] = -prices[0];
          //真实现起来，代码逻辑并不难懂
		  for (int i = 1; i < m; i++) {
			  dp[i][0] = dp[i - 1][0];
			  dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
			  dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
			  dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
			  dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
		  }
		  return dp[m - 1][4];
	  }
  };
```



## 4.11 买卖股票的最佳时机IV

**题目：**给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**又升级了，变成最多交易K次。**

==解题思路跟步骤同   最佳时机III==，只是这里更具有通性，限制在 K 次。

```cpp
//每奇数次 都是持有股票，偶数次 都是不持有股票
//所以只需要两个迭代式，memo 容器需要 2 * k 那么大，其中 为了方便定位 2 * k + 1 次，当状态为0 的时候我不选择 用
class Solution {
 public:
	  int maxProfit(int k, vector<int>& prices) {
		  int m = prices.size();
		  if (m == 0) return 0;
           //dp[i][1]：第 i 天持有股票的最大价值 ，即买入股票
           //dp[i][2]：第 i 天不持有股票的最大价值，即卖出股票
		  vector<vector<int>> dp(m, vector<int>(2 * k + 1, 0));
          //将第 0 天的买入都记为负数值，卖出 记为0，以此来初始化
		  for (int j = 1; j < 2 * k; j += 2)  dp[0][j] = -prices[0];
		  for (int i = 1; i < m; i++) {
			  for (int j = 0; j < 2 * k - 1; j += 2) {
				  dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
				  dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
			  }
		  }
		  return dp[m - 1][2 * k];
	  }

  };
```



+++



## 4.12 买卖股票的最佳时机V

**题目：**给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。



**解题步骤：**

1. 定义`dp[i][j]`为第 i 天 j 转态 j 情况下所卖出的最大值；其中 状态 j 有4 个值，[1]-- 买入 ， [2]--卖出，[3]--冷冻期，[4]--过了冷冻期；
2. 递推式：其他的与往常无异，只有一点，当天状态如果是[卖出]的话，只能是当天[卖出]，不能是之前卖出，因为之前卖出，那么今天状态必是 [冷冻期]；
3. 赋初值：与往常一致。

```cpp
  class Solution {
  public:
	  int maxProfit(vector<int>& prices) {
		  int m = prices.size();
		  if (m == 0) return 0;
		  //1-持有 2-未持有 3-冷冻期 4-过冷冻期
		  vector<vector<int>> dp(m, vector<int>(5, 0));
		  dp[0][1] = -prices[0];

		  for (int i = 1; i < m; i++) {
			  //当天持有的转态，则可能是之前买入，或者当天买入
			  dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][4], dp[i - 1][3]) - prices[i]);
			  dp[i][2] = dp[i - 1][1] + prices[i];
			  dp[i][3] = dp[i - 1][2];
			  dp[i][4] = max(dp[i - 1][3], dp[i - 1][4]);
			
		  }
		  //最后返回的一定一个未持有转态，细分为 当天为 冷冻期、过了冷冻期、卖出转态
		  //其中冷冻期跟过了冷冻期本质上价值是一样的，这里都列出来是为了防止给的数据 没有过冷冻期的状态
		  return max(dp[m - 1][3], max(dp[m - 1][4], dp[m - 1][2]));
	  }
  };
```





## 4.12 买卖股票的最佳时机VI

**题目：含手续费**。给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

==与 II 类似，不过是多减去一个fee== 

```cpp
//dp·算法
class Solution {
  public:
	  int maxProfit(vector<int>& prices, int fee) {
		  int m = prices.size();
		  if (m == 0)  return 0;
          //多次交易，不限次数，所以深度为 2 即可
           //dp[i][0]：第 i 天不持有股票的最大价值
           //dp[i][1]：第 i 天持有股票的最大价值
		  vector<vector<int>> dp(m, vector<int>(2,0));
          //正常赋值，并无异常
		  dp[0][1] = -prices[0];
		  for (int i = 1; i < m; i++) {
              //将所有天 依次买入卖出，计算下最大值
			  dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
			  dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
		  }
		  return dp[m - 1][0];
	  }
  };
```



## ------------子序列------------

## 4.12 最长递增子序列

**题目：**给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

**问题：**对于类似于这种题目的逻辑，总是不好厘清，并且总是过于复杂化。要多记几个样式，减轻逻辑负担，减少代码冗

```cpp
//该逻辑值得深敲
class Solution {
  public:
	  int lengthOfLIS(vector<int>& nums) {
		  int m = nums.size();
		  if (m <= 1)	return m;
		  //无论是从哪个位置开始，最小长度都是 1 
           //dp[i]:第 i 个 数的子序列个数
		  vector<int> dp(m, 1);
		  int result = 0;
          //先确定后序位置，在确定前序位置，会方便的多
		  for (int i = 1; i < m ; i++) {
			  for (int j = 0; j < i; j++) {
				  if(nums[i] > nums[j])		dp[i] = max(dp[i], dp[j] + 1)				 	 }
			  result = max(result, dp[i]);
		  }
		  return result;
	  }
  };
```

> 例如：10， 9， 2， 5， 3， 7， 101， 18
>
> 当取到 7 这个值的时候，所能组成的子串有很多个， 7 > 5   7 > 2  7 > 3，所以只需要看 5，2，3所能组成的最长串即可。由之前遍历可知，5 所能组成的最长子串为 2 ，同理 3（2） ，2（1）。故 7 能组成的最长子串为 前面的最长长度  +  1。
>
> ==本质上求组合数。==



+++



## 4.13 最长连续递增序列

**题目：**给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

**相比上面题目，是严格递增的。代码复杂度要少很多。**

```cpp
//dp·算法
class Solution {
  public:
	  int findLengthOfLCIS(vector<int>& nums) {
		  int m = nums.size();
          if(m <= 1) return m;
          //dpp[i] : 下标为 i 的时候，子序列的个数
		  vector<int> dp(m, 1);
		  int result = 0;
          //如果后项比前项大，就记录到 memo 中，自增，选出最大值
		  for (int i = 1; i < m; i++) {
			  if(nums[i] > nums[i - 1])  dp[i] = dp[i - 1] + 1;
			  result = max(dp[i], result);
		  }
		  return result;
	  }
  };
```



```cpp
//贪心·算法 本质上与dp算法一样，只是优化了许多，节省了内存
  class Solution {
  public:
	  int findLengthOfLCIS(vector<int> &nums) {
		  int m = nums.size();
		  if (m <= 1) return 1;
          //定义计数器
		  int count = 1; 
		  int result = 0;
		  for (int i = 1; i < m ; i++) {
              //与上面无异 ，如果后项大于前项，则计数器 自增
			  if (nums[i] > nums[i - 1])   count++;
              //否则，将其置为 1 ，重新开始计算
                  else  count = 1;
			  result = max(result, count);
		  }
		  return result;
	  }
  };
```



## 4.13 最长重复子数组

**题目：**给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。==找相同的地方。==

**相比于上题目，增加了一个维度。上面是对一个数组求最大长度，只需要一个遍历，下面是对两个数组，则需要两个遍历。** <a name='数组'></a>

```cpp
//dp·算法 二维数组
class Solution {
  public:
	  int findLength(vector<int>& nums1, vector<int>& nums2) {
		  int m = nums1.size();
		  int n = nums2.size();
		  if (m == 0 || n == 0) return 0;
		  int result = 0;
		  //这里用下标 1 ，2 会方便很多，所以从 1 开始 共需要 m + 1 个大小
		 //dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，
          //最长重复子数组长度为dp[i][j]。
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
          //依次遍历两个数组， 如果前组的值 = 后组的值，则计数器加 1 ，否则置0
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
				  if(nums1[i - 1] == nums2[j - 1])   
                      dp[i][j] = dp[i - 1][j - 1] + 1;
				  else dp[i][j] = 0;
				  if (dp[i][j] > result) result = dp[i][j];
			  }
		  }
		  return result;
	  }
  };
```



![屏幕截图 2021-04-13 103325](刷题日记.assets/屏幕截图 2021-04-13 103325.png)



```cpp
//dp·算法 滚动数组  
class Solution {
  public:
	  int findLength(vector<int>& nums1, vector<int>& nums2) {
		  int m = nums1.size();
		  int n = nums2.size();
		  if (m == 0 || n == 0) return 0;
		  int result = 0;
           
		  vector<int> dp(n + 1, 0);
		  //因为dp 只与前项的值有关，所以可以用一维数组来简化，记录上次的最大值，更新memo
          //从后向前遍历，避免重复覆盖
		  for (int i = 1; i <= m; i++) {
			  for (int j = n; j > 0; j--) {
                   // 如果两个数组的数相等，则记录 memo，+ 1，否则记为 0
				  if (nums1[i - 1] == nums2[j - 1])  dp[j] = dp[j - 1] + 1;
				  else dp[j] = 0;
				  if (dp[j] > result) result = dp[j];
			  }
		  }
		  return result;
	  }
  };
```







==滑动窗口解释如下图：==

```cpp
//滑动窗口·见具体专题



```



## 4.13 最长公共子序列

**题目：**给定两个字符串 str 1和 str 2，返回这两个字符串的最长公共子序列的长度。==找最大的组合。==

给个dp表格，一看就懂。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ciaqDnJprwv4Stw2Ra0d202BvyjCibf9go5KgAvaQNibF2oYK4CKml9mr0qnmjF0C7unejBREe5icSLAwXrn9XP5dA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```cpp
  class Solution {
  public:
	  int longestCommonSubsequence(string text1, string text2) {
		  int m = text1.size();
		  int n = text2.size();
           //dp[i][j]:下标为 i - 1， j - 1 的两个数组的公共子序列的长度
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
                  //如果相等，则 + 1
				  if (text1[i - 1] == text2[j - 1])  dp[i][j] = dp[i - 1][j - 1] + 1;
                  //否则取前面的最大值
				  else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
			  }
		  }
		  return dp[m][n];
	  }
  };
```



## 4.13 不相交的线

**题目：**我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。以这种方法绘制线条，并返回我们可以绘制的最大连线数。

本质上与最长的公共子序列问题相同。

```cpp
  class Solution {
  public:
	  int maxUncrossedLines(vector<int>& A, vector<int>& B) {
		  int m = A.size();
		  int n = B.size();
          //最长子序列的个数
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
          
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
                  
				  if (A[i - 1] == B[j - 1])
					  dp[i][j] = dp[i - 1][j - 1] + 1;
				  else
					  dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
			  }
		  }
		  return dp[m][n];
	  }
  };
```



## 4.13 判断子序列

**题目：**给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。==只需要删除。==

**思路：** 因为这里只设计到删除，所以可以用上面最长公共子序列的思路来做。看是否为子序列，即看s、t 的最长子序列的长度是否为 t的长度即可。但是要注意，子序列为0，是OK；源序列为 0，不可以。

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
          int m = s.size();
		 int n = t.size();
          if(m == 0)  return true;
          if(n == 0)  return 0;
		  int ret = m > n ? n : m;
          //dp[i][j]: i 和 j 处的子序列的长度
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
				  if (s[i - 1] == t[j - 1])
					  dp[i][j] = dp[i - 1][j - 1] + 1;
				  else
					  dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
			  }
		  }
		  return dp[m][n] == ret;

    }
};
```



**思路2：**编辑距离。

```cpp
  class Solution {
  public:
	  bool isSubsequence(string s, string t) {
		  int m = s.size();
		  int n = t.size();
		  if (m == 0) return 1;
		  if (n == 0) return 0;
          //第 i 、j 处的最长子序列长度
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
                    //如果 i 处 = j 处，则 长度 + 1
                    //否则 该长度 = 上次长度
				  if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
				  else  dp[i][j] = dp[i][j - 1];
			  }
		  }
		  return dp[m][n] == m;
	  }
  };
```



## 4.13 不同子序列

**题目：**给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "A B C D E" 的一个子序列，而 "A EC" 不是）。题目数据保证答案符合 32 位带符号整数范围。

**解题步骤：**

1. 定义`dp[i][j]`：长度为 i 的 s 子串中含有 长度为 j 的子串的个数
2. 递推式：考虑 `s[i - 1] == t[i - 1]`是否使用，当该字符匹配的时候，有两种情况，当该字符为第一次出现跟第n次出现。所以`dp[i][j] =  dp[i - 1][j - 1] + dp[i - 1][j]`，其中前项是该字符匹配的个数，后项为找一下前面 **有此字符** 的个数
3. 初始化：`dp[0][0] = 1 `，空串 s 中含有空串 t 的个数为1。



```cpp
  class Solution {
  public:
	  int numDistinct(string s, string t) {
		  int m = s.size();
		  int n = t.size();
		  if (m < n) return 0;
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1));
          //将所有 s 串为 0 的都置为 0 ， 因为s !=0
          //将所有 t 串为 0 的都置为 1 ， 因为 s 一定包含空串
		  for (int i = 0; i <= m; i++)  dp[i][0] = 1;
		  for (int j = 1; j <= n; j++)  dp[0][j] = 0;
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
                  //如果该位置匹配到了，则有两种情况，其一，该字符为首次出现
                  //其二该字符是第 n 次出现
				  if (s[i - 1] == t[j - 1]) 
                      	dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                  //如果该位置没有匹配到，则记录之前的 memo，向下进行
				  else  dp[i][j] = dp[i - 1][j];
			  }
		  }
		  return dp[m][n];
	  }
  };
```



## 4.13 两个字符串的删除操作

**题目：**给定两个单词 word 1 和 word 2，找到使得 word 1 和 word 2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

思路跟==不同的子序列==一样。具体分析看代码注释。

```cpp
  class Solution {
  public:
	  int minDistance(string word1, string word2) {
		  int m = word1.size();
		  int n = word2.size();
		  //dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。
		  vector<vector<int>> dp(m + 1, vector<int>(n + 1));
          //如果有空串，则次数为 i 或者为 j
		  for (int i = 0; i <= m; i++)  dp[i][0] = i;
		  for (int j = 0; j <= n; j++)  dp[0][j] = j;
         // 当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];
         // 当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：
		//情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1
		//情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1
	//情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2
	//那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：
    //dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
		  for (int i = 1; i <= m; i++) {
			  for (int j = 1; j <= n; j++) {
				  if (word1[i - 1] == word2[j - 1])  dp[i][j] = dp[i - 1][j - 1];
				  else dp[i][j] = min({ dp[i - 1][j] + 1,
                                       dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2 });
			  }
		  }
		  return dp[m][n];
	  }
  };

```



+++



## -------------滑动窗口-------------

## 4.14 最小覆盖子串

**双指针技巧的进阶：滑动窗口技巧**

> 解法步骤：主要是双指针——右指针右移，直到能包含符合的条件；接着左指针右移，直到包含的最小情况出现，接着左移一次，不满足条件后，重复以往，直至尽头。没左移一次要记得更新==memo==。

**题目：**给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 `""` 。

**解题步骤：**

1. 定义4个变量：`left` 和 `right`，用来记录 start ，end 的状态指针；
2. 右指针右移，涵盖条件，接着左指针右移，更新状态，每个题目对应的细节不同，要仔细把握；但一定记得，先添值在判断，先判断后删值；
3. 找出最优解。

```cpp
//给的参考答案，用的 while 循环
//下面有我自己写的个 for 循环（钟爱for循环）^_^
class Solution {
  public:
	  string minWindow(string s, string t) {
		  //哈希表 key：字符， value：个数
		  unordered_map<char, int> need, window;
		  //将 t 中的元素都添加到 need 字典中
		  for (auto e : t)  need[e]++;
		  //cout << need['a'] << endl;
		  int left(0), right(0);  //左右指针
		  int ret = 0;  //
		  int start = 0, len = INT_MAX;
		  while (right < s.size()) {
			  char c = s[right];
			  //这里 right 先 + 1 了，所以数据长度不用 + 1
			  right++;
			  if (need.count(c)) {
				  window[c]++;
				  if (need[c] == window[c])  ret++;
			  }
			  while (ret == need.size()) {
				  if (right - left < len) {
					  start = left;
					  len = right - left;
				  }
				  char d = s[left];
				  left++;
				  if (need.count(d)) {
					  if (window[d] == need[d])  ret--;
					  window[d]--;
				  }
			  }
		  }
		  return len == INT_MAX ? "" : s.substr(start, len + 1);
	  }
  };
```



> `dict[e]++`：e 代表 unordered_map 中的 key 值，`dict[e]` 为value，++，即value 自增。
>
> 判断某key是否存在可以使用map的count方法来间接判定。

```cpp
//for 循环
  class Solution {
  public:
	  string minWindow(string s, string t) {
		  //哈希表 key：字符， value：个数
		  unordered_map<char, int> dict, window;
		  //将 t 中的元素都添加到 need 字典中
          /*
          * dict[e]++：e 代表 unordered_map 中的 key 值，dict[e] 为value，++，即value++
          */
		  for (auto e : t)  dict[e]++;
		  int start = 0, len = INT_MAX;
		  int valid = 0;
		  //先定义 左右指针，右指针先走扩大窗口，左指针后走，缩小窗口
		  int left = 0, right = 0;
		  //先扩大窗口，并且给窗口赋值
		  for (; right < s.size(); right++ ) {
			  //右指针逐个取值
			  char c = s[right];
			  //如果字典中有该元素，那么加入到窗口中，同时有效长度递增
               //当遇到重复的元素的时候，也添加进去，不过 value 则递增
			  if (dict.count(c)) {
				  window[c]++;
                    //只有当字典中的 value 与 窗口中的 value相同时，
                    //说明该元素是第一次加入，则有效长度
				  if (dict[c] == window[c])  valid++;
			  }
			  //当有效长度跟字典长度一致时，即在目标源找到了合适的解，需要缩小窗口
				  for (; valid == dict.size(); left++) {
					  //选取中最小的长度，这里注意，数据长度 = 对应元素下边的差值 + 1
					  if (right - left < len) {
						  start = left ;
						  len = right - left + 1;
					  }
					  //如果字典中在最小长度处找到了该值，则窗口继续缩小，
					  //更新下一个合适的解，进行比较
					  char d = s[left];
					  if (dict.count(d)) {
                           //如果字典中有该元素，那么窗口中一定添加了该元素，
                           //要执行自减运算，保证 窗口中最多允许有 1 个元素
                         //  window[d]--;
                           //当窗口中的 value 跟字典中的 value 相同时，
                           //窗口可以缩小了，有效长度自减
						 if (dict[d] == window[d]) valid--;
                           //这里的语句不能放到前面，因为如果先减了，
                           //则 if 永远不能判断正确
						 window[d]--;
					  }
				  }
		  }
		  return len == INT_MAX ? "" : s.substr(start, len);
	  }
  };

```



## 4.14 字符串排列

**题目：**给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的排列。换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。

**思路：**问题跟最小覆盖子串类似，只不过该子串的排列都是连续的，最小覆盖子串字符可以不是连续的。最终问题转化成求在s 2中是否含有长度、字符等于s 1 的子串。

**解题步骤：**因为比较钟爱 for 循环，所以用 for 写的。

1. 定义左右两个指针，left 、right = 0；
2. 找到右指针移动条件，即往窗口中添加元素；左指针移动条件，即 window 中删掉元素；
3. 找到最优结果，即返回条件。

> 滑动窗口一般解题步骤：
>
> 1. 大体框架类似，定义左右指针，有的题目需要start，len 等状态变量；
> 2. 向字典中添加要求元素，右指针右移条件：向窗口中添加元素；左指针右移：向窗口中删减元素；
> 3. 找到返回条件，即什么时候推出循环，该窗口达到最优解。

```cpp
 class Solution {
  public:
	  bool checkInclusion(string s1, string s2) {
           //定义字典、窗口等哈希表
		  unordered_map<char, int> dict, window;
		  int start = 0;
		  int valid = 0;
           //向字典中添加要求值
		  for (auto e : s1)	 dict[e]++;
           //指针右移
		  for (int left = 0, right = 0; right < s2.size(); right++) {
			  char c = s2[right];
			  if (dict.count(c)) {
                   //向窗口中添加条件值
				  window[c]++;
				  if (window[c] == dict[c]) valid++;
			  }
               //指针左移
			  for (; valid == dict.size(); left++) {
                    //退出循环条件
				  if (right - left  + 1 == s1.size()) return true;
				  char d = s2[left];
				  if (dict.count(d)) {
					  if (dict[d] == window[d])  valid--;
					  window[d]--;
				  }
			  }
		  }
		  return false;
	  }
  };
```



```cpp
//while 循环写法
  class Solution {
  public:
	  bool checkInclusion(string s1, string s2) {
		  //定义字典、窗口等哈希表
		  unordered_map<char, int> dict, window;
		  int start = 0;
		  int left = 0, right = 0;
		  int valid = 0;
		  for (auto e : s1) dict[e]++;
		  while (right < s2.size()) {
			  char c = s2[right];
			  if (dict.count(c)) {
				  window[c]++;
				  if (dict[c] == window[c]) valid++;
			  }
			  while (valid == dict.size()) {
				  char d = s2[left];
				  if (right - left == s1.size())  return true;

				  if (dict.count(d)) {
					  if (dict[d] == window[d])	valid--;
					  window[d]--;
				  }
				  left++;
			  }
			  
			  right++;
		  }
		  return false;
	  }
  };
```



## 4.14 找所有字母异位词

**题目：**给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

**思路：**跟之前的做的题目大同小异，最基本的即使最小覆盖子串，然后本题最相近的是字符串排列。他俩的不同点仅在于该题输出下标，上题输出布尔值。

```cpp
 class Solution {
  public:
	  vector<int> findAnagrams(string s, string p) {
		  unordered_map<char, int> dict, window;
           //用来接收最后的结果
		  vector<int> v;
		  int start = 0, len = s.size();
		  int valid = 0;
           //字典初始化
		  for (auto e : p)  dict[e]++;
		  for (int left = 0, right = 0; right < s.size(); right++) {
			  char c = s[right];
			  if (dict.count(c)) {
				  window[c]++;
				  if (dict[c] == window[c])   valid++;
			  }
			  for (; valid == dict.size(); left++) {
                    //完成要求，如果找到了长度符合的子串，则记录下左指针的值
				  if (right - left + 1 == p.size())		v.push_back(left);
				  char d = s[left];
				  if (dict.count(d)) {
					  if (dict[d] == window[d])  valid--;
					  window[d]--;
				  }
			  }
		  }
		  return v;
	  }
  };
```



## 4.14 最长无重复子串

**题目：**给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**思路：**不含重复字符的最长子串，只能是从每个字符第一次出现的地方开始计数；如果遇到重复字符，那么只能从第一次出现该字符的下一位置重新开始。

```cpp
//例如 abcbe，到碰到第二个b的时候，需要从第一次b出现的地方下一位置重新计数 
class Solution {
  public:
	  int lengthOfLongestSubstring(string s) {
		  unordered_map<char, int> window;
		  int ans = 0;  // memo：用来计算长度
		  for (int left = 0, right = 0; right < s.size(); right++) {
			  char c = s[right];
			  window[c]++;
              //下面这个循环，将重复字符之前的字符全部去掉
              //因为不含重复字符的最长子串只能是从字符第一次出现的地方开始计数
			  for (; window[c] > 1; left++) {
				  char d = s[left];
				  window[d]--;
			  }
			  ans = max(ans, right - left + 1);
		  }
		  return ans;
	  }
  };
```



```cpp
//还可以这么写
  class Solution {
  public:
	  int lengthOfLongestSubstring(string s) {
		  int length = 0;
		  int ans = 0;
		  int index = 0;
		  for (int right = 0; right < s.size(); right++) {
			  char tempChar = s[right];
               //这里注意，必须要给left赋初值
               //left = 重复元素的下一位置开始重新计数
               //如果用left本身计数，会导致一旦没有匹配的字符，left++，无法重置
               //如果 left 从0开始，这不符合要求
			  for (int left = index; left < right; left++) {
				  if (tempChar == s[left]) {
					  index = left + 1;
					  length = right - index;
					  break;
				  } 
			  }
			  length++;
			  ans = max(ans, length); 
		  }
		  return ans;
	  }
  };
```



+++



## 4.15 最长重复子数组

**题目：**给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。[原题](#数组)

如下图分析：

![错开比较.gif](刷题日记.assets/9ed48b9b51214a8bafffcad17356d438b4c969b4999623247278d23f1e43977f-错开比较.gif)

代码如下：

```cpp
  class Solution {
  public:
	  int findLength(vector<int>& nums1, vector<int>& nums2) {
		  return nums1.size() <= nums2.size() ? helper(nums1, nums2) : helper(nums2, nums1);
	  }
	  //后者 > 前者，即 n > m
	  int helper(vector<int> &small, vector<int> &big) {
		  int bigSize = big.size();
		  int smallSize = small.size();
		  int ret = 0;
		  //动的 数组从最右端进入，一直到第一数组结束的地方。
		  for (int len = 1; len <= smallSize; len++) {
			  int templen = maxLen(small, 0, big, bigSize - len, len);
			  ret = max(ret, templen);
		  }
		  //数组在中间过程的时候,这时候B比A大
		  for (int len = bigSize; len >= smallSize; len --) {
			  int templen = maxLen(small, 0, big, len - smallSize, smallSize);
			  ret = max(ret, templen);
		  }
		  //数组出去的时候
		  for (int len = smallSize; len >= 1; len--) {
			  int templen = maxLen(small, smallSize - len, bigSize, 0, len);
			  ret = max(ret, templen);
		  }
		  return ret;
	  }

	  int maxLen(vector<int> &nums1, int index1, vector<int> &nums2, int index2, int len) {
		  int ret = 0;
		  int  count = 0;
		  for (int i = 0; i < len; i++) {
			  //如果有相同的值，则计数器自增
			  if (nums1[index1 + i] == nums2[index2 + i])  count++;
			  //如果有不同的值，则记录最大值，重新开始计数，
			  else if (count > 0) {
				  
				  count = 0;
			  }
			  ret = max(ret, count);
		  }
		  return ret;
	  }
  };
```



## 4.15 尽可能使字符串相等

**题目：**给你两个长度相同的字符串，s 和 t将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。

如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。

**思路：**该窗口只需要从目标处移动即可，符合条件时候，右移；越界了，就左移。

```cpp
  class Solution {
  public:
	  int equalSubstring(string s, string t, int maxCost) {
		  int ans = 0;
		  int cost = 0;  // 用来记录能否满足条件值
		  for (int left = 0, right = 0; right < s.size(); right++) {
			  cost += abs(s[right] - t[right]);
			  //窗口左移，删减掉之前的元素
			  //判断条件是大于条件值的时候才选择左移，等于不移
			  for (; cost > maxCost; left++) {
				  cost -= abs(s[left] - t[left]);
			  }
			  //结果是要保存长度
			  ans = max(ans, right - left + 1);
		  }
		  return ans;
	  }
  };
```



## 4.15 滑动窗口的最大值

**题目：**给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

==具体分析看代码。==

```cpp
//严格意义上来讲，本题跟滑动窗口没有关联  
class Solution {
  public:
	  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		  //用list是因为它可以头删，vector不能头删，
		  //同理，deque也可以头删，下面就用deque来写
		  list<int> window;
		  int  index = 0;
		  vector<int> res(nums.size() - k + 1);
		  for (int right = 0; right < nums.size(); right++) {
			  //因为要求是返回最大值，这里就直接找最大值了，让window中只保存最大值
			  while (!window.empty() && nums[right] > window.back())
                  window.pop_back();
			  //构造window
			  window.push_back(nums[right]);
			  //当窗口构造完成后，每移动一个元素，都要 memo
			  // k 是个数， right是下标，想要比较，就需要right+1
			  if (right + 1 >= k ) {  
				  //将window中 最大值 放进结果容器中
				  res[index++] = window.front();
				  //window左移，保持大小为3
				  if (window.front() == nums[right - k + 1])  window.pop_front();
			  }
			  
		  }
		  return res;
	  }
  };
```



```cpp
//用deque队列来写·思路同上题
 class Solution {
  public:
	  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		  deque<int> window;
		  int index = 0;
		  vector<int> ans(nums.size() - k + 1);
		  for (int right = 0; right < nums.size(); right++) {
			  while (!window.empty() && nums[right] > window.back())
                  window.pop_back();
			  window.push_back(nums[right]);
			  if (right + 1 >= k) {
				  ans[index++] = window.front();
				  if (nums[right - k + 1] == window.front())  window.pop_front();
			  }
		  }
		  return ans;
	  }
  };
```





## 4.15 定长子串中元音的最大数目

**题目：**给你字符串 s 和整数 k 。请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。

**思路：**窗口大小为K，可以仿照上题来写。 

```cpp
  class Solution {
  public:
	  int maxVowels(string s, int k) {
		  int ans = 0;
		  int sum = 0;
		  for (int right = 0; right < s.size(); right++) {
              //如果碰到了元音字母，则计数器 自增
			  sum += helper(s[right]);
              //窗口变大时，要进行左移
			  if (right + 1 >= k) {
                  //结果阶段性的 memo
				  ans = max(sum, ans);
                  //把左侧的元素的结果删减掉，维持窗口
				  sum -= helper(s[right + 1 - k]);
			  }		  
		  }
		  return ans;
	  }
	  int helper(char c) {
		  return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ? 1 : 0;
	  }
  };
```



## ------------双指针---------------

## 4.16 移除元素

**题目**：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

原题在这儿。3.30 移除元素。

> 所谓双指针法，就是建立两个变量，两个变量通过不同的方式、顺序遍历数组，达到目标的方法；
>
> 其中滚动数组、二分法都与双指针，密不可分。

```cpp
  class Solution {
  public:
	  int removeElement(vector<int>& nums, int val) {
          if(nums.size() == 0 || nums.empty())  return 0;
		  int left = 0;
          //右指针（快指针）先行，然后左指针（慢指针）记录 存到meno
		  for (int right = 0; right < nums.size(); right++) {
			  if (nums[right] != val) {
				  nums[left] = nums[right];
				  left++;
			  }
		  }
		  return left;
	  }
	  
  };
```



## 4.16 三数之和

**题目：**给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。==重点 在于如何去重。==

原题在3.27。

```cpp
 class Solution {
  public:
	  vector<vector<int>> threeSum(vector<int>& nums) {
		  vector<vector<int>> ans;
		  sort(nums.begin(), nums.end());
		  for (int i = 0; i < nums.size(); i++) {
			  int val = nums[i];
			 //本题的去重分两步，一个是去掉，目标值为重复的，另一个是去掉答案为重复的
			  //下面的去重，会导致如果只有一个元素，而一次判断也不执行
			  //if (i < nums.size() - 2 &&val == nums[i + 1])	 continue;
			  if (i > 0 && nums[i] == nums[i - 1])  continue;

			  for (int left = i + 1, right = nums.size() - 1; left < right;) {
				  if (-val > nums[left] + nums[right] )  left++;
				  else if (-val < nums[left] + nums[right] )  right--;
				  else {
					  // 去重逻辑应该放在找到一个三元组之后
					  if (-val == nums[right] + nums[left] )
						  ans.push_back({ nums[i],nums[left],nums[right] });
					  //该过程为去重，
					  //当找到答案后，在找到跟答案一样的组合，略过
					  while (left < right && nums[left] == nums[left + 1] ) left++;
					  while (left < right && nums[right] == nums[right-1]) right--;
					  //找到答案后可以同时收缩，因为数组是有序的，
                        //当正好符合条件时，无论单收缩哪个都必不符合答案，故可以同时收缩
					  left++;
					  right--;
				  }
			  }
		  }

		  return  ans;
	  }

  };
```



## 4.16 四数之和

**题目：**题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

**注意：**答案中不可以包含重复的四元组。

原题3.28

==同三数之和类似，思路不难，重在去重。==

```cpp
  class Solution {
  public:
	  vector<vector<int>> fourSum(vector<int>& nums, int target) {
		  vector<vector<int>> ans;
		  sort(nums.begin(), nums.end());
		  
		  for (int i = 0; i < nums.size(); i++) {
              //去重第一层，去掉重复求解过程
			  if (i > 0 && nums[i] == nums[i - 1])	continue;
              //固定第一个值
			  int val0 = nums[i];
			  for (int j = i + 1; j < nums.size(); j++) {
                  //去重第二层，去掉重复求解过程
				  if (j > i + 1 && nums[j] == nums[j - 1])  continue;
                  //固定第二个值
				  int val1 = nums[j];
                  //遍历，找值
				  for (int left = j + 1, right = nums.size() - 1; left < right;) {
					  if (nums[left] + nums[right] > target - val0 - val1)  
                          right--;
					  else if (nums[left] + nums[right] < target - val0 - val1)
                          left++;
					  else {
						  if (nums[left] + nums[right] == target - val0 - val1)
					 ans.push_back({ nums[i],nums[j],nums[left],nums[right] });
                          //去重第三层，去掉重复解
						  while (left < right && nums[left] == nums[left + 1]) 
                              left++;
						  while (left < right && nums[right] == nums[right - 1])
                              right--;
                          //找到合适的解，那么要双指针同时移动
						  left++;
						  right--;
					  }
				  }
			  }
		  }
		  return ans;

	  }
	  
  };
```



## 4.16 反转单链表

**题目：**反转一个单链表。

原题3.23。

> 双指针迭代方法，不是递归方法。迭代：处理完本次循环，进行下一次循环；递归：先处理最小循环。

```cpp
  class Solution {
  public:
	  ListNode* reverseList(ListNode* head) {
		  ListNode *prev = nullptr;
		  ListNode *curr = head;
		  //只要不为空节点，就继续迭代下去
		  //先处理一次，在进行下一次
		  while (curr) {
			  ListNode *temp = curr->next; 
			  curr->next = prev; //指向改变
			  prev = curr;  //前指针后移
			  curr = temp;  //当前指针后移
		  }
		  
	  }
	  
  };
```



## 4.16 环形链表II

**题目：**给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。

如果 pos 是 -1，则在该链表中没有环。

找到相遇的位置，由此位置，到下一次相遇的位置，即是环的入口点。

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv4aFV2OYN4V4oCGSglPhyQMW5uN2KrTcjrnuQJ3qYERliaADMrXdZOr1959GWicQ0w7tTXwwX1bQwDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

> slow指针走过的节点数为: `x + y`， fast指针走过的节点数：`x + y + n (y + z)`
>
> 由等价关系可得：`(x + y) * 2 = x + y + n(y + z)`，`x + y =  (n - 1)(y + z) + y + z`
>
>  `x = (n -1)(y + z) + z`： 即 y + z 是整圈，故 x 只与 z 有关系。

```cpp
  class Solution {
  public:
	  ListNode *detectCycle(ListNode *head) {
		  ListNode *fast = head;
		  ListNode *slow = head;
          //先找环
		  while (fast !=nullptr && fast->next !=nullptr) {
			  fast = fast->next->next;
			  slow = slow->next;
              //找到了环，下面找入口
			  if (fast == slow) {
                  //从相遇的位置，到下一次相遇的地方就是入口
				  ListNode *curr = head;
				  ListNode *prev = fast;
				  while (prev != curr) {
					  prev = prev->next;
					  curr = curr->next;
				  }
				  return curr;
			  }
		  }
		  return nullptr;
	  }
	  
  };
```



+++



## 4.17  反转字符串

**题目：**编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

**思路：**尽量不要使用库函数。使用双指针来解决。

> swap可以有两种实现。
>
> 一种就是常见的交换数值：
>
> ```
> int tmp = s[i];
> s[i] = s[j];
> s[j] = tmp;
> ```
>
> 一种就是通过位运算：
>
> ```
> s[i] ^= s[j];
> s[j] ^= s[i];
> s[i] ^= s[j];
> ```

```cpp

4.//一开始我理解错题目意思了，我以为是反向输出，所以写成了如下：
  class Solution {
  public:
	  void reverseString(vector<char>& s) {
		  int m = s.size();
		  for (int i = 1; i <= m; i++)   cout << s[m - i] << endl;
	  }
  };
//这仅是完成了反向输出，其实本题目的意思是将原有字符串的顺序逆转
//改变原来字符串，如下：
  class Solution {
  public:
	  void reverseString(vector<char>& s) {
		  int m = s.size();
		  for (int left = 0, right = m - 1; left < right; left++, right--)
			  swap(s[left], s[right]);
	  }
  };
//使用库函数，如下：
	reverse(s.begin(),s.end()); 
	for (auto e : s)  cout << e << endl;

```



## 4.17  字符串：替换空格

**题目：**请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

**思路：**空格变成“%20”后，内存空间变大了，所以可以预先申请一个大的数组空间，然后将其依次copy过去。

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ciaqDnJprwv7SRf2YqUnSPt9bfdD5jA9Pliaznlenvr1dtfPibqqSDfRZibqQOtpqEZeVQ5ibwICaokWvNdPOwGaexA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

> **「其实很多==数组填充==类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。」**
>
> 这么做有两个好处：
>
> 1. 不用申请新数组。
> 2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动

```cpp
  class Solution {
  public:
	  string replaceSpace(string s) {
		//先统计空格的个数
		  int  spaceCount = 0;
		  int oldSize = s.size();
		  for (int i = 0; i < s.size(); i++) {
			  if (s[i] == ' ')	 spaceCount++;
		  }
		  //这里实际上是将空格换了三个字符，即比原来多了两个字符
		 s.resize(s.size() + spaceCount * 2);
		 //如果没遇到空格， 就正常copy
		 //遇到空格，则将空格换成需要字符，然后继续copy
		 for (int left = oldSize, right = s.size(); left < right; left--,right--) {
			 if (s[left] != ' ') {
				 s[right] = s[left];
			 } else if (s[left] == ' ') {
				 s[right--] = '0';
				 s[right--] = '2';
				 s[right] = '%';
			 }
		 }
		 return s;
	  }
  };
```



## 4.17 翻转字符串中的单词

**题目：**给定一个字符串，逐个翻转字符串中的每个单词。

**思路：**可以先将整个字符串集体翻转，然后在逐个翻转单词，使之为正序。思路我有，实现不了。

> 与逻辑中，碰到一个 false，则后面的不再执行，直接判 false；
>
> 或逻辑中，碰到一个 true， 则后面的不再执行，直接判 true。

```cpp
 class Solution {
  public:
	  string reverseWords(string s) {
		  removeSpace(s);
		  reverse(s.begin(), s.end());
		  int start = 0; //单词初始位置
		  int end = 0;//单词结束位置
		  bool flag = false;//确定是不是单词区域
           //同时，保证 i - 1 的合理性，且能够从下标 0 的位置开始
		  for (int i = 0; i < s.size(); i++) {
			  //找到非空格部分
			  if ((!flag) || s[i] != ' ' && s[i - 1] == ' ') {
				  start = i;
				  flag = true;
			  }
			  //找到空格部分，做为结束的地方
			  if (flag && s[i] == ' ' && s[i - 1] != ' ') {
				  end = i - 1;
				  flag = false;
				  reverse(s.begin() + start, s.begin() + end + 1);
			  }
			  //字符串最后，不是以空格结尾的，要单独处理
			  if (flag && (i == (s.size() - 1)) && s[i] != ' ') {
				  end = i;
				  flag = false;
				  reverse(s.begin() + start, s.begin() + end + 1);
			  }
		  }
		  return s;
	  }
	  //整个去空格的方法，属实没想到
	  string removeSpace(string &s) {
		  int fast = 0, slow = 0;
		  //去除首空格
		  while (s.size() > 0 && fast < s.size() && s[fast] == ' ')  fast++;
		  //去除中间空格
		  for (; fast < s.size(); fast++) {
			  if (fast > 1 && s[fast - 1] == ' ' && s[fast] == ' ')  continue;
			  else s[slow++] = s[fast];
		  }
		  //去除尾空格
		  //因为在上面循环中，slow最后是执行了 +  1 操作的，所以这里slow不用 +1
		  if (slow > 1 && s[slow - 1] == ' ')  s.resize(slow - 1);
		  else s.resize(slow);
		  return s;
	  }

  };
```



## 4.17 平方数之和

**题目：**给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 a^2^ + b^2^ = c 。

**思路：**从c的算数平方根数开始倒数遍历。

```cpp
//很简单的双指针查找方式
  class Solution {
  public:
	  bool judgeSquareSum(int c) {
		  long sum = 0;
		  for (long left = 0, right = sqrt(c); left <= right; ) {
			  sum = left * left + right * right;
			  if (sum > c)	right--;
			  else if (sum < c) left++;
			  else if (sum == c) return true;
			 
		  }
		  return false;
	  }
  };
```



## 4.17 删除有序数组重复项II

**题目：**给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

**思路：**同其他删除重复项思路，快慢指针。

```cpp
 class Solution {
  public:
	  int removeDuplicates(vector<int>& nums) {
		  int slow = 2, fast = 2;
          if(nums.size() < 2 ) return nums.size();
		  while (fast < nums.size()) {
              //这里比较第 3 个位置 跟第 1 个位置处的元素大小
              //而新数组实际上是从第 3 个位置开始重组
			  if (nums[fast] != nums[slow - 2]) nums[slow++] = nums[fast];
			  fast++;
		  }
		  return slow;
	  }
  };
```





+++

## ------------数组--------------

## 4.18 搜索插入位置

**题目：**给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

```cpp
class Solution {
public:
	int searchInsert(vector<int>& nums, int target) {
		int left = 0, right = nums.size() - 1;
		//找到最后，left 一定是 等于right的，且left一定是向右走，right向左走
		//当不满足条件的时候，right < left, 代表没有找到该元素
		//插入的位置，也就是 right + 1
		while (left <= right) {
			int index = (left + right) >> 1;
			if (nums[index] == target)	return index;
			if (nums[index] > target)  right = index - 1;
			if (nums[index] < target)  left = index + 1;
		}
		return right + 1;
	}
};
```



## 4.18 长度最小的子数组

**题目：**给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

```cpp
class Solution{
public:
	int minSubArrayLen(int s, vector<int>& nums) {
		int res = INT_MAX;
		int n = nums.size();
		int sum = 0;
		//复习滑动窗口，前两天刚刚写过，今天写了双指针，就不会写了
		//窗口是循环，两层循环，先是右侧循环，当右侧到达临界点后，
		//左侧进入循环，到达临界点，右侧继续循环，以此往复
		for (int left = 0, right = 0; right < n; right++) {
			sum +=  nums[right];
			for (; sum >= s; left++) {
				sum -= nums[left];
				res = min(res, right - left + 1);
	
			}
		}
		return res == INT_MAX ? 0 : res;
	}
};
```



## 4.18 螺旋矩阵II

**题目：**给定一个正整数 n，生成一个包含 1 到 n^2^ 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

```cpp
class Solution {
public:
	vector<vector<int>> generateMatrix(int n) {
		//定义用来写矩阵的容器
		vector<vector<int>> res(n, vector<int>(n, 0));
		int x = 0, y = 0; // 定义每循环一个圈的起始位置
		int count = 1; // 用来给矩阵中每一个空格赋值
		int loop = n / 2, mid = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
		int offset = 1;  // 每一圈循环，需要控制每一条边遍历的长度
		while (loop--) { //给的循环数
			int i = x; 
			int j = y;
			
			for (; j < n - offset + x; j++)  res[i][j] = count++;// →	
			for (; i < n - offset + y; i++)  res[i][j] = count++;// ↓		
			for (; j > y; j--) res[i][j] = count++;  //←
			for (; i > x; i--) res[i][j] = count++;  //↑
			x++;
			y++;
			offset += 2;
		}
		if (n % 2 == 1)  res[mid][mid] = count;
		return res;
	}
};
```





+++

## ------------链表----------------



## 4.19 移除链表元素

**题目：**删除链表中等于给定值 val 的所有节点。

**注意：**利用虚拟头指针来实现，会方便很多。但是不能使用**虚头结点**作为中间迭代量，因为那样头节点会一直指向链表的最后位置，导致最后无法返回该链表。

链表里的操作，都需要标记要操作的节点，即用一个临时节点变量来标记。

```cpp
  class Solution {
  public:
	  ListNode* removeElements(ListNode* head, int val) {
		  //定义虚拟头节点，指向真实头节点
		  ListNode *dummyHead = new ListNode(0);
		  dummyHead->next = head;
		  //中间指示变量
		  ListNode *curr = dummyHead;
		  //如果用dummyHead 作为迭代量，会导致dummyHead最后指到结束位置
		  //而无法返回该链表
		  while (curr->next != nullptr) {
			 //检查下个节点的值
			  if (curr->next->val == val) {
				  //标记目标节点
				  ListNode *tmp = curr->next;
				  //跳过目标节点
				  curr->next = curr->next->next;
				  //释放节点内存
				  delete tmp;
			  }else  curr = curr->next;
		  }
		  return dummyHead->next;
	  }
  };
```



```cpp
  //使用一般模式实现该功能
  class Solution {
  public:
	  ListNode* removeElements(ListNode* head, int val) {
		  //删除头节点
		  //用 while的原因是，防止该链表都是统一的元素
		  //且不用判断head->next 的原因是将所有相同的val 都删掉
		  //如果有 head->next != NULL 的话，则会保存最后的元素
		  while (head != NULL && head->val == val) {
			  ListNode *tmp = head;
			  head = head->next;
			  delete tmp;

		  }
		  //删除一般节点
		  ListNode *curr = head;
		  while (curr != NULL && curr->next != NULL) {
			  if (curr->next->val == val) {
				  ListNode *tmp = curr->next;
				  curr->next = curr->next->next;
				  delete tmp;
			  }
			  curr = curr->next;
		  }
		  return head;
	  }
  };
```



## 4.19 设计链表

**题目：**在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```cpp
  class MyLinkedList {
  public:
	  MyLinkedList() {
		 dummyHead = new ListNode(0);
		 size = 0;
	  }

	  int get(int index) {
		  if (index < 0 || index > size - 1)  return -1;
		  ListNode *tmp = dummyHead->next;
		  while (index--) {
			  tmp = tmp->next;
		  }
		  return tmp->val;
	  }

	  void addAtHead(int val) {
		  ListNode *temp = new ListNode(val);
		  //在头位置处插入节点，而不是从头开始生成链表。
		  //所以要更改指向
		  temp->next = dummyHead->next;
		  dummyHead->next = temp;
		  size++;
	  }

	  void addAtTail(int val) {
		  ListNode *temp = new ListNode(val);
		  ListNode *curr = dummyHead;
		  while (curr->next != nullptr) curr = curr->next;
		  curr->next = temp;
		  size++;
	  }

	  //因为加了虚拟头节点，故index 就是链表中的目标元素前面的位置
	  void addAtIndex(int index, int val) {
		  if (index > size)  return;
		  ListNode *temp = new ListNode(val);
		  ListNode *curr = dummyHead;
		  while (index--)  curr = curr->next;
		  temp->next = curr->next;
		  curr->next = temp;
	  }
      
	  //因为加了虚拟头节点，故index 就是链表中的目标元素前面的位置
	  void deleteAtIndex(int index) {
		  ListNode *curr = dummyHead;
		  while (index--) curr = curr->next;
		  //标记要删除的节点
		  ListNode *temp = curr->next;
		  curr->next = curr->next->next;
		  delete temp;
		  size--;
	  }

	  void printfList() {
		  ListNode *curr = dummyHead ->next;
		  while (curr->next != NULL) {
			  curr = curr->next;
			  cout << curr->val ;
		  }
		  cout << endl;
	  }

	  ListNode *dummyHead = new ListNode(0);
	  int size;

  };
```



## 4.19 反转单链表(经典)

递归做法：两种写法。

```cpp
//该递归是看成两个部分，更改来的
class Solution {
  public:
	  ListNode* reverseList(ListNode* head) {
		  ListNode *curr = head;
		  //递归下去
		  if (head == nullptr && head->next == nullptr)  return head;
		  ListNode *newHead = reverseList(head->next);
		  head->next->next = head;
		  head->next = nullptr;
		  return newHead;
	  }
  };
```

> 1->2->3->4->5->NULL，1->2->3->4<-5，而4->NULL，依次，1->2->3<-4<-5，3->NULL，……



```cpp
//该递归是一个一个节点，依次指针指向前指来的  
class Solution {
  public:
    //这里的参数实现了递归功能
	  ListNode *reverse(ListNode *pre, ListNode *curr) {
		  if (curr == NULL) return pre;
		  ListNode *newNext = curr->next;
		  curr->next = pre;
		  return reverse(curr, newNext);
	  }

	  ListNode* reverseList(ListNode* head) {
		  return reverse(NULL, head);
	  }
  };

```

> 1->2->3->4->5->NULL，NULL<-1->2->3->4->5，NULL<-1<-2->3->4->5，NULL<-1<-2<-3->4->5，……



## ----------哈希表------------

## 4.19 有效的字母异位词

**题目：**给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

```cpp
  class Solution {
  public:
	  bool isAnagram(string s, string t) {
		  //备忘录 memo
		  int memo[26] = { 0 };
		  for (auto e : s) memo[e - 'a']++; //将s中的信息添加到memo中
		  for (auto e : t) memo[e - 'a']--; //若t中的信息跟s中一样，则信息清楚
		  for (auto e : memo) {
			  if (e != 0)  return false;
		  }
		  return true;
	  }

  };
```



## 4.19 两个数组的交集

**题目：**给定两个数组，编写一个函数来计算它们的交集。

>  set中find()的用法：s. find() ，查找一个元素，如果容器中不存在该元素，返回值等于s. **end**()

```cpp
 class Solution {
  public:
	  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
          //set 是集合，unorder_set 是无序集合
		  unordered_set<int> dict(nums1.begin(),nums1.end());
		  unordered_set<int> res;
		  for (auto e : nums2) {
              //如果dict中查询到了，就 memo一下
              //这里find用法：s.find() 查找一个元素，如果容器中不存在该元素，返回值等于s.end()
			  if (dict.find(e) != dict.end())  res.insert(e);
		 }
		  return vector<int>(res.begin(), res.end());
	  }
  };
```



## 4.19 快乐数

**题目：**编写一个算法来判断一个数 n 是不是快乐数。

```cpp
  class Solution {
  public:
	  bool isHappy(int n) {
		  unordered_set<int> set;
		  while(1){
			  int num = sumN(n);
			  if (num == 1) return true;
			  // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false
			  //set.find(e) == set.end() 没找到， != 找到了
			  if (set.find(num) != set.end()) return false;
			  else set.insert(num);
			  n = num;
		  } 
		  
	  }
      //计算各个位的平方，且求和
	  int sumN(int n) {
		  int sum = 0;
		  while (n) {
			  int m = n % 10;
			  sum += m * m;
			  n /= 10;
		  }
		  return sum;
	  }
  };
```



+++



## 4.20 两数之和

**题目：**给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

```cpp
  class Solution {
  public:
	  vector<int> twoSum(vector<int>& nums, int target) {
		  //第一个 加数，第二个 加数的下标
		  unordered_map<int, int> memo;
		  for (int i = 0; i < nums.size(); i++) {
              //这里返回的是一个迭代器
			  auto it = memo.find(target - nums[i]);
              //找到了，则返回下标
			  if (it != memo.end())  return { it->second, i };
              //否则，加入memo
			  else memo.insert(make_pair(nums[i], i));
		  }
		  return {};
	  }
  };
```





## 4.20 四数相加

**题目：**给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

```cpp
 class Solution {
  public:
	  int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
          //<元素，出现的次数>
		  unordered_map<int, int> dict;
		  for (auto e : nums1) {
			  for (auto c : nums2) dict[e + c]++;  //想dict中赋值
		  }
		  int count = 0;
		  for (auto e : nums3) {
			  for (auto c : nums4) {
                  //如果找到了相反数，则出现的次数就是组合数
				  auto ite = dict.find(0 - e - c);
				  if (ite != dict.end())  count += ite->second;
			  }
		  }
		  return count;
	  }
  };
```



## 4.20 赎金信

**题目：**给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

```cpp
  class Solution {
  public:
	  bool canConstruct(string ransomNote, string magazine) {
		  unordered_map<char, int> dict;
		  //将结果放入dict中
		  for (auto e : ransomNote)  dict[e]++;
		  //判断目标是否在区域内出现
		  for (auto e : magazine) {
			  if (dict.count(e)) dict[e]--;
		  }
		  //最后，如果有dict中有大于 0 的，则说明区域内不完全包含 目标
		  for (auto it = dict.begin(); it != dict.end();it++	) {
			  if (it->second > 0)  return false;
		  }
		  return true;
	  }
  };
```



```cpp
//一维哈希表·性能提高好多
  class Solution {
  public:
	  bool canConstruct(string ransomNote, string magazine) {
		  int memo[26] = { 0 };
           // 记录 magazine里各个字符出现次数
		  for (auto e : magazine) memo[e - 'a']++;
           for (auto e : ransomNote) memo[e - 'a']--;
           //小于0的时候存在于本身为0，做了自减运算
		  for (auto e : memo) {
			  if (e < 0) return  false;
		  }
		  return true;
	  }
  };
```



+++

## ---------字符串----------

## 4.21 左旋字符串

**题目：**字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

**思路：**跟翻转字符串中的单词类似。先整体翻转，然后在目标处两次翻转。

```cpp
  class Solution {
  public:
	  string reverseLeftWords(string s, int n) {
		  reverse(s.begin(), s.end());  //整体翻转
		  reverse(s.begin() + s.size() - n, s.end());  //前半段翻转
		  reverse(s.begin(), s.begin() + s.size() - n); //后半段翻转
		  return s;
	  }
  };
```



## 4.21 KMP算法

**题目：**给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

KMP算法，具体看[这里](https://blog.csdn.net/weixin_46007276/article/details/104372119?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161898696916780265498132%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161898696916780265498132&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104372119.first_rank_v2_pc_rank_v29&utm_term=KMP%E7%AE%97%E6%B3%95)。

本质上是遇到不匹配的字符的时候，向前回溯，只不过为了提高效率，我们是回溯模式串。文本串的回溯时间复杂度要远远高于模式串，并且通过回溯模式串，找到了更加优化的算法。

```cpp
class Solution {
public:
    //找一下模式串前后缀相等的长度
    void getNext(vector<int> &next, const string& s) {
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++) { // 注意i从1开始
            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
                j = next[j]; // 向前回溯
            }
            if (s[i] == s[j + 1]) { // 找到相同的前后缀
                j++;
            }
            next[i] = j; // 将j（前缀的长度）赋给next[i]
        }
    }
    //匹配字符串
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
         //next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）
        vector<int> next(needle.size());
        getNext(next, needle);
        int j = -1; // // 因为next数组里记录的起始位置为-1
        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始
            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配
                j = next[j]; // j 寻找之前匹配的位置
            }
            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动 
                j++; 
            }
            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t
                return (i - needle.size() + 1); 
            }
        }
        return -1;
    }
};
```



## 4.21 重复的子字符串

**题目：**给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

**思路：**利用KMP算法求得最长的子字符串。

```
最长相等前后缀的长度为：next[len - 1] + 1，
数组长度为：len；
如果len % (len - (next[len - 1] + 1)) == 0 ，则说明 (数组长度-最长相等前后缀的长度) 正好可以被 数组的长度整除，说明有该字符串有重复的子字符串。
```

```cpp
//我们可以发现next[]表前三位（子字符串）都为0，而其后的值都是递增的，
//next[len-1]中存放的就是原字符串减去子字符串长度的值，也即最大相等前后缀长度，记为len2。
//将len-len2的值记为len1。它就是子字符串的长度，是一定可以被len整除的。
  class Solution {
  public:
	  bool repeatedSubstringPattern(string s) {
		  if (s.size() == 0)	 return false;
		  vector<int> next(s.size());
		  getNext(next, s);
		  int len = s.size();
		  //这里的len - (next[len - 1] + 1)是 重复的 子串的长度
		  if (next[len - 1] != -1 && len % (len - (next[len - 1] + 1)) == 0) {
			  return true;
		  }
		  return false;

	  }
	 
	  void getNext(vector<int> &next, const string &t ) {
		  //next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）
		  int j = -1;
		  next[0] = -1; //也可以写作j
		  for (int i = 1; i < t.size(); i++) {
			  while (j >= 0 && t[i] != t[j + 1])   j = next[j];
			  if (t[i] == t[j + 1])  j++;
			  next[i] = j;
		  }
		  for (auto e : next)  cout << e + 1 << endl;
	  }

  };
```

> 同行写代码，可不写{}，但是分行写，一定要加{}。在这里记录一下，往后的习惯全都照此执行！



## ---------栈与队列--------

## 4.21 用栈实现队列

**题目：**使用栈实现队列的下列操作：

```
push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
```

```cpp
class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stk1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    //删除队首的元素
    int pop() {
        if(stk2.empty()){
            while(!stk1.empty()){
                stk2.push(stk1.top());
                stk1.pop(); //stk1 清空
            }
        }
        int result = stk2.top();
        stk2.pop();  
        return result;
    }
    
    /** Get the front element. */
    //返回队首的元素
    int peek() {
        int res = this->pop();
        stk2.push(res);
        return res;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return stk1.empty() && stk2.empty();
    }
    stack<int> stk1;  //用来输入
    stack<int> stk2;  //用来输出
};
```



## 4.21 用队列实现栈

**题目：**

```
使用队列实现栈的下列操作：
push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
```

```cpp
class MyStack {
public:
    queue<int> que1;
    queue<int> que2; // 辅助队列，用来备份
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        que1.push(x);
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int size = que1.size();
        size--;
        while (size--) { // 将que1 导入que2，但要留下最后一个元素
            que2.push(que1.front());
            que1.pop();
        }

        int result = que1.front(); // 留下的最后一个元素就是要返回的值
        que1.pop();
        que1 = que2;            // 再将que2赋值给que1
        while (!que2.empty()) { // 清空que2
            que2.pop();
        }
        return result;
    }

    /** Get the top element. */
    int top() {
        return que1.back();
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return que1.empty();
    }
};
```



## 4.21 有效的括号

**题目：**给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<int> stk;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') stk.push(')');
            else if (s[i] == '{') stk.push('}');
            else if (s[i] == '[') stk.push(']');
            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，
            //没有匹配的字符了，说明右括号没有找到对应的左括号 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。
            //所以return false
            else if (stk.empty() || stk.top() != s[i]) return false;
            else stk.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，
        //说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
        return stk.empty();
    }
};
```



+++



## 4.22 删除字符串中的所有相邻重复项

 **题目：**给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

```cpp
//利用栈写的 
//本质是如果相邻的元素相等，出栈；如果不等，则入栈
class Solution {
  public:
	  string removeDuplicates(string S) {
		  stack<char> stk;
		  for (auto e : S) {
              //若栈不为空且栈顶元素不跟下一个元素相等，则入栈；否则，出栈
			  if (stk.empty() || stk.top() != e)   stk.push(e);
			  else  stk.pop();
		  }
		  string str;
          //将栈中的元素取出来
		  while (!stk.empty()) {
			  str += stk.top();
			  stk.pop();
		  }
          //栈是反向输出的，故需要翻转一下
		  reverse(str.begin(), str.end());
		  return str;
	  }
  };
```



```cpp
//利用栈的思想，实际是用string来实现
//若stk字符串中的最新插入的元素跟下一个元素相同，则尾删；
//若不等，则尾插
  class Solution {
  public:
	  string removeDuplicates(string S) {
		  string stk;
		  for (auto e : S) {
              //不等，尾插；相等，尾删
			  if (stk.empty() || stk.back() != e)   stk.push_back(e);
			  else  stk.pop_back();
		  }
		  return stk;
	  }
  };
```



## 4.22 逆波兰表达式求值

**题目：**根据 逆波兰表示法，求表达式的值。有效的运算符包括 + ,  - ,  *  ,  / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

```cpp
  class Solution {
  public:
	  int evalRPN(vector<string>& tokens) {
		  stack<int> stk;
		  for (auto e : tokens) {
              //遍历字符串，如果碰到符号，则取出前两个数进行运算
			  if (e == "+" || e == "-"   || e == "*" || e == "/") {
				  int res1 = stk.top();
				  stk.pop();
				  int res2 = stk.top();
				  stk.pop();
                    int res;
				  if (e == "+")   res = res1 + res2;
				  if (e == "-")   res = res2 - res1;
				  if (e == "*")   res = res1 * res2;
				  if (e == "/")   res = res2 / res1;
                  stk.push(res);
			//否则入栈
			  } else {
				  stk.push(stoi(e));
			  }
		  }
		  return stk.top();
	  }
  };
```



> `stoi：string to int` ，将字符串风格的转化成int类型，`const  string *` 
>
> `atio：auto to int`，这里是将`const char*`，所以要多一步操作：`e.c_str()`，我们必须调用 c_str()的方法把这个string转换成 `const char*`类型的。



## 4.22 滑动窗口的最大值

**题目：**给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

用==单调队列==实现。

```cpp
//这个跟窗口也没啥关系，只需每次找到最大值即可。
class Solution {
  public:
	  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		  MyQueue q;
		  vector<int> res;
          //窗口元素
		  for (int i = 0; i < k; i++) q.push(nums[i]);
		  res.push_back(q.front());
          //窗口开始移动
		  for (int i = k; i < nums.size(); i++) {
			  q.pop(nums[i - k]);
			  q.push(nums[i]);
			  res.push_back(q.front());
		  }
		  return res;
	  }
  private:
	  class MyQueue {
	  public:
		  deque<int> deq;
          //这里改变窗口大小的操作，当队首的元素跟之前的元素相同，说明窗口是满的，则删掉
		  void pop(int val) {
			  if (!deq.empty() && val == deq.front())  deq.pop_front();
		  }
          //将K个元素中的最大值加入到队列中，并且放在队首
		  void push(int val) {
			  while (!deq.empty() && val > deq.back())  deq.pop_back();
			  deq.push_back(val);
		  }
          //返回队首元素
		  int  front() {
			  return deq.front();
		  }
	  };
  };

```



优先队列。

```cpp
 class Solution {
  public:
	  vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		  int n = nums.size();
          //大顶堆，优先排列大的元素，> （按第一个参数做为优先级）
		  priority_queue<pair<int, int>> q;
          //将元素跟元素下标传入队列
		  for (int i = 0; i < k; i++) {
			  q.emplace(make_pair(nums[i], i));
		  }
		  vector<int> ans = { q.top().first };
		  for (int i = k; i < n; i++) {
			  q.emplace(make_pair(nums[i], i));
              //若下标值出窗了，那么队列中删除
			  while (q.top().second <= i - k) {
				  q.pop();
			  }
			  ans.push_back(q.top().first);
		  }
		  return ans;
	  }
  };
```



## 4.22 前K个高频元素

**题目：**给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

```cpp
// 时间复杂度：O(nlogk)
// 空间复杂度：O(n)
class Solution {
public:
    // 小顶堆，小的在前，故为升序，即greater。
    class mycomparison {
    public:
        //第二个参数做为优先级，这既是小顶堆的定义
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 要统计元素出现频率
        unordered_map<int, int> map; // map<nums[i],对应出现的次数>
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }

        // 对频率排序
        // 定义一个小顶堆，大小为k
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
        
        // 用固定大小为k的小顶堆，扫面所有频率的数值 
        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
            pri_que.push(*it);
             // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
            if (pri_que.size() > k) {
                pri_que.pop();
            }
        }

        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;

    }
};
```



> 小顶堆：队尾4 3 2 1 0 队首，输出为：0 1 2 3 4 升序greater
>
> 大顶堆：队尾0 1 2 3 4 队首，输出为：4 3 2 1 0 降序less

> ```cpp
> static bool cmp(pair<int, int>& m, pair<int, int>& n) {
>         return m.second > n.second;
>     }
> priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);
> ```
>
> ==decltype的用法：==
>
> decltype与auto关键字一样，用于进行编译时类型推导。
>         decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型，例如：
>
> ```cpp
> int x = 3;  
> decltype(x) y = x;
> ```

> **遍历map：**
>
> ```cpp
> for(auto e : map){//这里的 e 就是对组的形式：（1,3）（2，2）
> }
> ```
>
> 



## -------------二叉树--------------

## 4.22 二叉树的遍历

**题目：**如题，深度优先。

- 递归法

```cpp
//前序遍历·中左右，∠
 class Solution {
  public:
	  vector<int> preorderTraversal(TreeNode* root) {
		  vector<int> res;
           traversalPRE(root, res); //前序
		  traversalMID(root, res); //中序
		  traversalLAT(root, res); //后序
           return res;
	  }
	  void traversalPRE(TreeNode *curr, vector<int> &v) {
		  if (curr == NULL) return;
		  v.push_back(curr->val);
		  traversalPRE(curr->left, v);
		  traversalPRE(curr->right, v);
	  }
	  void traversalMID(TreeNode *curr, vector<int> &v) {
		  if (curr == NULL) return;
		  traversalMID(curr->left, v);
		  v.push_back(curr->val);
		  traversalMID(curr->right, v);
	  }
	  void traversalLAT(TreeNode *curr, vector<int> &v) {
		  if (curr == NULL) return;
		  traversalLAT(curr->left, v);
		  traversalLAT(curr->right, v);
		  v.push_back(curr->val);
	  }
  };

```



- 迭代法

  **前序遍历：**

```cpp
//前序遍历
  class Solution {
  public:
	  vector<int> preorderTraversal(TreeNode* root) {
		  stack<TreeNode*> stk;
		  if (root != NULL) stk.push(root);
		  vector<int> res;
		  while (!stk.empty()) {
			  TreeNode* curr = stk.top(); //节点
			  stk.pop();
			  if(curr != NULL) res.push_back(curr->val);
			  
			  if (curr->right) stk.push(curr->right);  //先放右子树，因为它后出
			  if (curr->left)  stk.push(curr->left);   //后放左子树，让它先出
		  }
		  return res;
	  }
  };

```



**中序遍历：**

先入根节点，然后一路遍历左子树的左节点，直到最深处，添加左节点的值；

接着回退上一节点的右子树，将右子树的值添加到结果集中，依次下去。

```cpp
//中序遍历

  class Solution {
  public:
	  vector<int> preorderTraversal(TreeNode* root) {
		  stack<TreeNode*> stk;
		  if (root != NULL) stk.push(root);
		  vector<int> res;
		  TreeNode* curr = root;
		  stk.pop();
		  while (curr != NULL || !stk.empty()) {
			  if (curr != NULL) {
				  stk.push(curr);
				  curr = curr->left;
			  } else {
				  curr = stk.top();
				  stk.pop();
				  res.push_back(curr->val);
				  curr = curr->right;
			  }
		  }
		  return res;
	  }
  };

```



**后序遍历：**

后序遍历的顺序是，左右中，所以可以将出栈顺序调整成 中右左，最后翻转一下即可。

至于为什么要这样，因为我们每次都是先从该节点（根）开始向下搜寻左、右节点的。

故 中 是最先出栈的。

```cpp
//后序遍历
  class Solution {
  public:
	  vector<int> preorderTraversal(TreeNode* root) {
		  stack<TreeNode*> stk;
		  if (root != NULL) stk.push(root);
		  vector<int> res;
		  while (!stk.empty()) {
			  TreeNode* curr = stk.top(); //节点
			  stk.pop();
			  res.push_back(curr->val);
			  if (curr->left)  stk.push(curr->left);   
			  if (curr->right) stk.push(curr->right);  
			 
		  }
		  reverse(res.begin(), res.end());
		  return res;
	  }
  };
```



+++

## 4.23 前中后序迭代统一写法

**题目：**如题，深度优先。

```cpp
//中序遍历·先存放左子树的内容，将左子树的内容取出后，在存放右子树的内容。
  class Solution {
  public:
	  vector<int> inorderTraversal(TreeNode* root) {
		  vector<int> res;
		  stack<TreeNode*> stk;
		  if (root != NULL) stk.push(root);
		  while (!stk.empty()) {
			  TreeNode *curr = stk.top();
			  if (curr != NULL) {
				  stk.pop(); //将该节点弹出，因为要形成左节点，根节点，右节点的顺序
				  if (curr->right) stk.push(curr->right);  //将右节点添加进去
				  stk.push(curr);   //根节点
				  stk.push(NULL);   //在读出的每个节点后面都加上NULL，方便操作
				  if (curr->left) stk.push(curr->left);  //左节点
			  } else {          //当遇到空节点的时候，才将下一个节点放入结果集
				  stk.pop();   //弹出空节点
				  curr = stk.top();  //获取该节点
				  stk.pop();         //弹出该节点
				  res.push_back(curr->val);  //获取该值
			  }
		  }
		  return res;
	  }
  };
```



```cpp
//前序遍历·更改两条语句顺序，先放入右节点，然后是中节点，最后是左节点
  class Solution {
  public:
	  vector<int> inorderTraversal(TreeNode* root) {
		  vector<int> res;
		  stack<TreeNode*> stk;
		  if (root != NULL) stk.push(root);
		  while (!stk.empty()) {
			  TreeNode *curr = stk.top();
			  if (curr != NULL) {
				  stk.pop(); //将该节点弹出，因为要形成左节点，根节点，右节点的顺序
				  if (curr->right) stk.push(curr->right);  //将右节点添加进去
                   if (curr->left) stk.push(curr->left);  //左节点
				  stk.push(curr);   //根节点
				  stk.push(NULL);   //在读出的每个节点后面都加上NULL，方便操作
				 
			  } else {          //当遇到空节点的时候，才将下一个节点放入结果集
				  stk.pop();   //弹出空节点
				  curr = stk.top();  //获取该节点
				  stk.pop();         //弹出该节点
				  res.push_back(curr->val);  //获取该值
			  }
		  }
		  return res;
	  }
  };
```



```cpp
//后序遍历·更改顺序为：左节点，右节点，中节点
 class Solution {
  public:
	  vector<int> inorderTraversal(TreeNode* root) {
		  vector<int> res;
		  stack<TreeNode*> stk;
		  if (root != NULL) stk.push(root);
		  while (!stk.empty()) {
			  TreeNode *curr = stk.top();
			  if (curr != NULL) {
				  stk.pop(); //将该节点弹出
				  
				  stk.push(curr);   //根节点
				  stk.push(NULL);   //在读出的每个节点后面都加上NULL，方便操作
                   if (curr->right) stk.push(curr->right);  //将右节点添加进去
                   if (curr->left) stk.push(curr->left);  //左节点
				 
			  } else {          //当遇到空节点的时候，才将下一个节点放入结果集
				  stk.pop();   //弹出空节点
				  curr = stk.top();  //获取该节点
				  stk.pop();         //弹出该节点
				  res.push_back(curr->val);  //获取该值
			  }
		  }
		  return res;
	  }
  };
```



## 4.23 层序遍历

**题目：**如题，广度优先，自上而下。

```cpp
  class Solution {
  public:
	  vector<vector<int>> levelOrder(TreeNode* root) {
          //新建一个队列，先进先出，正好能实现广度优先的条件
		  queue<TreeNode *> que;  
		  vector<vector<int>> res;
		  if (root != NULL) que.push(root);
		  while (!que.empty()) {
			  vector<int> vec;  //存储下一层的值
			  int size = que.size();
              //这里的size不能写成que.size()，因为下面que尾插后，容量就变了
              //会导致该循环一直进行，不能退出
			  for (int i = 0; i < size; i++) {
                  //将队列的头元素取出来，加到结果集中，删掉，如此往复。
				  TreeNode *curr = que.front();
				  que.pop();
				  vec.push_back(curr->val);
				  if (curr->left)  que.push(curr->left);
				  if (curr->right) que.push(curr->right);
			  }
			  res.push_back(vec);
		  }
		  return res;
	  }
  };
```



## 4.23 层次遍历II

**题目：**如题，广度优先，自下而上。

**思路：**将上题最后的结果反转一下即可。

```cpp
 class Solution {
  public:
	  vector<vector<int>> levelOrder(TreeNode* root) {
          //新建一个队列，先进先出，正好能实现广度优先的条件
		  queue<TreeNode *> que;  
		  vector<vector<int>> res;
		  if (root != NULL) que.push(root);
		  while (!que.empty()) {
			  vector<int> vec;  //存储下一层的值
			  int size = que.size();
              //这里的size不能写成que.size()，因为下面que尾插后，容量就变了
              //会导致该循环一直进行，不能退出
			  for (int i = 0; i < size; i++) {
                  //将队列的头元素取出来，加到结果集中，删掉，如此往复。
				  TreeNode *curr = que.front();
				  que.pop();
				  vec.push_back(curr->val);
				  if (curr->left)  que.push(curr->left);
				  if (curr->right) que.push(curr->right);
			  }
			  res.push_back(vec);
		  }
           reverse(res.begin(), res.end());
		  return res;
	  }
  };
```



## 4.23 右视图

**题目：**给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。即只返回最右侧的值。

**思路：**返回仅右子树（的右子树）的值，采用层序遍历，不需要遍历左子树即可。

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        //这个循环利用的是每层遍历的时候，将需要的元素放在队首
        //然后每层循环开始前，将其加入到结果集中
        //队列中依旧是添加了每层的所有元素
        while(!que.empty()){
            int size = que.size();
            //结果集中只添加先进去的 右子树，即right
            res.push_back(que.front()->val);
            //这个循环，将每层的数据都遍历了，且都在队列中
            while(size--){
                TreeNode* curr = que.front();
                que.pop();
                if (curr->right)  que.push(curr->right);
                if (curr->left)   que.push(curr->left);
            }
        }
        return res;
    }
};
```



```cpp
//另一种写法
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            //跟层序遍历差距不大
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                // 将每一层的最后元素放入result数组中
                if (i == (size - 1)) result.push_back(node->val); 
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```



自己也写了一个来着，想着只添加右子树的值进去，后来中午来的路上想到，从最右边看过去，看到也可能是左子树的内容，适应于没有右子树的情况。故删掉。



> 要遍历所有数据，则在循环中添加到结果集中；要遍历特殊数据，就在循环外添加数据。



## 4.23 层平均值

**题目：**给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

**思路：**层序遍历后，求平均值。

```cpp
  class Solution {
  public:
	  vector<double> averageOfLevels(TreeNode* root) {
		  queue<TreeNode *> que;
		  vector<double> res;
		  if (root != NULL) que.push(root);
		  while (!que.empty()) {
			  int size = que.size();
			  //这里的size不能写成que.size()，因为下面que尾插后，容量就变了
			  //会导致该循环一直进行，不能退出
			  double sum = 0;
              //这里不能用while，因为后面要做 /size 的运算，size的值不能改变
			 for(int i = 0; i < size; i++){
				  //将队列的头元素取出来，加到结果集中，删掉，如此往复。
				  TreeNode *curr = que.front();
				  que.pop();
				  sum += curr->val;
				  if (curr->left)  que.push(curr->left);
				  if (curr->right) que.push(curr->right);
			  }
			  res.push_back(sum / size);
		  }
		  return res;
	  }
  };
```



## 4.23 N叉树的层序遍历

**题目：**如题，与二叉树的区别是，二叉树最多只有两个子节点，而N叉树最多有N个子节点。故最后添加到队列中的时候，需要判断子节点的个数。

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node *> que;  
		  vector<vector<int>> res;
		  if (root != NULL) que.push(root);
		  while (!que.empty()) {
			  vector<int> vec;  //存储下一层的值
			  int size = que.size();
              //这里的size不能写成que.size()，因为下面que尾插后，容量就变了
              //会导致该循环一直进行，不能退出
			  for (int i = 0; i < size; i++) {
                  //将队列的头元素取出来，加到结果集中，删掉，如此往复。
				  Node *curr = que.front();
				  que.pop();
				  vec.push_back(curr->val);
                   //此循环是要添加所有子节点到队列中
				  for(int j = 0; j < curr->children.size(); j++){
                      if(curr->children[j])  que.push(curr->children[j]);
                  }
			  }
			  res.push_back(vec);
		  }
		  return res;
    }
};
```



## 4.23 在每个树行中找最大值

**题目：**需要在二叉树的每一行中找到最大的值。

```cpp
//利用层序遍历，稍作修改，求最大值
class Solution {
  public:
	  vector<int> largestValues(TreeNode* root) {
		  queue<TreeNode *> que;
		  if (root != NULL) que.push(root);
		  vector<int> res;
		  while (!que.empty()) {
			  int maxVal = INT_MIN;
			  int size = que.size();
			  while (size--) {
				  TreeNode *curr = que.front();
				  que.pop();
                   
				  maxVal =max(maxVal, curr->val);  //加了这行代码
				  if (curr->left) que.push(curr->left);
				  if (curr->right) que.push(curr->right);

			  }
			  res.push_back(maxVal);
		  }
		  return res;
	  }
  };
```



## 4.23 翻转二叉树

**题目：**如题，将其左右翻转。

**本节如有看不懂的代码，建议去翻看前面几个基础遍历知识点。**

**方式一：递归方式**

```cpp
//利用swap(left,right)来进行翻转  
class Solution {
  public:
	  TreeNode* invertTree(TreeNode* root) {
		  if (root == NULL)  return root;
		  invertTree(root->left);
		  invertTree(root->right);
		  swap(root->left, root->right);
		  return root;
	  }
  };

//自己实现swap功能
  class Solution {
  public:
	  TreeNode* invertTree(TreeNode* root) {
		  if (root == NULL)  return root;

		  TreeNode *leftTree = invertTree(root->left);
		  TreeNode *rightTree = invertTree(root->right);
          //更改root的指向，左子树变成右子树的内容，右子树变成左子树的内容
		  root->right = leftTree;
		  root->left = rightTree;

		  return root;
	  }
  };
```



**方式二：迭代法**

```cpp
//以前序遍历为例·栈
//这里注意中序遍历不可以，是因为中序遍历的时候，先入右子树，然后根节点，最后左子树，
//多一个if判断处理，故不选择用中序遍历，这回导致某些个节点会翻转两次
  class Solution {
  public:
	  TreeNode* invertTree(TreeNode* root) {
		  if (root == NULL)  return root;

		  stack<TreeNode*> stk;
		  stk.push(root);
		  while (!stk.empty()) {
			  TreeNode* curr = stk.top();
			  stk.pop();
			  swap(curr->left, curr->right);
			  if (curr->left) stk.push(curr->left);
			  if (curr->right) stk.push(curr->right);
		  }

		  return root;
	  }
  };

//统一的迭代写法·以前序遍历为例
  class Solution {
  public:
	  TreeNode* invertTree(TreeNode* root) {
		  if (root == NULL)  return root;

		  stack<TreeNode*> stk;
		  stk.push(root);
		  while (!stk.empty()) {
			  TreeNode* curr = stk.top();
			  if (curr != NULL) {
				  stk.pop();
				  if (curr->right) stk.push(curr->right);
				  if (curr->left) stk.push(curr->left);
				  stk.push(curr);
				  stk.push(NULL);
			  } else {
				  stk.pop();
				  curr = stk.top();
				  stk.pop();
				  swap(curr->left, curr->right);
			  }
		  }

		  return root;
	  }
  };
```



**方式三：层序遍历**

```cpp
//层序遍历
  class Solution {
  public:
	  TreeNode* invertTree(TreeNode* root) {
		  if (root == NULL)  return root;

		  queue<TreeNode*> que;
		  que.push(root);
		  while (!que.empty()) {
			  int size = que.size();
			  while (size--) {
				  TreeNode* curr = que.front();
				  que.pop();
				  swap(curr->left, curr->right);
				  if (curr->left)  que.push(curr->left);
				  if (curr->right)  que.push(curr->right);
			  }
		  }

		  return root;
	  }
  };
```



## 4.23 对称二叉树

**题目：**检查二叉树是否是对称的。

**递归做法：**

```cpp
//分开比较，左子树的左节点值跟右子树的右节点值是否相等 
class Solution {
  public:
	  bool compare(TreeNode* leftTree, TreeNode* rightTree) {
		  if (leftTree == NULL && rightTree != NULL) return false;
		  else if (leftTree != NULL && rightTree == NULL) return false;
		  else if (leftTree == NULL && rightTree == NULL) return true;
		  else if (leftTree->val != rightTree->val)  return false;
		  
		  bool outside = compare(leftTree->left, rightTree->right);
		  bool inside = compare(leftTree->right, rightTree->left);
		  bool isSame = outside && inside;
		  return isSame;
	  }
	  bool isSymmetric(TreeNode* root) {
		  if (root == NULL) return true;
		  return compare(root->left, root->right);
	  }
  };
```



**迭代做法：队列**

```cpp
 //在队列中，依次加入要比较的值进行比较
class Solution {
  public:
	  bool isSymmetric(TreeNode* root) {
		  if (root == NULL) return true;
		  queue<TreeNode*> que;
          //加入要比较的值
		  que.push(root->left);
		  que.push(root->right);
		  while (!que.empty()) {
              //将要比较的值取出
			  TreeNode* leftTree = que.front();
			  que.pop();
			  TreeNode* rightTree = que.front();
			  que.pop();
			  if (!leftTree && !rightTree) continue;
			  else if (leftTree == NULL || rightTree == NULL) return false;
			  else if (leftTree->val != rightTree->val) return false;
              //继续比较
			  que.push(leftTree->left);
			  que.push(rightTree->right);
			  que.push(leftTree->right);
			  que.push(rightTree->left);
		  }
		  return true;
	  }
  };
```



**迭代做法：栈**

```cpp
  class Solution {
  public:
	 //将队列容器改成栈即可，因为只是比较相邻的两个值，栈或者队列无大异
	  bool isSymmetric(TreeNode* root) {
		  if (root == NULL) return true;
		  stack<TreeNode*> stk;
		  stk.push(root->left);
		  stk.push(root->right);
		  while (!stk.empty()) {
			  TreeNode* leftTree = stk.top();
			  stk.pop();
			  TreeNode* rightTree = stk.top();
			  stk.pop();
			  if (!leftTree && !rightTree) continue;
			  else if (leftTree == NULL || rightTree == NULL) return false;
			  else if (leftTree->val != rightTree->val) return false;
			  stk.push(leftTree->left);
			  stk.push(rightTree->right);
			  stk.push(leftTree->right);
			  stk.push(rightTree->left);
		  }
		  return true;
	  }
  };
```



+++

## 4.24 二叉树的最大深度

**题目：**给定一个二叉树，找出其最大深度。

**二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。**

**说明:** 叶子节点是指没有子节点的节点。

```cpp
//很简单的递归写法  
class Solution {
  public:
	  int maxDepth(TreeNode* root) {
		  return getDepth(root);

	  }
	  int getDepth(TreeNode* curr) {
		  if (curr == NULL) return 0;  //结束条件
          //递归求解
 		  int leftLength = getDepth(curr->left);  
		  int rightLengh = getDepth(curr->right);
		  int ret = max(leftLength, rightLengh) + 1;
		  return ret;
	  }
  };
```



**迭代做法：**

```cpp
//利用层序遍历，来实现该功能 
class Solution {
  public:
	  int maxDepth(TreeNode* root) {
		  queue<TreeNode*> que;
		  if (root != NULL)  que.push(root);
		  int depth = 0;  // 用来记录层数
		  while (!que.empty()) {
			  int size = que.size();
			  while (size--) {
				  TreeNode* curr = que.front();
				  que.pop();
				  if (curr->left) que.push(curr->left);
				  if (curr->right) que.push(curr->right);
			  }
              //每当遍历完一层后，计数加一
			  depth++; 
		  }
		  return depth;
	  }
  };
```



## 4.24 N叉树的最大深度

**题目：**给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

**思路：**跟二叉树的最大深度思路类似，利用层序遍历计算层数，或者利用递归都可以实现。

**递归做法：**

```cpp
//N叉树就是拥有N个子节点，二叉树只有左右两个节点，故不用循环，直接罗列出来是最简单的
//而N叉树就要用到循环来遍历他的子节点
class Solution {
public:
    int maxDepth(Node* root) {
        return getDepth(root);
    }
    int getDepth(Node* curr){
        if(curr == NULL)  return 0;
        int depth = 0;
        for(int i = 0; i < curr->children.size(); i++){
            depth = max(depth, getDepth(curr->children[i]));
        }
        return depth + 1;
    }
};
```



**迭代做法：**

```cpp
//跟上面一样，记录每层的层数
class Solution {
public:
    int maxDepth(Node* root) {
      queue<Node*> que;
      if(root != NULL) que.push(root);
      int depth = 0;
      while(!que.empty()){
          int size = que.size();
          while(size--){
              Node* curr = que.front();
               que.pop();
              //唯一的区别在这里，每个子节点的个数未知，所以要用循环来遍历
              for(int i = 0; i < curr->children.size(); i++){
                  if(curr->children[i])  que.push(curr->children[i]);
              }

            }
            depth++;
      }
      return depth;
    }
};
```



## 4.24 二叉树的最小深度

**题目：**给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

**思路：**与最大深度类似，注意区别。

**递归做法：**

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
    int getDepth(TreeNode* curr){
        if(curr == NULL)  return 0;
        int leftDepth = getDepth(curr->left);
        int rightDepth = getDepth(curr->right);
        //当左右节点为空的时候，就返回另一个节点，但长度要 +1
        //求最小值
        if(curr->left == NULL && curr->right != NULL)   return rightDepth + 1;
        if(curr->right == NULL && curr->left != NULL)   return leftDepth + 1;
        return min(leftDepth, rightDepth) + 1;
    }
};
```



**迭代做法：**

```cpp
//因为要找最小深度，所以不必要都遍历，只需要遍历到我们需要的地方，设置标志位退出即可
class Solution {
public:
    int minDepth(TreeNode* root) {
        queue<TreeNode*> que;
        if(root != NULL)  que.push(root);
        int depth = 0;
        while(!que.empty()){
            int size = que.size();
            int flag = 0;  //设置标志位，当满足找到最小深度的时候退出
            while(size--){
                TreeNode* curr = que.front();
                que.pop();
                if(curr->left)  que.push(curr->left);
                if(curr->right)  que.push(curr->right);
                //当左右为为空节点的时候，这时候为最小值，要退出
                if(!curr->left && !curr->right){
                    flag = 1;
                    break;
                }
            }
            depth++;
            if(flag == 1)  break;
        }
        return depth;
    }
};
```



## 4.24 完全二叉树的节点个数

**题目：**给出一个完全二叉树，求出该树的节点个数。

**递归做法：**

```cpp
//每个节点的个数都是 1 ，依次相加起来即可
class Solution {
public:
    int countNodes(TreeNode* root) {
        return getNodeSum(root);
    }
    int getNodeSum(TreeNode* curr){
        if(curr == NULL)  return 0;
        int leftNum = getNodeSum(curr->left);
        int rightNum = getNodeSum(curr->right);
        return leftNum + rightNum + 1;
    }
};
//精简写法
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == NULL)  return 0;
        return 1 + countNodes(curr->left) + countNodes(curr->right);
    }
};
```



**迭代做法：**

```cpp
//层序遍历每个节点，计数器 + 1
class Solution {
public:
    int countNodes(TreeNode* root) {
       queue<TreeNode*> que;
       if(root != NULL)  que.push(root);
       int sum = 0;
       while(!que.empty()){
           int size = que.size();
           while(size--){
               TreeNode* curr = que.front();
               sum++;
               que.pop();
               if(curr->left) que.push(curr->left);
               if(curr->right) que.push(curr->right);
           }
       }
       return sum;
    }
};
```



## 4.24 平衡二叉树

**题目：**给定一个二叉树，判断它是否是每个节点 的左右两个子树的高度差的绝对值不超过 1 。

**这里强调一波概念：**

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

```cpp
//分别求出左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，
//否则则返回-1，表示已经不满足要求。
//本题只要看最后是否等于 -1 即可，满足这个标志，则不平衡
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return getDepth(root) == -1 ? false : true;
    }
    int getDepth(TreeNode* curr){
        if(curr == NULL)  return 0;
        int leftDepth = getDepth(curr->left);
        //如果不满足要求，则返回 -1
        if(leftDepth == -1)  return -1;
        int rightDepth = getDepth(curr->right);
        if(rightDepth == -1) return -1;
        //最后的max() 是为了参与下一次迭代 计算abs()
        return abs(leftDepth - rightDepth) > 1 ? -1 : 1 + max(leftDepth, rightDepth); 
    }
};
```



## 4.24 二叉树的所有路径

**题目：**给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

**递归做法：**

```cpp
  class Solution {
  public:
	  vector<string> binaryTreePaths(TreeNode* root) {
		  vector<int> path;
		  vector<string> res;
		  if (root == NULL) return res;
		  traversal(root, path, res);
		  return res;
	  }
  private:
      //这里的 path，如果不采用递归方式，只是简单实现的话，不加 & 是没有关系的
      //但是递归要循环的用 path的空间，故不能新开辟空间，只能对源地址进行操作
	  void traversal(TreeNode* curr, vector<int>& path, vector<string>& result) {
		  path.push_back(curr->val); 
		  //这里拼接 n 个节点，只需要 n-1 g个 ->
		  if (curr->left == NULL && curr->right == NULL) {
			  string sPath;
			  for (int i = 0; i < path.size() - 1; i++) {
				  sPath += to_string(path[i]);
				  sPath += "->";
			  }
			  sPath += to_string(path[path.size() - 1]);
			  result.push_back(sPath);
			  return;
		  }
		  //由上面的节点，在左子树中找所有的路径
		  if (curr->left) {
			  traversal(curr->left, path, result);
			  //然后删掉该条路径，保留子节点
			  path.pop_back();
		  }
		  //由上个子节点，在右子树中找所有的路径
		  if (curr->right) {
			  traversal(curr->right, path, result);
			  //然后删掉该路径，继续向下寻找
			  path.pop_back();
		  }
	  }
  };
```



**迭代做法：**

```cpp
 class Solution {
  public:
	  vector<string> binaryTreePaths(TreeNode* root) {
		  stack<TreeNode*> tree; //遍历用的
		  stack<string> path;  //记录路径
		  vector<string> res;  //存放结果
		  if (root == NULL)  return res;
		  path.push(to_string(root->val));
		  tree.push(root);
		  while (!tree.empty()) {
			  TreeNode* curr = tree.top();
			  tree.pop();
			  string pth = path.top();  //用来组装路径
			  path.pop();
			  //遇到叶子节点就添加到结果集中
			  if (curr->left == NULL && curr->right == NULL) {
				  res.push_back(pth);
			  }
			  //遇到子节点开始组装路径
			  if (curr->right) {
				  tree.push(curr->right);
				  path.push(pth + "->" + to_string(curr->right->val));
			  }
			  //遇到子节点开始组装路径
			  if (curr->left) {
				  tree.push(curr->left);
				  path.push(pth + "->" + to_string(curr->left->val));
			  }
		  }
		  return res;

	  }
  };
```



## 4.24 相同的树

**题目：**给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**思路：**同对称二叉树的而实现方法类似。

```cpp
//相同的思路
//递归做法
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p && !q)  return  true;
        return compare(p,q);    
    }
    bool compare(TreeNode* p, TreeNode* q){
        if(p == NULL && q != NULL)  return false;
        else if(p != NULL && q == NULL)  return false;
        else if(p == NULL && q == NULL)  return true;
        else if(p->val != q->val)  return false;
        bool leftTree = compare(q->left, p->left);
        bool rightTree = compare(p->right, q->right);
        bool res = leftTree && rightTree;
        return res;

    }
};
//迭代做法·队列
class Solution {
public:

    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == NULL && q == NULL) return true;
        if (p == NULL || q == NULL) return false;
        queue<TreeNode*> que;
        que.push(p);   
        que.push(q);  
        while (!que.empty()) {  
            TreeNode* leftNode = que.front(); 
            que.pop();
            TreeNode* rightNode = que.front(); 
            que.pop();
            if (!leftNode && !rightNode)  continue;
            if (!leftNode || !rightNode) return false;
            if(leftNode->val != rightNode->val)  return false;
            // 相对于求对称二叉树，这里两个树都要保持一样的遍历顺序
            que.push(leftNode->left); 
            que.push(rightNode->left); 
            que.push(leftNode->right);  
            que.push(rightNode->right);  
        }
        return true;
    }
};

```



## 4.24  另一个树的子树

**题目：**给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

**思路：**相当于比较两个树是否一致，同上题思路。

```cpp
//仅改变下主函数即可，与二叉树的对称性跟两个二叉树是否相等思路相同
//一棵二叉树树只有两个子树，即左子树跟右子树
class Solution{
public:
    bool isSubtree(TreeNode* s, TreeNode* t) {
    if (s == NULL && t == NULL) return true;
    if (s == NULL && t != NULL) return false;
    return isSametree(s, t)|| isSubtree(s->left, t)|| isSubtree(s->right, t);
	}
private:
    bool isSametree(TreeNode* s, TreeNode* t){
    if (s == NULL && t == NULL) return true;
    return  s && t && s->val == t->val  && isSametree(s->left, t->left) 
            && isSametree(s->right, t->right);
	}
}
```



+++

## 4.25 左叶子之和

**题目：**计算给定二叉树的所有左叶子之和。

**注意：**叶子节点是指没有左右子节点的节点。

**递归做法：**

```cpp
  class Solution {
  public:
	  int sumOfLeftLeaves(TreeNode* root) {
		  if (root == NULL)  return 0;
		  //左子树的左子叶
		  int leftVal = sumOfLeftLeaves(root->left);
		  //右子树的左子叶
		  int rightVal = sumOfLeftLeaves(root->right);
		  int midVal = 0;
		  if (root->left && !root->left->left && !root->left->right) {
			  midVal = root->left->val;
		  }
		  //这个求和，midVal是取出每次的值，但这个值每次返回到leftVal与rightVal 中
		  int sum = midVal + leftVal + rightVal;
		  return sum;
	  }
  };
//精简代码
  class Solution {
  public:
	  int sumOfLeftLeaves(TreeNode* root) {
		  if (root == NULL)  return 0;
	
		  int midVal = 0;
		  if (root->left && !root->left->left && !root->left->right) {
			  midVal = root->left->val;
		  }
		  return midVal + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
	  }
  };
```



**迭代做法：**

```cpp
//每次感觉迭代方法用的更顺手，更好理解...
class Solution {
  public:
	  int sumOfLeftLeaves(TreeNode* root) {
		  stack<TreeNode*> stk;
		  if (root == NULL)  return 0;
		  stk.push(root);
		  int res = 0;
		  while (!stk.empty()) {
			  TreeNode* curr = stk.top();
			  stk.pop();
			  if (curr->left && !curr->left->left && !curr->left->right) {
				  res += curr->left->val;
			  }
			  if (curr->left) stk.push(curr->left);
			  if (curr->right) stk.push(curr->right);
		  }
		  return res;
	  }
  };
```



## 4.25 找到左下角的值

**题目：**给定一个二叉树，在树的最后一行找到最左边的值。

**思路：**可以用层序遍历，找到最后一行的最左边的值。

**递归做法：**

```cpp
  class Solution {
  public:
	  int maxDepth = INT_MIN;
	  int leftVal;
	  int findBottomLeftValue(TreeNode* root) {
		  traversal(root, 0);
		  return leftVal;
	  }
	  void traversal(TreeNode* curr, int leftLen) {
		  if (curr->left == NULL && curr->right == NULL) {
			  if (leftLen > maxDepth) {
				  //更新最大深度
				  maxDepth = leftLen;  
				  //最大深度的最左面的值
				  leftVal = curr->val;  
			  }
			  return;
		  }
		  if (curr->left) {
			  leftLen++;  //深度 + 1
			  traversal(curr->left, leftLen);
			  leftLen--;  //回溯 - 1，回到上个节点，向下寻找
		  }
		  if (curr->right) {
			  leftLen++;  //深度 + 1
			  traversal(curr->right, leftLen);
			  leftLen--;  //回溯 - 1，回到上个节点，向下寻找
		  }
		  return;
	  }
  };


```





**迭代做法：**

```cpp
  class Solution {
  public:
	  int findBottomLeftValue(TreeNode* root) {
		  if (root == NULL)  return 0;
		  queue<TreeNode*> que;
		  que.push(root);
		  int res = 0;
		  while (!que.empty()) {
			  int size = que.size();
              //总的来看，用for循环比用while循环方便的多，能避免很多不必要的错误
			  for(int i = 0; i < size; i++){
				  TreeNode* curr = que.front();
				  que.pop();
                  //这里的目的是取出每层的第一个值
				  if (i == 0)	  res = curr->val;
				  if (curr->left)  que.push(curr->left);
				  if (curr->right) que.push(curr->right);
			  }
		  }
		  return res;
	  }
  };
```



## 4.25 路径总和

**题目：**给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

**思路：**计算每个路径中的总和。

**递归做法：**

```cpp
  class Solution {
  public:
	  bool hasPathSum(TreeNode* root, int sum) {
		  if (root == NULL) return false;
		  return traversal(root, sum - root->val);
	  }
  private:
	  bool traversal(TreeNode* curr, int count) {
		  //遇到叶子节点且数值为0，则返回找到了
		  if (!curr->left && !curr->right && count == 0) return true;
		  //遇到叶子节点，数值不为0，说明不通，直接返回
		  if (!curr->left && !curr->right) return false;
		  //向左走，同时数值减去当前节点的值，递归下去
		  if (curr->left) {
			  count -= curr->left->val;
			  if (traversal(curr->left, count))  return true;
			  //如果未找到合适的值，则回溯，撤销本次的尝试结果
			  count += curr->left->val; 
		  }
		  if (curr->right) {
			  count -= curr->right->val;
			  if (traversal(curr->right, count))  return true;
			  count += curr->right->val;
		  }
		  return false;
	  }
  };
//代码精简
class Solution{
public:
    bool hasPathSum(TreeNode* root, int sum){
        if(root == NULL)  return false;
        if(!root->left && !root->right && sum == root->val)  return true;
        return hasPathSum(root->left, sum - root->val) 
            || hasPathSum(root->right,sum - root->right->val)
    }
}
```



**迭代做法：**

```cpp
  class Solution {
  public:
	  bool hasPathSum(TreeNode* root, int sum) {
		  if (root == NULL) return false;
		  //栈<节点指针，路径数值>
		  stack<pair<TreeNode*, int >> stk;
		  //将每次该节点的指针（用于遍历）添加进去，将该节点数值与前面节点数值的和（用于比较）添加进去
		  stk.push(make_pair(root, root->val));
		  while (!stk.empty()) {
			  pair<TreeNode*, int> curr = stk.top();
			  stk.pop();
			  if (!curr.first->left && !curr.first->right 
                  && sum == curr.first->val) {
				  return true;
			  }
			  //因为此处curr.secend 即该节点的数值没有变化，故不需要回溯
			  if (curr.first->right) {
				  stk.push(make_pair(curr.first->right, 
                                     curr.second + curr.first->right->val));
			  }
			  if (curr.first->left) {
				  stk.push(make_pair(curr.first->left, 
                                     curr.second + curr.first->left->val));
			  }
		  }
		  return false;
	  }
  };
```



> **「如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。」**

## 4.25 路径总和II

**题目：**给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

**思路：**该题不需要返回值，因为是遍历所有路径，跟找所有路径的思路一致。

```cpp
class Solution {
  public:
	  vector<vector<int>> pathSum(TreeNode* root, int sum) {
		  vector<vector<int>> result;
		  vector<int> path;
		  if (root == NULL) return result;
		  path.push_back(root->val);  
		  traversal(root, sum - root->val, path, result);
		  return result;
	  }
  private:
    // 递归函数不需要返回值，因为我们要遍历整个树
	  void traversal(TreeNode* curr, int count, 
                     vector<int>& path, vector<vector<int>>& res) {
          // 遇到了叶子节点切找到了和为sum的路径
		  if (!curr->left && !curr->right && count == 0) {
			  res.push_back(path);
			  return;
		  }
          // 遇到叶子节点而没有找到合适的边，直接返回
		  if (!curr->left && !curr->right)  return;
		  if (curr->left) {
			  path.push_back(curr->left->val);
			  count -= curr->left->val;
			  traversal(curr->left, count, path, res);
			  count += curr->left->val;
			  path.pop_back();
		  }
		  if (curr->right) {
			  path.push_back(curr->right->val);
			  count -= curr->right->val;
			  traversal(curr->right, count, path, res);
			  count += curr->right->val;
			  path.pop_back();
		  }
		  return;
	  }

  };

```



## 4.25 构造二叉树

**题目：**根据一棵树的中序遍历与后序遍历构造二叉树，你可以假设树中没有重复的元素。

```cpp
class Solution {
private:
    //中序遍历跟后序遍历
    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {
        if (postorder.size() == 0) return NULL;

        // 后序遍历数组最后一个元素，就是当前的中间节点
        int rootValue = postorder[postorder.size() - 1];
        TreeNode* root = new TreeNode(rootValue);

        // 叶子节点
        if (postorder.size() == 1) return root;

        // 找到中序遍历的切割点
        int delimiterIndex;
        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue) break;
        }

        // 切割中序数组
        // 左闭右开区间：[0, delimiterIndex)
        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
        // [delimiterIndex + 1, end)
        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );

        // postorder 舍弃末尾元素
        postorder.resize(postorder.size() - 1);

        // 切割后序数组
        // 依然左闭右开，注意这里使用了左中序数组大小作为切割点
        // [0, leftInorder.size)
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        // [leftInorder.size(), end)
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        root->left = traversal(leftInorder, leftPostorder);
        root->right = traversal(rightInorder, rightPostorder);

        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        return traversal(inorder, postorder);
    }
};

//代码优化
class Solution {
private:
    // 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)
    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {
        if (postorderBegin == postorderEnd) return NULL;

        int rootValue = postorder[postorderEnd - 1];
        TreeNode* root = new TreeNode(rootValue);

        if (postorderEnd - postorderBegin == 1) return root;

        int delimiterIndex;
        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue) break;
        }
        // 切割中序数组
        // 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;

        // 切割后序数组
        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)
        int leftPostorderBegin =  postorderBegin;
        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size
        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)
        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);
        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了

        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);
        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);

        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        // 左闭右开的原则
        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
};

```



## 4.25 构造二叉树II

**题目：**根据一棵树的前序遍历与中序遍历构造二叉树。

注意: 你可以假设树中没有重复的元素。

```cpp
class Solution {
private:
        //前序遍历与中序遍历
        TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& preorder, int preorderBegin, int preorderEnd) {
        if (preorderBegin == preorderEnd) return NULL;

        int rootValue = preorder[preorderBegin]; // 注意用preorderBegin 不要用0
        TreeNode* root = new TreeNode(rootValue);

        if (preorderEnd - preorderBegin == 1) return root;

        int delimiterIndex;
        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue) break;
        }
        // 切割中序数组
        // 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;
        
        // 切割前序数组
        // 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)
        int leftPreorderBegin =  preorderBegin + 1;
        int leftPreorderEnd = preorderBegin + 1 + delimiterIndex - inorderBegin; // 终止位置是起始位置加上中序左区间的大小size
        // 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)
        int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);
        int rightPreorderEnd = preorderEnd; 

        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);
        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);

        return root;
    }

public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (inorder.size() == 0 || preorder.size() == 0) return NULL;

        // 参数坚持左闭右开的原则
        return traversal(inorder, 0, inorder.size(), preorder, 0, preorder.size());
    }
};
```



> 注意：前序遍历跟后序遍历不能唯一确定一颗二叉树！



## 4.25 最大二叉树

**题目：**给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

```cpp
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        TreeNode* node = new TreeNode(0);
        if (nums.size() == 1) {
            node->val = nums[0];
            return node;
        }
        // 找到数组中最大的值和对应的下表
        int maxValue = 0;
        int maxValueIndex = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > maxValue) {
                maxValue = nums[i];
                maxValueIndex = i;
            }
        }
        node->val = maxValue;
        // 最大值所在的下表左区间 构造左子树
        if (maxValueIndex > 0) {
            vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex); 
            node->left = constructMaximumBinaryTree(newVec);
        }
        // 最大值所在的下表右区间 构造右子树
        if (maxValueIndex < (nums.size() - 1)) {
            vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());
            node->right = constructMaximumBinaryTree(newVec);
        }
        return node;
    }
};

//代码优化
class Solution {
private:
    // 在左闭右开区间[left, right)，构造二叉树
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left >= right) return nullptr;

        // 分割点下表：maxValueIndex
        int maxValueIndex = left;
        for (int i = left + 1; i < right; ++i) {
            if (nums[i] > nums[maxValueIndex]) maxValueIndex = i;
        }

        TreeNode* root = new TreeNode(nums[maxValueIndex]);

        // 左闭右开：[left, maxValueIndex)
        root->left = traversal(nums, left, maxValueIndex);

        // 左闭右开：[maxValueIndex + 1, right)
        root->right = traversal(nums, maxValueIndex + 1, right);

        return root;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }
};
```



## 4.25 合并二叉树

**题目：**给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

**递归做法：**

```cpp
//前序遍历
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
        if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
        // 修改了t1的数值和结构
        t1->val += t2->val;                             // 中
        t1->left = mergeTrees(t1->left, t2->left);      // 左
        t1->right = mergeTrees(t1->right, t2->right);   // 右
        return t1;
    }
};

class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        // 重新定义新的节点，不修改原有两个树的结构
        TreeNode* root = new TreeNode(0);
        root->val = t1->val + t2->val;
        root->left = mergeTrees(t1->left, t2->left);
        root->right = mergeTrees(t1->right, t2->right);
        return root;
    }
};
```



**迭代做法：**

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        queue<TreeNode*> que;
        que.push(t1);
        que.push(t2);
        while(!que.empty()) {
            TreeNode* node1 = que.front(); 
            que.pop();
            TreeNode* node2 = que.front(); 
            que.pop();
            // 此时两个节点一定不为空，val相加，赋值给node1
            node1->val += node2->val;

            // 如果两棵树左节点都不为空，加入队列
            if (node1->left != NULL && node2->left != NULL) {
                que.push(node1->left);
                que.push(node2->left);
            }
            // 如果两棵树右节点都不为空，加入队列
            if (node1->right != NULL && node2->right != NULL) {
                que.push(node1->right);
                que.push(node2->right);
            }

            // 当t1的左节点 为空 t2左节点不为空，就赋值过去
            if (node1->left == NULL && node2->left != NULL) {
                node1->left = node2->left;
            }
            // 当t1的右节点 为空 t2右节点不为空，就赋值过去
            if (node1->right == NULL && node2->right != NULL) {
                node1->right = node2->right;
            }
        }
        return t1;
    }
};
```



## 4.25 二叉树中的搜索

**题目：**给定二叉搜索树（BST）的根节点和一个值。你需要在BST中找到节点值等于给定值的节点。返回以该节点为根的子树。如果节点不存在，则返回 NULL。

> 二叉搜索树是一个有序树：
>
> - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
> - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
> - 它的左、右子树也分别为二叉搜索树
>
> 这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。

**递归做法：**

```cpp
TreeNode* searchBST(TreeNode* root, int val) {
    if (root == NULL || root->val == val) return root;
    if (root->val > val) return searchBST(root->left, val);
    if (root->val < val) return searchBST(root->right, val);
    return NULL;
}
```



**迭代做法：**

```cpp
TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
```



+++



## 4.26 验证二叉搜索树

**题目：**给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

```
分析：  例如一个[10,5,1,6,...]的一棵左子树，最底层肯定是在1的位置，此时maxVal = 1，向上递归，maxVal此时为5，满足条件，看一下个递归，右子树为6，maxVal依然小于右子树的值，故成立。
```

**递归做法：**

```cpp
//利用中序遍历，前中后，升序排列
class Solution {
public:
    //这题的核心在于在函数外定义了一个变量，在每次递归的时候，该变量的值能一直保存上次的值
    long long maxVal = LONG_MIN;
    bool isValidBST(TreeNode* root) {
        if(root == nullptr)  return true;
        bool left = isValidBST(root->left);
        if(maxVal < root->val)  maxVal = root->val;
        else return false;
        bool right = isValidBST(root->right);
        return left && right; 
    }
};

//一般做法：
class Solution {
public:
    TreeNode* pre = NULL; // 用来记录前一个节点 
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        bool left = isValidBST(root->left);

        if (pre != NULL && pre->val >= root->val) return false;
        pre = root; // 记录前一个节点

        bool right = isValidBST(root->right);
        return left && right;
    }
};
```



**迭代做法：**

```cpp
//利用中序遍历的迭代法
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* curr = root;
        TreeNode* pre = NULL; // 记录前一个节点
        while (curr != NULL || !st.empty()) {
            if (curr != NULL) {
                st.push(curr);
                curr = curr->left;                // 左
            } else {
                curr = st.top();                 // 中
                st.pop();
                if (pre != NULL && curr->val <= pre->val){
                    return false;
                }
                pre = curr; //保存前一个访问的结点

                curr = curr->right;               // 右
            }
        }
        return true;
    }
};
```



## 4.26 二叉搜索树的最小绝对差

**题目：**给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

**思路：**将所有值添加到vector容器中比较。

**递归做法：**

```cpp
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        v.clear();
        traversal(root);
        if(v.size() < 2)  return 0;
        int res = INT_MAX;
        //比较前后的差值
        for(int i = 1; i < v.size(); i++){
            res = min(res, v[i] - v[i - 1]);
        }
        return res;
    }
private:
    vector<int> v;
    //中序遍历同时收集每个节点的值
    void traversal(TreeNode* node){
        if(node == NULL)  return;
        traversal(node->left);
        v.push_back(node->val);
        traversal(node->right);
    }
};

```



**迭代做法：**

```cpp
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        stack<TreeNode*> stk;
        TreeNode* curr = root;
        TreeNode* pre = NULL;
        int result = INT_MAX;
        while(curr != NULL || !stk.empty()){
            if(curr != NULL){
                stk.push(curr);
                curr = curr->left;
            }else{
                curr = stk.top();
                stk.pop();
                if(pre != NULL){
                    result = min(result, curr->val - pre->val);
                }
                pre = curr ;
                curr = curr->right;
            }
        }
        return result;
    }
};
```



## 4.26 二叉搜索树中的众数

**题目：**给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

**递归做法：**

```cpp
//普通二叉树
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        unordered_map<int, int> map;
        vector<int> result;
        if(root == NULL)  return result;
        searchBST(root, map);
        vector<pair<int, int>> v(map.begin(), map.end());
        sort(v.begin(), v.end(), cmp);
        result.push_back(v[0].first);
        //找出频率最高的那个值
        for(int i = 1; i < v.size(); i++){
            if(v[i].second == v[0].second) {
                result.push_back(v[i].first);
            }else{
                break;
            }
        }
        return result;
    }
private:
    //将数值添加到 map 容器中
    void searchBST(TreeNode* curr, unordered_map<int, int>& map){
        if(curr == NULL)  return;
        map[curr->val]++;
        searchBST(curr->left, map);
        searchBST(curr->right, map);
        return;
    }
    //排序方式  注：map不能排序，要转换成 vector 进行排序
    bool static cmp(const pair<int, int>& a, const pair<int, int> & b){
        return a.second > b.second;
    }
};
```



```cpp
//二叉搜索树
class Solution {
private:
    int maxCount; // 最大频率
    int count; // 统计频率
    TreeNode* pre;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;

        searchBST(cur->left);       // 左
                                    // 中
        if (pre == NULL) { // 第一个节点
            count = 1;
        } else if (pre->val == cur->val) { // 与前一个节点数值相同
            count++;
        } else { // 与前一个节点数值不同
            count = 1;
        }
        pre = cur; // 更新上一个节点

        if (count == maxCount) { // 如果和最大值相同，放进result中
            result.push_back(cur->val);
        }

        if (count > maxCount) { // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur->val);
        }

        searchBST(cur->right);      // 右
        return ;
    }

public:
    vector<int> findMode(TreeNode* root) {
        count = 0; 
        maxCount = 0;
        TreeNode* pre = NULL; // 记录前一个节点
        result.clear();

        searchBST(root);
        return result;
    }
};
```



**迭代做法：**

```cpp
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int maxCount = 0; // 最大频率
        int count = 0; // 统计频率
        vector<int> result;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top();
                st.pop();                       // 中
                if (pre == NULL) { // 第一个节点
                    count = 1;
                } else if (pre->val == cur->val) { // 与前一个节点数值相同
                    count++;
                } else { // 与前一个节点数值不同
                    count = 1;
                }
                if (count == maxCount) { // 如果和最大值相同，放进result中
                    result.push_back(cur->val);
                }

                if (count > maxCount) { // 如果计数大于最大值频率
                    maxCount = count;   // 更新最大频率
                    result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
                    result.push_back(cur->val);
                }
                pre = cur;
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```



## 4.26 二叉树最近的公共祖先

**题目：**给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //如果遍历到最后一个节点，返回
        //若找到合适的节点，返回
        if(root == q || root == p || root == NULL)  return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if(left != NULL && right != NULL)  return root;
        //左边为空，那说明要在右边遍历寻找目标值
        if(left == NULL && right != NULL)  return right;
        //右边为空，则说明要在左边寻找目标值
        else if(left != NULL && right == NULL)  return left;  
        else return NULL;
    }
};
```



## 4.26 二叉搜索树的最近公共祖先

**题目：**给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

**思路：**只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。

**递归做法：**

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
private:
    TreeNode* traversal(TreeNode* curr, TreeNode* p, TreeNode* q){
        if(curr == NULL) return curr;
        //如果节点值大于要寻找的值
        if(curr->val > p->val && curr->val > q->val){
            TreeNode* left = traversal(curr->left, p, q);
            if(left != NULL)  return left;
        }
        //节点值小于寻找的值
        if(curr->val < p->val && curr->val < q->val){
            TreeNode* right = traversal(curr->right, p, q);
            if(right != NULL) return right;
        }
        return curr;
    }
};
```



**迭代做法：**

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root) {
            if (root->val > p->val && root->val > q->val) {
                root = root->left;
            } else if (root->val < p->val && root->val < q->val) {
                root = root->right;
            } else return root;
        }
        return NULL;
    }
};
```



## 4.26 二叉搜索树中的插入

**题目：**给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。返回插入后二叉搜索树的根节点。输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回任意有效的结果。

**递归做法：**

```cpp
//只需要在目标空节点处插入合适的元素即可
//第一种实现
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        if(root->val > val)  root->left = insertIntoBST(root->left, val);
        if(root->val < val)  root->right = insertIntoBST(root->right, val);
        return root;
    }
};
//第二种实现
class Solution {
private:
    TreeNode* parent;
    void traversal(TreeNode* cur, int val) {
        //该节点加入到树中
        if (cur == NULL) {
            TreeNode* node = new TreeNode(val);
            if (val > parent->val) parent->right = node;
            else parent->left = node;
            return;
        }
        parent = cur;  //标记该节点
        if (cur->val > val) traversal(cur->left, val);
        if (cur->val < val) traversal(cur->right, val);
        return;
    }

public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        parent = new TreeNode(0);  //初始化
        if (root == NULL) {
            root = new TreeNode(val);
        }
        traversal(root, val);
        return root;
    }
};
```



**迭代做法：**

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        TreeNode* curr = root;
        TreeNode* parent = root; // 这个很重要，需要记录上一个节点，否则无法赋值新节点
        while (curr != NULL) {
            parent = curr;
            if (curr->val > val) curr = curr->left;
            else curr = curr->right;
        }
        TreeNode* node = new TreeNode(val);
        if (val < parent->val) parent->left = node;// 此时是用parent节点的进行赋值
        else parent->right = node;
        return root;
    }
};
```



## 4.26 二叉搜索树中删除

**题目：**给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；如果找到了，删除它。说明：要求算法时间复杂度为 O(h)，h 为树的高度。

**递归做法：**

```cpp
//搜索二叉树
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        //1. 没找到该节点
       if(root == NULL) return root;
       //找到了该节点
       if(root->val == key){
           //2.左右孩子都为空，返回NULL，这里只写一个就够了
           //若左孩子为空，则返回右孩子，此时，右孩子为NULL
           //3.左孩子为空，返回右孩子
           if(root->left == NULL) return root->right;
           //4.右孩子为空，返回左孩子
           else if(root->right == NULL) return root->left;
           //5.左右孩子不为空，需要将删除的节点的左子树放到删除节点右子树的左孩子位置
           else {
               //遍历当前节点的右子树的左孩子
               TreeNode* curr = root->right;
               //找到左孩子的最后一个节点
               while(curr->left != NULL){
                   curr = curr->left;
               }
               //左孩子的最后一个节点指向被删除节点的左子树，添加完成
               curr->left = root->left;
               //删除节点
               TreeNode* tmp = root;
               root = root->right;
               delete tmp;
               return root;
           }
       } 
       if(root->val > key) root->left = deleteNode(root->left, key);
       if(root->val < key) root->right = deleteNode(root->right,key);
       return root;
    }
};
```



**迭代做法：**

```cpp
class Solution {
private:
    // 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上
    // 并返回目标节点右孩子为新的根节点
    // 是动画里模拟的过程
    TreeNode* deleteOneNode(TreeNode* target) {
        if (target == nullptr) return target;
        if (target->right == nullptr) return target->left;
        TreeNode* cur = target->right;
        while (cur->left) {
            cur = cur->left;
        }
        cur->left = target->left;
        return target->right;
    }
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        TreeNode* cur = root;
        TreeNode* pre = nullptr; // 记录cur的父节点，用来删除cur
        while (cur) {
            if (cur->val == key) break;
            pre = cur;
            if (cur->val > key) cur = cur->left;
            else cur = cur->right;
        }
        if (pre == nullptr) { // 如果搜索树只有头结点
            return deleteOneNode(cur);
        }
        // pre 要知道是删左孩子还是右孩子
        if (pre->left && pre->left->val == key) {
            pre->left = deleteOneNode(cur);
        }
        if (pre->right && pre->right->val == key) {
            pre->right = deleteOneNode(cur);
        }
        return root;
    }
};

```



## 4.26 修剪二叉搜索树

**题目：**给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

**递归做法：**

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr ) return nullptr;
        if (root->val < low) {
            // 寻找符合区间[low, high]的节点
            TreeNode* right = trimBST(root->right, low, high); 
            return right;
        }
        if (root->val > high) {
            // 寻找符合区间[low, high]的节点
            TreeNode* left = trimBST(root->left, low, high); 
            return left;
        }
        // root->left接入符合条件的左孩子
        root->left = trimBST(root->left, low, high); 
        // root->right接入符合条件的右孩子
        root->right = trimBST(root->right, low, high); 
        return root;
    }
};
```



**迭代做法：**

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if (!root) return nullptr;

        // 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭
        while (root->val < L || root->val > R) {
            if (root->val < L) root = root->right; // 小于L往右走
            else root = root->left; // 大于R往左走
        }
        TreeNode *cur = root;
        // 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况
        while (cur != nullptr) {
            while (cur->left && cur->left->val < L) {
                cur->left = cur->left->right;
            }
            cur = cur->left;
        }
        cur = root;

        // 此时root已经在[L, R] 范围内，处理右孩子大于R的情况
        while (cur != nullptr) {
            while (cur->right && cur->right->val > R) {
                cur->right = cur->right->left;
            }
            cur = cur->right;
        }
        return root;
    }
};
```



## 4.26 有序数组转二叉搜索树

**题目：**将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

**递归做法：**

```cpp
class Solution {
private:
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left > right) return NULL;
        int mid = left + ((right - left) / 2); 
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = traversal(nums, left, mid - 1);
        root->right = traversal(nums, mid + 1, right);
        return root;
    }
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root = traversal(nums, 0, nums.size() - 1);
        return root;
    }
};
```



**迭代做法：**

```cpp
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if (nums.size() == 0) return nullptr;

        TreeNode* root = new TreeNode(0);   // 初始根节点
        queue<TreeNode*> nodeQue;           // 放遍历的节点
        queue<int> leftQue;                 // 保存左区间下表
        queue<int> rightQue;                // 保存右区间下表
        nodeQue.push(root);                 // 根节点入队列
        leftQue.push(0);                    // 0为左区间下表初始位置
        rightQue.push(nums.size() - 1);     // nums.size() - 1为右区间下表初始位置

        while (!nodeQue.empty()) {
            TreeNode* curNode = nodeQue.front();
            nodeQue.pop();
            int left = leftQue.front(); leftQue.pop();
            int right = rightQue.front(); rightQue.pop();
            int mid = left + ((right - left) / 2);

            curNode->val = nums[mid];       // 将mid对应的元素给中间节点

            if (left <= mid - 1) {          // 处理左区间
                curNode->left = new TreeNode(0);
                nodeQue.push(curNode->left);
                leftQue.push(left);
                rightQue.push(mid - 1);
            }

            if (right >= mid + 1) {         // 处理右区间
                curNode->right = new TreeNode(0);
                nodeQue.push(curNode->right);
                leftQue.push(mid + 1);
                rightQue.push(right);
            }
        }
        return root;
    }
};
```



## 4.26 把二叉搜索树转换为累加树

**题目：**给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。节点的右子树仅包含键 大于 节点键的节点。左右子树也必须是二叉搜索树。

**递归做法：**

```cpp
//本质上构建一棵树，从原搜索树的右子树逐步求和
class Solution {
private:
    int pre; // 记录前一个节点的数值
    void traversal(TreeNode* curr) { // 右中左遍历
        if (curr == NULL) return;
        traversal(curr->right);
        curr->val += pre;
        pre = curr->val;
        traversal(curr->left);
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        pre = 0;
        traversal(root);
        return root;
    }
};
```



**迭代做法：**

```cpp
class Solution {
private:
    int pre; // 记录前一个节点的数值
    void traversal(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur->right;   // 右
            } else {
                cur = st.top();     // 中
                st.pop();
                cur->val += pre;
                pre = cur->val;
                cur = cur->left;    // 左
            }
        }
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        pre = 0;
        traversal(root);
        return root;
    }
};
```



## -----------回溯算法--------------

### 1. 什么是回溯算法

**回溯可以理解成多分支的递归。**

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。

在二叉树系列中，我们已经不止一次，提到了回溯，例如[二叉树：以为使用了递归，其实还隐藏着回溯](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247484885&idx=1&sn=590b824ec73eb65de22a7dcc98134d26&scene=21#wechat_redirect)。

回溯是递归的副产品，只要有递归就会有回溯。

### 2. 回溯算法的特点

- 回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。
- 即使让回溯法高效一些，例如加一些剪枝的操作，但也改不了回溯法就是穷举的本质。
- 回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！
- 回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。
- 递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。
- 注意：虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。

### 3. 回溯法模板

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



## 4.26 组合

**题目：**给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

**思路：**穷举所有可能。

```cpp
//写完回溯算法，记得查看剪枝  
class Solution {
  public:
	  vector<vector<int>> combine(int n, int k) {
		  result.clear();
		  backtracking(n, k, 1);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes; // 用于存放阶段性结果
	  void backtracking(int n, int k, int start) {
		  //写结束条件
		  /*当递归到最小子问题的时候，即什么时候退出递归*/
		  if (k == tempRes.size()) {
			  result.push_back(tempRes);
			  return;
		  }
		  //写分支，回溯求解
		  for (int i = start; i <= n; i++) {
			  tempRes.push_back(i);
			  backtracking(n, k, i + 1);
			  tempRes.pop_back();
		  }
	  }
  };
```



上面代码可以优化，进行==剪枝操作==：

```cpp
for (int i = start; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置
 //即每次搜索的时候判断一下个数是否符合条件要求
 //本次优化的是起始位置，如果前面已经选择了 m 个元素，那么 i 能选取的最大值为 上所述
 //从起始位置开始算起，用总的个数 - （要求的组合元素的个数 - 已找到元素的个数）+ 1（后移1位）
```



## 4.26 组合总和

**题目：**给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

```cpp
  class Solution {
  public:
	  vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
		  result.clear();
		  tempRes.clear();
		  if (candidates.size() == 0)  return result;
          //排序，将原数组中大于target的值都剔除掉
		  sort(candidates.begin(), candidates.end());
		  int end = candidates.size() - 1;
		  for (int i = 0; i < candidates.size(); i++) {
			  if (candidates[i] > target)  end = i;
		  }
		  backtracking(candidates, 0, end, target);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes;
	  void backtracking(vector<int>& candidates, int start, int end, int target) {
		  //写结束条件
		  /*当递归到最小子问题的时候，即什么时候退出递归*/
		  if (target == 0) {
			  result.push_back(tempRes);
			  return;
		  }
		  if (target < 0)  return;
		  //写分支，回溯求解
		  for (int i = start; i <= end; i++) {
			  tempRes.push_back(candidates[i]);
			  backtracking(candidates, i , end, target - candidates[i]);
			  tempRes.pop_back();
			}
	  }
  };
```



> 循环中可以优化一下：让其不再递归的时候判断是否大于target。
>
> `for(int i = start; i <= end && target >= candidates[i]; i++)`

## 4.26 组合总和II

**题目：**给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

**如果candidate中没有重复元素，那么该算法就是求解能组成target的所有组合。**

```cpp
  class Solution {
  public:
	  vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
		  result.clear();
		  tempRes.clear();
		  if (candidates.size() == 0)  return result;
		  sort(candidates.begin(), candidates.end());
		  int end = candidates.size() - 1;
		  for (int i = 0; i < candidates.size(); i++) {
			  if (candidates[i] > target)  end = i;
		  }
		  backtracking(candidates, 0, end, target);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes;
	  void backtracking(vector<int>& candidates, int start, int end, int target) {
		  //写结束条件
		  /*当递归到最小子问题的时候，即什么时候退出递归*/
		  if (target == 0) {
			  result.push_back(tempRes);
			  return;
		  }
		  if (target < 0)  return;
		  //写分支，回溯求解
		  for (int i = start; i <= end && target >= candidates[i]; i++) {
              //在向下递归的时候，如果相邻的元素相同，就跳过本次循环
			  if (i != start && candidates[i] == candidates[i - 1])	continue;
			  tempRes.push_back(candidates[i]);
			  backtracking(candidates, i + 1, end, target - candidates[i]);
			  tempRes.pop_back();
			}
	  }
  };
```



```cpp
//利用flag标记一下每层是否使用了该元素
 class Solution {
  public:
	  vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
		  result.clear();
		  tempRes.clear();
		  if (candidates.size() == 0)  return result;
		  sort(candidates.begin(), candidates.end());
		  int end = candidates.size() - 1;
		  for (int i = 0; i < candidates.size(); i++) {
			  if (candidates[i] > target)  end = i;
		  }
		  backtracking(candidates, 0, end, target, flag);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes;
      //每次递归的时候都给 这层树的数值打个标记，当回溯的时候，标记要抹去
      //这样就只剩这层树所选用的值有标记了
	  int flag[100] = { 0 }; 
	  void backtracking(vector<int>& candidates, int start, int end, int target, int* flag) {
		  //写结束条件
		  /*当递归到最小子问题的时候，即什么时候退出递归*/
		  if (target == 0) {
			  result.push_back(tempRes);
			  return;
		  }
		  if (target < 0)  return;
		  //写分支，回溯求解
		  for (int i = start; i <= end && target >= candidates[i]; i++) {
			  if (i > 0 && flag[i - 1] == 0 && candidates[i] == candidates[i - 1])
                  continue;
			  tempRes.push_back(candidates[i]);
			  flag[i] = 1;  //同树枝使用 的标记
			  backtracking(candidates, i + 1, end, target - candidates[i],flag);
			  flag[i] = 0;  //回溯，将该标记抹去，剩下树层的标记
			  tempRes.pop_back();
			}
	  }
  };
```



## 4.26 组合总和III

**题目：**找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

```cpp
  class Solution {
  public:
	  vector<vector<int>> combinationSum3(int k, int n) {
		  result.clear();
		  backtracking(n, k, 1);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes; // 用于存放阶段性结果
	  void backtracking(int sum, int k, int start) {
		  //写结束条件
		  /*当递归到最小子问题的时候，即什么时候退出递归*/
		  if (sum == 0 && k == tempRes.size()) {
			  result.push_back(tempRes);
			  return;
		  }
		  if (sum < 0)  return;
		  //写分支，回溯求解
		  for (int i = start; i <= 9 - (k - tempRes.size()) + 1 ; i++) {
			  tempRes.push_back(i);
			  backtracking(sum - i, k, i + 1);
			  tempRes.pop_back();
		  }
	  }
  };
```



## 4.26 电话号码的字母组合

**题目：**给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

其实本题不算难，但也处处是细节，还是要反复琢磨。

```cpp
 class Solution {
  public:
	  vector<string> letterCombinations(string digits) {
		  result.clear();
		  str.clear();
		  if (digits.size() == 0)  return result;
		  backtracking(digits, 0);
		  return result;
	  }
  private:
	  vector<string> result;
	  string str;
	  const string letterMap[10] = {
			"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
	  void backtracking(const string& digits, int start) {
		  //写结束条件
		  /*当递归到最小子问题的时候，即什么时候退出递归*/
		  if (start == digits.size()) {
			  result.push_back(str);
			  return;
		  }
		  //写分支，回溯求解
		  int index = digits[start] - '0';  //将字符串中的数字转换成int格式
		  string letter = letterMap[index]; //将letterMap中数字代表的 字符串取出来
		  for (int i = 0; i < letter.size(); i++) {
			  str += letter[i];
			  backtracking(digits, start + 1);
			  str.pop_back();
			}
	  }
  };
```



+++

## 4.27 分割成回文串

**题目：**给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。

```cpp
 class Solution {
  public:
	  vector<vector<string>> partition(string s) {
		  result.clear();
		  tempRes.clear();
		  if (s.size() == 0)  return result;
		  backtracking(s, 0);
		  return result;
	  }
  private:
	  vector<vector<string>> result;
	  vector<string> tempRes;
	  void backtracking(string s, int start) {
		  //写结束条件
		  /*当递归到最小子问题的时候，即什么时候退出递归*/
		  if (start >= s.size()) {
			  result.push_back(tempRes);
			  return;
		  }
		  //写分支，回溯求解
		  for (int i = start; i < s.size(); i++) {
			  //这里的start 每次递归都会做为起始值传递下去
			  //找到回文串了就添加进结果集，然后找下一个回文子串
			  if (isPalindrome(s, start, i)) {
				  tempRes.push_back(s.substr(start, i - start + 1));
				  backtracking(s, i + 1);
				  tempRes.pop_back();
			  }
		  }
	  }
     //判断分割的串是否是回文串
	  bool isPalindrome(const string& s, int start, int end) {
		  for (int i = start, j = end; i < j; i++, j--) {
			  if (s[i] != s[j])  return false; 
		  }
		  return true;
	  }
  };
```



## 4.27 复原IP地址

**题目：**给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

```cpp
  class Solution {
  public:
	  vector<string> restoreIpAddresses(string s) {
		  result.clear();
		  if (s.size() == 0)  return result;
		  backtracking(s, 0, 0);
		  return result;
	  }
  private:
	  vector<string> result;
	  //本题目需要判断 一下加了多少个分隔符：'.'
	  void backtracking(string s, int start, int point) {
		  //写结束条件
		  /*当递归到最小子问题的时候，即什么时候退出递归*/
		  if (point == 3) {
			  if (isValid(s, start, s.size() - 1))  result.push_back(s);
			  return;
		  }
		  //写分支，回溯求解
		  for (int i = start; i < s.size(); i++) {
			  if (isValid(s, start, i)) {
				  s.insert(s.begin() + i + 1, '.');
				  point++;
				  backtracking(s, i + 2, point);
				  point--;
				  s.erase(s.begin() + i + 1);
			  }
		  }
	  }
      //判断是否为有效值
	  bool isValid(const string& s, int start, int end) {
		  if (start > end)  return false;  //越界舍弃
		  if (s[start] == '0' && start != end)  return false;  //开头不止一个0，舍弃
		  int num = 0;
		  for (int i = start; i <= end; i++) {
			  if (s[i] <'0' || s[i] > '9')  return false;  //非数字，舍弃
			  num = num * 10 + (s[i] - '0');   
			  if (num > 255)	  return false;    //数字大于最大值，舍弃
		  }
		  return true;
	  }
  };
```



## 4.27 子集

**题目：**给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

```cpp
//本题是求所有的子集，是比较简单的，只需要穷举所有可能，添加到结果集中即可。   
class Solution {
  public:
	  vector<vector<int>> subsets(vector<int>& nums) {
		  result.clear();
		  tempRes.clear();
		  if (nums.size() == 0)  return result;
		  backtracking(nums, 0);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes;
	  void backtracking(vector<int>& nums, int start) {
		  //写分支，回溯求解
		  //因为结果集中是有空集的，故先将tempRes添加1次
		  result.push_back(tempRes);
		  for (int i = start; i < nums.size(); i++) {
			  tempRes.push_back(nums[i]);
			  backtracking(nums, i + 1);
			  tempRes.pop_back();
		  }
	  }
	
  };
```



## 4.27 子集II

**题目：**给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

**思路：**与组合总和II思路一致。

```cpp
//本题相较于子集I中，nums多了重复的元素，故只需要将数组排序，遇到相同的元素，则跳过即可
class Solution {
  public:
	  vector<vector<int>> subsetsWithDup(vector<int>& nums) {
		  result.clear();
		  tempRes.clear();
		  if (nums.size() == 0)  return result;
           sort(nums.begin(), nums.end());
		  backtracking(nums, 0);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes;
	  void backtracking(vector<int>& nums, int start) {
		  //写分支，回溯求解
		  //因为结果集中是有空集的，故先将tempRes添加1次
		  result.push_back(tempRes);
		  for (int i = start; i < nums.size(); i++) {
			  if (i != start && nums[i - 1] == nums[i])	 continue;
			  tempRes.push_back(nums[i]);
			  backtracking(nums, i + 1);
			  tempRes.pop_back();
		  }
	  }
	
  };
```



## 4.27 递增子序列

**题目：**给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

> 组合与排列对于重复的元素区别是：组合是遇到重复元素，不再使用；而排列遇到重复元素，下次还要使用之前重复的元素；一个是从==头==开始，一个是从==下一个==开始。

```cpp
//用 unorder_set<int> 来实现
  class Solution {
  public:
	  vector<vector<int>> findSubsequences(vector<int>& nums) {
		  result.clear();
		  tempRes.clear();
		  backtracking(nums, 0);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes;
	  void backtracking(vector<int>& nums, int start) {
		  if (tempRes.size() > 1) {
			  result.push_back(tempRes);
			  // 注意这里不要加return，要取树上的节点
		  }
		  unordered_set<int> uset; // 使用set对本层元素进行去重
		  for (int i = start; i < nums.size(); i++) {
			  if ((!tempRes.empty() && nums[i] < tempRes.back())
				  || uset.find(nums[i]) != uset.end()) {
				  continue;
			  }
			  uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
			  tempRes.push_back(nums[i]);
			  backtracking(nums, i + 1);
			  tempRes.pop_back();
		  }
	  }
 
  };
```



```cpp
//优化，本质不是这样来理解的 
class Solution {
  public:
	  vector<vector<int>> findSubsequences(vector<int>& nums) {
		  result.clear();
		  tempRes.clear();
		  if (nums.size() == 0)  return result;
		  backtracking(nums, 0);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes;
	  void backtracking(vector<int>& nums, int start) {
		  //求所有子集，所以不需要最小转态退出，凡是符合即可加入结果集中
		  //穷举所有可能
		  if (tempRes.size() > 1)  result.push_back(tempRes);
		  //写分支，回溯求解
		  int flag[201] = { 0 };
		  for (int i = start; i < nums.size(); i++) {
			  //这里如果不判断容器为非空的话，在最上层的递归中，tempRes.back()是会报错的
			  if ((!tempRes.empty()  && nums[i] < tempRes.back()) 
                  || flag[nums[i] + 100] == 1)  continue;
			  flag[nums[i] + 100] = 1;
			  tempRes.push_back(nums[i]);
			  backtracking(nums, i + 1);
			  tempRes.pop_back();
			  
		  }
	  }
  };
```



> 树枝去重：树枝的重复元素，应该局限在当前树枝，即每进一个树枝，都要重新记录

## 4.27 排列问题

**题目：**给定一个 没有重复 数字的序列，返回其所有可能的全排列。

**排列问题主要区别在于遍历的时候是从0开始，不是从下一个开始。**

排列问题的关键在于每个数字在每层每枝都要遍历到，不存在我打了标记下一次就不遍历了。

```cpp
  class Solution {
  public:
	  vector<vector<int>> permute(vector<int>& nums) {
		  result.clear();
		  tempRes.clear();
		  if (nums.size() == 0)  return result;
		  backtracking(nums);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes;
	  int flag[100] = { 0 };  //
	  void backtracking(vector<int>& nums) {
		  //写递归结束条件
		  if (tempRes.size() == nums.size()) {
			  result.push_back(tempRes);
			  return;
		  }
		  //写分支，回溯求解
		  for (int i = 0; i < nums.size(); i++) {
			  if (flag[i] == 1)  continue;
			  flag[i] = 1;
			  tempRes.push_back(nums[i]);
			  backtracking(nums);
			  flag[i] = 0;
			  tempRes.pop_back();
			  
		  }
	  }
  };
```



> 本题是树枝去重：即当前树枝遇到重复元素就跳过；故需要在外层记录，每一次递归的数值使用情况，而当回溯的时候，则需要把标记去掉。

## 4.27 排列问题II

**题目：**给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

**要求是解集不能重复，但每个解中给的元素可以有重复。**所以不能用`unorder_set<int>`来做。

```cpp
  class Solution {
  public:
	  vector<vector<int>> permuteUnique(vector<int>& nums) {
		  result.clear();
		  tempRes.clear();
		  if (nums.size() == 0)  return result;
		  sort(nums.begin(), nums.end());
		  backtracking(nums);
		  return result;
	  }
  private:
	  vector<vector<int>> result;
	  vector<int> tempRes;
	  int flag[100] = { 0 };  //在函数外记录每个值的使用情况
	  void backtracking(vector<int>& nums) {
		  //写递归结束条件
		  if (tempRes.size() == nums.size()) {
			  result.push_back(tempRes);
			  return;
		  }
		  //写分支，回溯求解
		  for (int i = 0; i < nums.size(); i++) {
              //这里等于0或者等于1，对于结果本身没有区别，只是查看是否有标记
              //因为下面是没递归依次打一个标记，然后每回溯1次，在取消一次标记
			  if (i > 0 && nums[i] == nums[i - 1] && flag[i - 1] == 1)  continue;
              //因为没都是从 0 开始，所以上面的语句几乎每层的树枝都不会进去，
              //故用下面的语句来保证开始的时候，不加入容器
			  if (flag[i] == 0) { 
				  flag[i] = 1;  //打个标记
				  tempRes.push_back(nums[i]);
				  backtracking(nums);
				  flag[i] = 0;  //当回溯到上层的时候，恢复之前的标记
				  tempRes.pop_back();
			  }
		  
		 }
	  }
  };
```



## 4.27 重新安排行程

**题目：**给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。

```cpp
class Solution {
  private:
	  // unordered_map<出发机场, map<到达机场, 航班次数>> targets
	  unordered_map<string, map<string, int>> targets;
	  bool backtracking(int ticketNum, vector<string>& result) {
		  if (result.size() == ticketNum + 1) {
			  return true;
		  }
		  for (pair<const string, int>& target : targets[result[result.size() - 1]]) {
			  if (target.second > 0) { // 记录到达机场是否飞过了
				  result.push_back(target.first);
				  target.second--;
				  if (backtracking(ticketNum, result)) return true;
				  result.pop_back();
				  target.second++;
			  }
		  }
		  return false;
	  }
  public:
	  vector<string> findItinerary(vector<vector<string>>& tickets) {
		  targets.clear();
		  vector<string> result;
		  for (const vector<string>& vec : tickets) {
			  targets[vec[0]][vec[1]]++; // 记录映射关系
		  }
		  result.push_back("JFK"); // 起始机场
		  backtracking(tickets.size(), result);
		  return result;
	  }
  };

```



## 4.27 N皇后

**题目：**n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

```cpp
class Solution {
  public:
	  vector<vector<string>> solveNQueens(int n) {
		  result.clear();
		  if (n == 0)  return result;
		  //构建一个 n x n 的棋盘，用 '.' 填满
		  vector<string> chessboard(n, string(n ,'.'));
		  backtracking(n, 0, chessboard);
		  return result;
	  }
  private:
	  vector<vector<string>> result;
	  void backtracking(int n, int row, vector<string>& chessboard) {
		  //写递归结束条件
		  if (row == n) {
			  result.push_back(chessboard);
			  return;
		  }
		  for (int col = 0; col < n; col++) {
			  if (isValid(row, col, n, chessboard)) {
				  chessboard[row][col] = 'Q';
				  backtracking(n, row + 1, chessboard);
				  chessboard[row][col] = '.';
			  }
		  }
	  }
	  //检查是否在同一条线上·不用检查行，因为每次行 只放一个值
	  bool isValid(int row, int col, int n, vector<string>& chessboard) {
		  //检查列
		  for (int i = 0; i < row; i++) {
			  if (chessboard[i][col] == 'Q')  return false;
		  }
		  //检查对角
		  for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
			  if (chessboard[i][j] == 'Q') return false;
		  }
		  for (int i = row - 1, j = col + 1; i >= 0 && j <= n; i--, j++) {
			  if (chessboard[i][j] == 'Q')  return false;
		  }
		  return true;
	  }
  };
```



## 4.27 解数独

```cpp
  class Solution {
  public:
	  void solveSudoku(vector<vector<char>>& board) {
		  backtracking(board);
	  }
  private:
	  bool backtracking(vector<vector<char>>& board) {
		  for (int i = 0; i < 9; i++) {
			  for (int j = 0; j < 9; j++) {
				  if (board[i][j] != '.')  continue;
				  for (char k = '1'; k <= '9'; k++) {
					  if (isValid(board, i, j, k)) {
						  board[i][j] = k;
						  if (backtracking(board)) return true;  //找到了合适的
						  board[i][j] = '.';
					  }
				  }
				  return false;  //没有合适的值填入
			  }
		  }
		  return true; // 每个位置都填满了数字
	  }
	  //判断是否有重复元素
	  bool isValid(vector<vector<char>>& board, int row, int col, char val) {
		  //判断行
		  for (int i = 0; i < 9; i++) {
			  if (board[row][i] == val)  return false;
		  }
		  //查看列
		  for (int i = 0; i < 9; i++) {
			  if (board[i][col] == val)  return false;
		  }
		  //查看方格
		  int startRow = (row / 3) * 3;  //每个小方格的起始行 row / 3 * 3
		  int startCol = (col / 3) * 3;  //每个小方格的其实列 col / 3 * 3
		  for (int i = startRow; i < startRow + 3; i++) {  //结束的位置 + 3
			  for (int j = startCol; j < startCol + 3; j++) {
				  if (board[i][j] == val)  return false;
			  }
		  }
		  return  true;
	  }
  };
```

